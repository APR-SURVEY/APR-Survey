['Csv-1', 1, 1, 1, 1, ["@Override public int read() throws IOException { int current = super.read(); if (current == '\\n') { lineCounter++; } lastChar = current;"], ["@Override public int read() throws IOException { int current = super.read(); if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) { lineCounter++; } lastChar = current;"], ["if (current == '\\n') {"], ["if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {"], 'a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java', 'b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java']
['Csv-2', 1, 1, 1, 1, ['"No header mapping was specified, the record values can\'t be accessed by name"); } final Integer index = mapping.get(name); return index != null ? values[index.intValue()] : null; } /**'], ['"No header mapping was specified, the record values can\'t be accessed by name"); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( "Index for header \'%s\' is %d but CSVRecord only has %d values!", name, index.intValue(), values.length)); } } /**'], [''], ['try { } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( "Index for header \'%s\' is %d but CSVRecord only has %d values!", name, index.intValue(), values.length)); }'], 'a/src/main/java/org/apache/commons/csv/CSVRecord.java', 'b/src/main/java/org/apache/commons/csv/CSVRecord.java']
['Csv-3', 1, 1, 1, 1, ['throw new IOException("EOF whilst processing escape sequence"); default: // Now check for meta-characters return c; // indicate unexpected char - available from in.getLastChar() } }'], ['throw new IOException("EOF whilst processing escape sequence"); default: // Now check for meta-characters if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { return c; } // indicate unexpected char - available from in.getLastChar() return END_OF_STREAM; } }'], [''], ['if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { } return END_OF_STREAM;'], 'a/src/main/java/org/apache/commons/csv/Lexer.java', 'b/src/main/java/org/apache/commons/csv/Lexer.java']
['Csv-4', 1, 1, 1, 1, ['* @return a copy of the header map that iterates in column order. */ public Map<String, Integer> getHeaderMap() { return new LinkedHashMap<String, Integer>(this.headerMap); } /**'], ['* @return a copy of the header map that iterates in column order. */ public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } /**'], ['return new LinkedHashMap<String, Integer>(this.headerMap);'], ['return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);'], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['Csv-5', 1, 1, 1, 1, ['*/ public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); out.append(recordSeparator); newRecord = true; }'], ['*/ public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; }'], [''], ['if (recordSeparator != null) { }'], 'a/src/main/java/org/apache/commons/csv/CSVPrinter.java', 'b/src/main/java/org/apache/commons/csv/CSVPrinter.java']
['Csv-6', 1, 1, 1, 1, ['<M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); map.put(entry.getKey(), values[col]); } return map; }'], ['<M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) { map.put(entry.getKey(), values[col]); } } return map; }'], [''], ['if (col < values.length) { }'], 'a/src/main/java/org/apache/commons/csv/CSVRecord.java', 'b/src/main/java/org/apache/commons/csv/CSVRecord.java']
['Csv-7', 2, 2, 2, 2, ['import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap;', '// build the name to index mappings if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } }'], ['import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap;', '// build the name to index mappings if (header != null) { for (int i = 0; i < header.length; i++) { if (hdrMap.containsKey(header[i])) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); } hdrMap.put(header[i], Integer.valueOf(i)); } }'], ['', ''], ['import java.util.Arrays;', 'if (hdrMap.containsKey(header[i])) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); }'], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['Csv-8', 2, 2, 2, 2, ['if (header == null) { this.header = null; } else { this.header = header.clone(); } this.skipHeaderRecord = skipHeaderRecord;', 'throw new IllegalStateException("No quotes mode set but no escape character is set"); } if (header != null) { final Set<String> set = new HashSet<String>(header.length); set.addAll(Arrays.asList(header)); if (set.size() != header.length) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); } } } /**'], ['if (header == null) { this.header = null; } else { Set<String> dupCheck = new HashSet<String>(); for(String hdr : header) { if (!dupCheck.add(hdr)) { throw new IllegalArgumentException("The header contains a duplicate entry: \'" + hdr + "\' in " + Arrays.toString(header)); } } this.header = header.clone(); } this.skipHeaderRecord = skipHeaderRecord;', 'throw new IllegalStateException("No quotes mode set but no escape character is set"); } } /**'], ['', 'if (header != null) { final Set<String> set = new HashSet<String>(header.length); set.addAll(Arrays.asList(header)); if (set.size() != header.length) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); } }'], ['Set<String> dupCheck = new HashSet<String>(); for(String hdr : header) { if (!dupCheck.add(hdr)) { throw new IllegalArgumentException("The header contains a duplicate entry: \'" + hdr + "\' in " + Arrays.toString(header)); } }', ''], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-9', 1, 1, 1, 1, ['* @return the given map. */ <M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) {'], ['* @return the given map. */ <M extends Map<String, String>> M putIn(final M map) { if (mapping == null) { return map; } for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) {'], [''], ['if (mapping == null) { return map; }'], 'a/src/main/java/org/apache/commons/csv/CSVRecord.java', 'b/src/main/java/org/apache/commons/csv/CSVRecord.java']
['Csv-10', 1, 1, 1, 1, ['this.format.validate(); // TODO: Is it a good idea to do this here instead of on the first call to a print method? // It seems a pain to have to track whether the header has already been printed or not. } // ======================================================'], ['this.format.validate(); // TODO: Is it a good idea to do this here instead of on the first call to a print method? // It seems a pain to have to track whether the header has already been printed or not. if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); } } // ======================================================'], [''], ['if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); }'], 'a/src/main/java/org/apache/commons/csv/CSVPrinter.java', 'b/src/main/java/org/apache/commons/csv/CSVPrinter.java']
['Csv-11', 1, 1, 1, 1, ['for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException("The header contains a duplicate name: \\"" + header + "\\" in " + Arrays.toString(headerRecord));'], ['for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException("The header contains a duplicate name: \\"" + header + "\\" in " + Arrays.toString(headerRecord));'], ['final boolean emptyHeader = header.trim().isEmpty();'], ['final boolean emptyHeader = header == null || header.trim().isEmpty();'], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['Csv-12', 1, 1, 1, 1, ['* Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}. * </p> */ public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); /** * Tab-delimited format.'], ['* Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}. * </p> */ public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); /** * Tab-delimited format.'], ['public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);'], ['public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);'], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-13', 2, 2, 2, 2, ['* http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a> */ public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF); /** * Returns true if the given character is a line break character.', 'if (!newRecord) { out.append(format.getDelimiter()); } if (format.isQuoteCharacterSet()) { // the original object is needed so can check for Number printAndQuote(object, value, offset, len); } else if (format.isEscapeCharacterSet()) {'], ['* http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a> */ public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString("\\\\N"); /** * Returns true if the given character is a line break character.', 'if (!newRecord) { out.append(format.getDelimiter()); } if (object == null) { out.append(value); } else if (format.isQuoteCharacterSet()) { // the original object is needed so can check for Number printAndQuote(object, value, offset, len); } else if (format.isEscapeCharacterSet()) {'], ['.withQuote(null).withRecordSeparator(LF);', 'if (format.isQuoteCharacterSet()) {'], ['.withQuote(null).withRecordSeparator(LF).withNullString("\\\\N");', 'if (object == null) { out.append(value); } else if (format.isQuoteCharacterSet()) {'], 'a/src/main/java/org/apache/commons/csv/CSVPrinter.java', 'b/src/main/java/org/apache/commons/csv/CSVPrinter.java']
['Csv-14', 1, 1, 1, 1, ["char c = value.charAt(pos); // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA = %x20-21 / %x23-2B / %x2D-7E if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { quote = true; } else if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now"], ['char c = value.charAt(pos); // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA = %x20-21 / %x23-2B / %x2D-7E if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now'], ["if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {"], ['if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {'], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-15', 1, 1, 1, 1, ["} else { char c = value.charAt(pos); if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now // encapsulate if we start in anything less than '#'. We are being conservative // by including the default comment char too."], ["} else { char c = value.charAt(pos); if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now // encapsulate if we start in anything less than '#'. We are being conservative // by including the default comment char too."], ['if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) {'], ['if (c <= COMMENT) {'], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-16', 4, 4, 4, 4, [' private final Lexer lexer; /** A record buffer for getRecord(). Grows as necessary and is reused. */ private final List<String> recordList = new ArrayList<>();', ' this.format = format; this.lexer = new Lexer(format, new ExtendedBufferedReader(reader)); this.headerMap = this.initializeHeader(); this.characterOffset = characterOffset; this.recordNumber = recordNumber - 1;', '*/ @Override public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() {', 'throw new UnsupportedOperationException(); } }; } /** * Parses the next record from the current point in the stream.'], [' private final Lexer lexer; private final CSVRecordIterator csvRecordIterator; /** A record buffer for getRecord(). Grows as necessary and is reused. */ private final List<String> recordList = new ArrayList<>();', ' this.format = format; this.lexer = new Lexer(format, new ExtendedBufferedReader(reader)); this.csvRecordIterator = new CSVRecordIterator(); this.headerMap = this.initializeHeader(); this.characterOffset = characterOffset; this.recordNumber = recordNumber - 1;', '*/ @Override public Iterator<CSVRecord> iterator() { return csvRecordIterator; } class CSVRecordIterator implements Iterator<CSVRecord> { private CSVRecord current; private CSVRecord getNextRecord() {', 'throw new UnsupportedOperationException(); } }; /** * Parses the next record from the current point in the stream.'], ['', '', 'return new Iterator<CSVRecord>() {', '}'], ['private final CSVRecordIterator csvRecordIterator;', 'this.csvRecordIterator = new CSVRecordIterator();', 'return csvRecordIterator; } class CSVRecordIterator implements Iterator<CSVRecord> {', ''], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['JacksonXml-1', 2, 2, 2, 2, ['// Simple, except that if this is a leaf, need to suppress end: if (_mayBeLeaf) { _mayBeLeaf = false; // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;', '// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null (or, worse, as used to // be done, by swallowing the token) _currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; } } return (_currToken = JsonToken.VALUE_STRING);'], ['// Simple, except that if this is a leaf, need to suppress end: if (_mayBeLeaf) { _mayBeLeaf = false; if (_parsingContext.inArray()) { // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;', '// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null (or, worse, as used to // be done, by swallowing the token) _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } } return (_currToken = JsonToken.VALUE_STRING);'], ['', '_currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken;'], ['if (_parsingContext.inArray()) { _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); }', '_nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT);'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java']
['JacksonXml-2', 4, 4, 4, 4, ['* * @since 2.8 */ /** * Index of the next attribute of the current START_ELEMENT', '} // otherwise need to find START/END_ELEMENT or text String text = _collectUntilTag(); // If we have no/all-whitespace text followed by START_ELEMENT, ignore text if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) { return _initStartElement(); } // For END_ELEMENT we will return text, if any if (text != null) { _textValue = text; return (_currentState = XML_TEXT); } return _handleEndElement(); case XML_ATTRIBUTE_NAME:', 'return (_currentState = XML_ATTRIBUTE_VALUE); case XML_TEXT: // mixed text with other elements // text followed by END_ELEMENT return _handleEndElement(); case XML_END:', '} // for DEBUGGING @Override'], ['* * @since 2.8 */ protected boolean _mixedText; /** * Index of the next attribute of the current START_ELEMENT', '} // otherwise need to find START/END_ELEMENT or text String text = _collectUntilTag(); final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT; // If we have no/all-whitespace text followed by START_ELEMENT, ignore text if (startElementNext) { if (text == null || _allWs(text)) { _mixedText = false; return _initStartElement(); } _mixedText = true; _textValue = text; return (_currentState = XML_TEXT); } // For END_ELEMENT we will return text, if any if (text != null) { _mixedText = false; _textValue = text; return (_currentState = XML_TEXT); } _mixedText = false; return _handleEndElement(); case XML_ATTRIBUTE_NAME:', 'return (_currentState = XML_ATTRIBUTE_VALUE); case XML_TEXT: // mixed text with other elements if (_mixedText){ _mixedText = false; return _initStartElement(); } // text followed by END_ELEMENT return _handleEndElement(); case XML_END:', "} protected boolean _allWs(String str) { final int len = (str == null) ? 0 : str.length(); if (len > 0) { for (int i = 0; i < len; ++i) { if (str.charAt(i) > ' ') { return false; } } } return true; } // for DEBUGGING @Override"], ['', 'if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {', '', ''], ['protected boolean _mixedText;', 'final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT; if (startElementNext) { if (text == null || _allWs(text)) { _mixedText = false; } _mixedText = true; _textValue = text; return (_currentState = XML_TEXT); _mixedText = false; _mixedText = false;', 'if (_mixedText){ _mixedText = false; return _initStartElement(); }', "protected boolean _allWs(String str) { final int len = (str == null) ? 0 : str.length(); if (len > 0) { for (int i = 0; i < len; ++i) { if (str.charAt(i) > ' ') { return false; } } } return true; }"], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java']
['JacksonXml-3', 1, 1, 1, 1, ['} break; case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break; case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) {'], ['} break; case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currToken = JsonToken.VALUE_STRING; return (_currText = _xmlTokens.getText()); case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) {'], ['_currText = _xmlTokens.getText(); break;'], ['return (_currText = _xmlTokens.getText());'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java']
['JacksonXml-4', 1, 1, 1, 1, ['{ // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly // configured root name... if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); } super.serializeValue(jgen, null); }'], ['{ // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly // configured root name... QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, rootName); } super.serializeValue(jgen, null); }'], ['_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);'], ['QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } _initWithRootName((ToXmlGenerator) jgen, rootName);'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java']
['JacksonXml-5', 1, 1, 1, 1, ['super(src); // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy // root name lookup as that may link back to diff version, configuration _rootNameLookup = src._rootNameLookup; } /*'], ['super(src); // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy // root name lookup as that may link back to diff version, configuration _rootNameLookup = new XmlRootNameLookup(); } /*'], ['_rootNameLookup = src._rootNameLookup;'], ['_rootNameLookup = new XmlRootNameLookup();'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java']
['JacksonXml-6', 2, 2, 2, 2, ["} } // Stax2 API only has 'full buffer' write method: // should we consider pretty-printing or not? // base64 encodes up to 3 bytes into a 4 bytes string // we still have < 3 bytes in the buffer private byte[] toFullBuffer(byte[] data, int offset, int len)", 'return result; } /* /**********************************************************'], ['} } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { if (data == null) { writeNull(); return 0; } _verifyValueWrite("write Binary value"); if (_nextName == null) { handleMissingName(); } try { if (_nextIsAttribute) { // Stax2 API only has \'full buffer\' write method: byte[] fullBuffer = toFullBuffer(data, dataLength); _xmlWriter.writeBinaryAttribute("", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer); } else if (checkNextIsUnwrapped()) { // should we consider pretty-printing or not? writeStreamAsBinary(data, dataLength); } else { if (_xmlPrettyPrinter != null) { _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), toFullBuffer(data, dataLength), 0, dataLength); } else { _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart()); writeStreamAsBinary(data, dataLength); _xmlWriter.writeEndElement(); } } } catch (XMLStreamException e) { StaxUtil.throwAsGenerationException(e, this); } return dataLength; } private void writeStreamAsBinary(InputStream data, int len) throws IOException, XMLStreamException { // base64 encodes up to 3 bytes into a 4 bytes string byte[] tmp = new byte[3]; int offset = 0; int read; while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) { offset += read; len -= read; if(offset == 3) { offset = 0; _xmlWriter.writeBinary(tmp, 0, 3); } if (len == 0) { break; } } // we still have < 3 bytes in the buffer if(offset > 0) { _xmlWriter.writeBinary(tmp, 0, offset); } } private byte[] toFullBuffer(byte[] data, int offset, int len)', 'return result; } private byte[] toFullBuffer(InputStream data, final int len) throws IOException { byte[] result = new byte[len]; int offset = 0; for (; offset < len; ) { int count = data.read(result, offset, len - offset); if (count < 0) { _reportError("Too few bytes available: missing "+(len - offset)+" bytes (out of "+len+")"); } offset += count; } return result; } /* /**********************************************************'], ['', ''], ['@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { if (data == null) { writeNull(); return 0; } _verifyValueWrite("write Binary value"); if (_nextName == null) { handleMissingName(); } try { if (_nextIsAttribute) { byte[] fullBuffer = toFullBuffer(data, dataLength); _xmlWriter.writeBinaryAttribute("", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer); } else if (checkNextIsUnwrapped()) { writeStreamAsBinary(data, dataLength); } else { if (_xmlPrettyPrinter != null) { _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), toFullBuffer(data, dataLength), 0, dataLength); } else { _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart()); writeStreamAsBinary(data, dataLength); _xmlWriter.writeEndElement(); } } } catch (XMLStreamException e) { StaxUtil.throwAsGenerationException(e, this); } return dataLength; } private void writeStreamAsBinary(InputStream data, int len) throws IOException, XMLStreamException { byte[] tmp = new byte[3]; int offset = 0; int read; while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) { offset += read; len -= read; if(offset == 3) { offset = 0; _xmlWriter.writeBinary(tmp, 0, 3); } if (len == 0) { break; } } if(offset > 0) { _xmlWriter.writeBinary(tmp, 0, offset); } }', 'private byte[] toFullBuffer(InputStream data, final int len) throws IOException { byte[] result = new byte[len]; int offset = 0; for (; offset < len; ) { int count = data.read(result, offset, len - offset); if (count < 0) { _reportError("Too few bytes available: missing "+(len - offset)+" bytes (out of "+len+")"); } offset += count; } return result; }'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java']
['Math-1', 2, 2, 2, 2, ['if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. throw new FractionConversionException(value, p2, q2); }', 'if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. throw new FractionConversionException(value, p2, q2); }'], ['if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; } throw new FractionConversionException(value, p2, q2); }', 'if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; } throw new FractionConversionException(value, p2, q2); }'], ['', ''], ['if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; }', 'if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; }'], 'a/src/main/java/org/apache/commons/math3/fraction/Fraction.java', 'b/src/main/java/org/apache/commons/math3/fraction/Fraction.java']
['Math-2', 1, 1, 1, 1, ['* size {@code n}, the mean is {@code n * m / N}. */ public double getNumericalMean() { return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); } /**'], ['* size {@code n}, the mean is {@code n * m / N}. */ public double getNumericalMean() { return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize()); } /**'], ['return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();'], ['return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());'], 'a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java']
['Math-3', 1, 1, 1, 1, ['throw new DimensionMismatchException(len, b.length); } // Revert to scalar multiplication. final double[] prodHigh = new double[len]; double prodLowSum = 0;'], ['throw new DimensionMismatchException(len, b.length); } if (len == 1) { // Revert to scalar multiplication. return a[0] * b[0]; } final double[] prodHigh = new double[len]; double prodLowSum = 0;'], [''], ['if (len == 1) { return a[0] * b[0]; }'], 'a/src/main/java/org/apache/commons/math3/util/MathArrays.java', 'b/src/main/java/org/apache/commons/math3/util/MathArrays.java']
['Math-4', 2, 2, 2, 2, [' // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));', ' // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));'], [' // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); if (v1D == null) { return null; } // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));', ' // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); if (v2D == null) { return null; } // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));'], ['', ''], ['if (v1D == null) { return null; }', 'if (v2D == null) { return null; }'], 'a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java', 'b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java']
['Math-5', 1, 1, 1, 1, ['} if (real == 0.0 && imaginary == 0.0) { return NaN; } if (isInfinite) {'], ['} if (real == 0.0 && imaginary == 0.0) { return INF; } if (isInfinite) {'], ['return NaN;'], ['return INF;'], 'a/src/main/java/org/apache/commons/math3/complex/Complex.java', 'b/src/main/java/org/apache/commons/math3/complex/Complex.java']
['Math-6', 12, 12, 12, 12, ['this.checker = checker; evaluations = new Incrementor(0, new MaxEvalCallback()); iterations = new Incrementor(0, new MaxIterCallback()); } /**', '} PointValuePair current = null; int iter = 0; int maxEval = getMaxEvaluations(); while (true) { ++iter; final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { if (checker.converged(iter, previous, current)) { // We have found an optimum. return current; }', 'steepestDescent = newSteepestDescent; // Compute conjugate search direction. if (iter % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone();', ' generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda);', 'double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); int iter = 0; while (true) { ++iter; double fX = fVal; double fX2 = 0;', 'final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { stop = checker.converged(iter, previous, current); } } if (stop) {', 'int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { if (iteration > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i];', 'previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator); ++iteration; } }', ' // iterate until convergence is reached PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) { ++iter; // evaluate the objective function and its jacobian PointVectorValuePair previous = current;', ' // Check convergence. if (previous != null) { converged = checker.converged(iter, previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current;', '// Outer loop. lmPar = 0; boolean firstIteration = true; int iter = 0; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { ++iter; final PointVectorValuePair previous = current; // QR decomposition of the jacobian matrix', '// tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(iter, previous, current)) { setCost(currentCost); return current; }'], ['this.checker = checker; evaluations = new Incrementor(0, new MaxEvalCallback()); iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback()); } /**', '} PointValuePair current = null; int maxEval = getMaxEvaluations(); while (true) { incrementIterationCount(); final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { if (checker.converged(getIterations(), previous, current)) { // We have found an optimum. return current; }', 'steepestDescent = newSteepestDescent; // Compute conjugate search direction. if (getIterations() % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone();', ' generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { incrementIterationCount(); // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda);', 'double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); while (true) { incrementIterationCount(); double fX = fVal; double fX2 = 0;', 'final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { stop = checker.converged(getIterations(), previous, current); } } if (stop) {', 'int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { if (getIterations() > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i];', 'previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator); incrementIterationCount(); } }', ' // iterate until convergence is reached PointVectorValuePair current = null; for (boolean converged = false; !converged;) { incrementIterationCount(); // evaluate the objective function and its jacobian PointVectorValuePair previous = current;', ' // Check convergence. if (previous != null) { converged = checker.converged(getIterations(), previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current;', '// Outer loop. lmPar = 0; boolean firstIteration = true; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { incrementIterationCount(); final PointVectorValuePair previous = current; // QR decomposition of the jacobian matrix', '// tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(getIterations(), previous, current)) { setCost(currentCost); return current; }'], ['iterations = new Incrementor(0, new MaxIterCallback());', 'int iter = 0; ++iter; if (checker.converged(iter, previous, current)) {', 'if (iter % n == 0 ||', '', 'int iter = 0; ++iter;', 'stop = checker.converged(iter, previous, current);', 'if (iteration > 0) {', '++iteration;', 'int iter = 0; ++iter;', 'converged = checker.converged(iter, previous, current);', 'int iter = 0; ++iter;', 'if (checker.converged(iter, previous, current)) {'], ['iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());', 'incrementIterationCount(); if (checker.converged(getIterations(), previous, current)) {', 'if (getIterations() % n == 0 ||', 'incrementIterationCount();', 'incrementIterationCount();', 'stop = checker.converged(getIterations(), previous, current);', 'if (getIterations() > 0) {', 'incrementIterationCount();', 'incrementIterationCount();', 'converged = checker.converged(getIterations(), previous, current);', 'incrementIterationCount();', 'if (checker.converged(getIterations(), previous, current)) {'], 'a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java']
['Math-7', 2, 2, 2, 2, ['final double[] eventY = interpolator.getInterpolatedState().clone(); // advance all event states to current time currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; }'], ['final double[] eventY = interpolator.getInterpolatedState().clone(); // advance all event states to current time for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); } // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; } boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); } if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; return eventT; }'], ['currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop();', 'for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } boolean needReset = currentEvent.reset(eventT, eventY); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }'], ['for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); }', 'boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); }'], 'a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java', 'b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java']
['Math-8', 1, 1, 1, 1, ['* @throws NotStrictlyPositiveException if {@code sampleSize} is not * positive. */ public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample();'], ['* @throws NotStrictlyPositiveException if {@code sampleSize} is not * positive. */ public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final Object[] out = new Object[sampleSize]; for (int i = 0; i < sampleSize; i++) { out[i] = sample();'], ['public T[] sample(int sampleSize) throws NotStrictlyPositiveException { final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);'], ['public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { final Object[] out = new Object[sampleSize];'], 'a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java']
['Math-9', 1, 1, 1, 1, ['* @return a new instance, with reversed direction */ public Line revert() { final Line reverted = new Line(zero, zero.subtract(direction)); return reverted; }'], ['* @return a new instance, with reversed direction */ public Line revert() { final Line reverted = new Line(this); reverted.direction = reverted.direction.negate(); return reverted; }'], ['final Line reverted = new Line(zero, zero.subtract(direction));'], ['final Line reverted = new Line(this); reverted.direction = reverted.direction.negate();'], 'a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java', 'b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java']
['Math-10', 1, 1, 1, 1, ['} // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly }'], ['} // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]); }'], [''], ['result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);'], 'a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java', 'b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java']
['Math-11', 1, 1, 1, 1, ['throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }'], ['throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -0.5 * dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }'], ['return FastMath.pow(2 * FastMath.PI, -dim / 2) *'], ['return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *'], 'a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java']
['Math-12', 2, 2, 2, 2, ['*/ package org.apache.commons.math3.random; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath;', '* @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator { /** Serializable version identifier */ /** Next gaussian. */ private double nextGaussian;'], ['*/ package org.apache.commons.math3.random; import java.io.Serializable; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath;', '* @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator, Serializable { /** Serializable version identifier */ private static final long serialVersionUID = 20130104L; /** Next gaussian. */ private double nextGaussian;'], ['', 'implements RandomGenerator {'], ['import java.io.Serializable;', 'implements RandomGenerator, Serializable { private static final long serialVersionUID = 20130104L;'], 'a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java', 'b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java']
['Math-13', 1, 1, 1, 1, ['* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } }'], ['* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } } }'], [''], ['if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { }'], 'a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java']
['Math-14', 2, 2, 2, 2, ['*/ public Weight(double[] weight) { final int dim = weight.length; weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); for (int i = 0; i < dim; i++) { weightMatrix.setEntry(i, i, weight[i]); } } /**', '* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } }'], ['*/ public Weight(double[] weight) { final int dim = weight.length; weightMatrix = new DiagonalMatrix(weight); } /**', '* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } } }'], ['weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); for (int i = 0; i < dim; i++) { weightMatrix.setEntry(i, i, weight[i]); }', ''], ['weightMatrix = new DiagonalMatrix(weight);', 'if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { }'], 'a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java']
['Math-15', 2, 2, 2, 2, ['/** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d;', '/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); }'], ['/** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ private static final double TWO_POWER_53 = 2 * TWO_POWER_52; /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d;', '/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { return pow(-x, y); }'], ['', 'if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {'], ['private static final double TWO_POWER_53 = 2 * TWO_POWER_52;', 'if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {'], 'a/src/main/java/org/apache/commons/math3/util/FastMath.java', 'b/src/main/java/org/apache/commons/math3/util/FastMath.java']
['Math-16', 3, 3, 3, 3, ["*/ public class FastMath { /** StrictMath.log(Double.MAX_VALUE): {@value} */ /** Archimede's constant PI, ratio of circle circumference to diameter. */ public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { // Avoid overflow (MATH-905). return 0.5 * exp(x); } if (x < -20) { // Avoid overflow (MATH-905). return 0.5 * exp(-x); } final double hiPrec[] = new double[2];', '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { // Avoid overflow (MATH-905). return 0.5 * exp(x); } if (x < -20) { // Avoid overflow (MATH-905). return -0.5 * exp(-x); } if (x == 0) {'], ["*/ public class FastMath { /** StrictMath.log(Double.MAX_VALUE): {@value} */ private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE); /** Archimede's constant PI, ratio of circle circumference to diameter. */ public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(0.5 * x); return (0.5 * t) * t; } else { return 0.5 * exp(x); } } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(-0.5 * x); return (0.5 * t) * t; } else { return 0.5 * exp(-x); } } final double hiPrec[] = new double[2];', '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(0.5 * x); return (0.5 * t) * t; } else { return 0.5 * exp(x); } } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(-0.5 * x); return (-0.5 * t) * t; } else { return -0.5 * exp(-x); } } if (x == 0) {'], ['', 'if (x < -20) {', 'if (x < -20) {'], ['private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);', 'if (x >= LOG_MAX_VALUE) { final double t = exp(0.5 * x); return (0.5 * t) * t; } else { } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { final double t = exp(-0.5 * x); return (0.5 * t) * t; } else { }', 'if (x >= LOG_MAX_VALUE) { final double t = exp(0.5 * x); return (0.5 * t) * t; } else { } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { final double t = exp(-0.5 * x); return (-0.5 * t) * t; } else { }'], 'a/src/main/java/org/apache/commons/math3/util/FastMath.java', 'b/src/main/java/org/apache/commons/math3/util/FastMath.java']
['Math-17', 1, 1, 1, 1, ['* @return product of this and x */ public Dfp multiply(final int x) { return multiplyFast(x); } /** Multiply this by a single digit 0&lt;=x&lt;radix.'], ['* @return product of this and x */ public Dfp multiply(final int x) { if (x >= 0 && x < RADIX) { return multiplyFast(x); } else { return multiply(newInstance(x)); } } /** Multiply this by a single digit 0&lt;=x&lt;radix.'], [''], ['if (x >= 0 && x < RADIX) { } else { return multiply(newInstance(x)); }'], 'a/src/main/java/org/apache/commons/math3/dfp/Dfp.java', 'b/src/main/java/org/apache/commons/math3/dfp/Dfp.java']
['Math-18', 3, 3, 3, 3, ['double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = (x[i] - boundaries[0][i]) / diff; } return res; }', 'double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i] + boundaries[0][i]; } return res; }', 'return true; } for (int i = 0; i < x.length; i++) { if (x[i] < 0) { return false; } if (x[i] > 1.0) { return false; } }'], ['double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = x[i] / diff; } return res; }', 'double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i]; } return res; }', 'return true; } final double[] bLoEnc = encode(boundaries[0]); final double[] bHiEnc = encode(boundaries[1]); for (int i = 0; i < x.length; i++) { if (x[i] < bLoEnc[i]) { return false; } if (x[i] > bHiEnc[i]) { return false; } }'], ['res[i] = (x[i] - boundaries[0][i]) / diff;', 'res[i] = diff * x[i] + boundaries[0][i];', 'if (x[i] < 0) { if (x[i] > 1.0) {'], ['res[i] = x[i] / diff;', 'res[i] = diff * x[i];', 'final double[] bLoEnc = encode(boundaries[0]); final double[] bHiEnc = encode(boundaries[1]); if (x[i] < bLoEnc[i]) { if (x[i] > bHiEnc[i]) {'], 'a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java']
['Math-19', 1, 1, 1, 1, ['boundaries[1] = uB; // Abort early if the normalization will overflow (cf. "encode" method). } } else { // Convert API to internal handling of boundaries.'], ['boundaries[1] = uB; // Abort early if the normalization will overflow (cf. "encode" method). for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } } } else { // Convert API to internal handling of boundaries.'], [''], ['for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } }'], 'a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java']
['Math-20', 1, 1, 1, 1, ['* @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { return decode(x); }'], ['* @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); }'], ['return'], ['return boundaries != null && isRepairMode ? decode(repair(x)) :'], 'a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java']
['Math-21', 3, 3, 3, 3, ['final double[][] c = matrix.getData(); final double[][] b = new double[order][order]; int[] swap = new int[order]; int[] index = new int[order]; for (int i = 0; i < order; ++i) { index[i] = i;', 'for (boolean loop = true; loop;) { // find maximal diagonal element swap[r] = r; for (int i = r + 1; i < order; ++i) { int ii = index[i]; int isi = index[swap[i]]; if (c[ii][ii] > c[isi][isi]) { swap[r] = i; } } // swap elements if (swap[r] != r) { int tmp = index[r]; index[r] = index[swap[r]]; index[swap[r]] = tmp; } // check diagonal element', 'final double sqrt = FastMath.sqrt(c[ir][ir]); b[r][r] = sqrt; final double inverse = 1 / sqrt; for (int i = r + 1; i < order; ++i) { final int ii = index[i]; final double e = inverse * c[ii][ir]; b[i][r] = e; c[ii][ii] -= e * e; for (int j = r + 1; j < i; ++j) { final int ij = index[j]; final double f = c[ii][ij] - e * b[j][r];'], ['final double[][] c = matrix.getData(); final double[][] b = new double[order][order]; int[] index = new int[order]; for (int i = 0; i < order; ++i) { index[i] = i;', 'for (boolean loop = true; loop;) { // find maximal diagonal element int swapR = r; for (int i = r + 1; i < order; ++i) { int ii = index[i]; int isr = index[swapR]; if (c[ii][ii] > c[isr][isr]) { swapR = i; } } // swap elements if (swapR != r) { final int tmpIndex = index[r]; index[r] = index[swapR]; index[swapR] = tmpIndex; final double[] tmpRow = b[r]; b[r] = b[swapR]; b[swapR] = tmpRow; } // check diagonal element', 'final double sqrt = FastMath.sqrt(c[ir][ir]); b[r][r] = sqrt; final double inverse = 1 / sqrt; final double inverse2 = 1 / c[ir][ir]; for (int i = r + 1; i < order; ++i) { final int ii = index[i]; final double e = inverse * c[ii][ir]; b[i][r] = e; c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2; for (int j = r + 1; j < i; ++j) { final int ij = index[j]; final double f = c[ii][ij] - e * b[j][r];'], ['int[] swap = new int[order];', 'swap[r] = r; int isi = index[swap[i]]; if (c[ii][ii] > c[isi][isi]) { swap[r] = i; if (swap[r] != r) { int tmp = index[r]; index[r] = index[swap[r]]; index[swap[r]] = tmp;', 'c[ii][ii] -= e * e;'], ['', 'int swapR = r; int isr = index[swapR]; if (c[ii][ii] > c[isr][isr]) { swapR = i; if (swapR != r) { final int tmpIndex = index[r]; index[r] = index[swapR]; index[swapR] = tmpIndex; final double[] tmpRow = b[r]; b[r] = b[swapR]; b[swapR] = tmpRow;', 'final double inverse2 = 1 / c[ir][ir]; c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;'], 'a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java', 'b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java']
['Math-22', 2, 2, 2, 2, [' /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { return true; } /** {@inheritDoc} */', ' /** {@inheritDoc} */ public boolean isSupportUpperBoundInclusive() { return false; } /**'], [' /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { return false; } /** {@inheritDoc} */', ' /** {@inheritDoc} */ public boolean isSupportUpperBoundInclusive() { return true; } /**'], ['return true;', 'return false;'], ['return false;', 'return true;'], 'a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java']
['Math-23', 3, 3, 3, 3, ['UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); // Best point encountered so far (which is the initial guess). int iter = 0; while (true) {', '// User-defined convergence checker. previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); if (checker != null) { if (checker.converged(iter, previous, current)) { return best(current, previous, isMinim); } }', "} } } else { // Default termination (Brent's criterion). return best(current, previous, isMinim); } ++iter;"], ['UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); // Best point encountered so far (which is the initial guess). UnivariatePointValuePair best = current; int iter = 0; while (true) {', '// User-defined convergence checker. previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); best = best(best, best(current, previous, isMinim), isMinim); if (checker != null) { if (checker.converged(iter, previous, current)) { return best; } }', "} } } else { // Default termination (Brent's criterion). return best(best, best(current, previous, isMinim), isMinim); } ++iter;"], ['', 'return best(current, previous, isMinim);', 'return'], ['UnivariatePointValuePair best = current;', 'best = best(best, best(current, previous, isMinim), isMinim); return best;', 'return best(best, isMinim),'], 'a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java']
['Math-24', 2, 2, 2, 2, [' if (checker != null) { if (checker.converged(iter, previous, current)) { return current; } }', "} } } else { // Default termination (Brent's criterion). return current; } ++iter; }"], [' if (checker != null) { if (checker.converged(iter, previous, current)) { return best(current, previous, isMinim); } }', "} } } else { // Default termination (Brent's criterion). return best(current, previous, isMinim); } ++iter; }"], ['return current;', 'return current;'], ['return best(current, previous, isMinim);', 'return best(current, previous, isMinim);'], 'a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java']
['Math-25', 1, 1, 1, 1, ['} a = 0.5 * (yMax - yMin); } else { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3);'], ['} a = 0.5 * (yMax - yMin); } else { if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); } a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3);'], [''], ['if (c2 == 0) { throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); }'], 'a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java', 'b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java']
['Math-26', 2, 2, 2, 2, ['long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); }', 'long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((p2 > overflow) || (q2 > overflow)) { throw new FractionConversionException(value, p2, q2); }'], ['long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (FastMath.abs(a0) > overflow) { throw new FractionConversionException(value, a0, 1l); }', 'long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { throw new FractionConversionException(value, p2, q2); }'], ['if (a0 > overflow) {', 'if ((p2 > overflow) || (q2 > overflow)) {'], ['if (FastMath.abs(a0) > overflow) {', 'if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {'], 'a/src/main/java/org/apache/commons/math3/fraction/Fraction.java', 'b/src/main/java/org/apache/commons/math3/fraction/Fraction.java']
['Math-27', 1, 1, 1, 1, ['* @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { return multiply(100).doubleValue(); } /**'], ['* @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { return 100 * doubleValue(); } /**'], ['return multiply(100).doubleValue();'], ['return 100 * doubleValue();'], 'a/src/main/java/org/apache/commons/math3/fraction/Fraction.java', 'b/src/main/java/org/apache/commons/math3/fraction/Fraction.java']
['Math-28', 4, 4, 4, 4, ["// there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset();", "} } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index", '// Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) {', '} } return minRow; } return minRatioPositions.get(0); }'], ["// there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis if (tableau.getNumArtificialVariables() > 0) { for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset();", "} } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index", '// Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. if (getIterations() < getMaxIterations() / 2) { Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) {', '} } return minRow; } } return minRatioPositions.get(0); }'], ['', '', '', ''], ['if (tableau.getNumArtificialVariables() > 0) {', '}', 'if (getIterations() < getMaxIterations() / 2) {', '}'], 'a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java', 'b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java']
['Math-29', 2, 2, 2, 2, ['* this only. Indeed, if this[i] = 0d and v[i] = 0d, then * this[i] / v[i] = NaN, and not 0d. */ Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); } return res; }', '* * These special cases are handled below. */ return res; }'], ['* this only. Indeed, if this[i] = 0d and v[i] = 0d, then * this[i] / v[i] = NaN, and not 0d. */ final int n = getDimension(); for (int i = 0; i < n; i++) { res.setEntry(i, this.getEntry(i) / v.getEntry(i)); } return res; }', '* * These special cases are handled below. */ if (v.isNaN() || v.isInfinite()) { final int n = getDimension(); for (int i = 0; i < n; i++) { final double y = v.getEntry(i); if (Double.isNaN(y)) { res.setEntry(i, Double.NaN); } else if (Double.isInfinite(y)) { final double x = this.getEntry(i); res.setEntry(i, x * y); } } } return res; }'], ['Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));', ''], ['final int n = getDimension(); for (int i = 0; i < n; i++) { res.setEntry(i, this.getEntry(i) / v.getEntry(i));', 'if (v.isNaN() || v.isInfinite()) { final int n = getDimension(); for (int i = 0; i < n; i++) { final double y = v.getEntry(i); if (Double.isNaN(y)) { res.setEntry(i, Double.NaN); } else if (Double.isInfinite(y)) { final double x = this.getEntry(i); res.setEntry(i, x * y); } } }'], 'a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java', 'b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java']
['Math-30', 1, 1, 1, 1, ['final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0;'], ['final int n2) throws ConvergenceException, MaxCountExceededException { final double n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0;'], ['final int n1n2prod = n1 * n2;'], ['final double n1n2prod = n1 * n2;'], 'a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java', 'b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java']
['Math-31', 3, 3, 3, 3, [' int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;', "final double a = getA(n, x); final double b = getB(n, x); double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) { // Can't scale throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } for (int i = 0; i < maxPower; i++) { lastScaleFactor = scaleFactor; scaleFactor *= scale; if (a != 0.0 && a > b) { cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); } else if (b != 0) { cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; } if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { break; } } } final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN; if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,", 'break; } dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2; n++; }'], [' int n = 1; double dPrev = 0.0; double cPrev = hPrev; double hN = hPrev;', 'final double a = getA(n, x); final double b = getB(n, x); double dN = a + b * dPrev; if (Precision.equals(dN, 0.0, small)) { dN = small; } double cN = a + b / cPrev; if (Precision.equals(cN, 0.0, small)) { cN = small; } dN = 1 / dN; final double deltaN = cN * dN; hN = hPrev * deltaN; if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,', 'break; } dPrev = dN; cPrev = cN; hPrev = hN; n++; }'], ['double p0 = 1.0; double q1 = 1.0;', "double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) { // Can't scale throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } for (int i = 0; i < maxPower; i++) { lastScaleFactor = scaleFactor; scaleFactor *= scale; if (a != 0.0 && a > b) { cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); } else if (b != 0) { cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; } if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { break; } } final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN;", 'dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2;'], ['', 'double dN = a + b * dPrev; if (Precision.equals(dN, 0.0, small)) { dN = small; } double cN = a + b / cPrev; if (Precision.equals(cN, 0.0, small)) { cN = small; dN = 1 / dN; final double deltaN = cN * dN; hN = hPrev * deltaN;', 'dPrev = dN; cPrev = cN; hPrev = hN;'], 'a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java', 'b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java']
['Math-32', 1, 1, 1, 1, [' if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);'], [' if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if (tree.getCut() == null && (Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);'], ['if ((Boolean) tree.getAttribute()) {'], ['if (tree.getCut() == null && (Boolean) tree.getAttribute()) {'], 'a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java', 'b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java']
['Math-33', 1, 1, 1, 1, ['// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } }'], ['// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, epsilon) > 0) { columnsToDrop.add(i); } }'], ['if (Precision.compareTo(entry, 0d, maxUlps) > 0) {'], ['if (Precision.compareTo(entry, 0d, epsilon) > 0) {'], 'a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java', 'b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java']
['Math-34', 1, 1, 1, 1, ['* @return chromosome iterator */ public Iterator<Chromosome> iterator() { return chromosomes.iterator(); } }'], ['* @return chromosome iterator */ public Iterator<Chromosome> iterator() { return getChromosomes().iterator(); } }'], ['return chromosomes.iterator();'], ['return getChromosomes().iterator();'], 'a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java', 'b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java']
['Math-35', 2, 2, 2, 2, ['final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); this.elitismRate = elitismRate; } /**', '*/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); this.elitismRate = elitismRate; } /**'], ['final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); setElitismRate(elitismRate); } /**', '*/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); setElitismRate(elitismRate); } /**'], ['this.elitismRate = elitismRate;', 'this.elitismRate = elitismRate;'], ['setElitismRate(elitismRate);', 'setElitismRate(elitismRate);'], 'a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java', 'b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java']
['Math-36', 2, 2, 2, 2, ['@Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. return result; }', '@Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. return result; }'], ['@Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Double.MAX_EXPONENT; result = numerator.shiftRight(shift).doubleValue() / denominator.shiftRight(shift).doubleValue(); } return result; }', '@Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Float.MAX_EXPONENT; result = numerator.shiftRight(shift).floatValue() / denominator.shiftRight(shift).floatValue(); } return result; }'], ['', ''], ['if (Double.isNaN(result)) { int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Double.MAX_EXPONENT; result = numerator.shiftRight(shift).doubleValue() / denominator.shiftRight(shift).doubleValue(); }', 'if (Double.isNaN(result)) { int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Float.MAX_EXPONENT; result = numerator.shiftRight(shift).floatValue() / denominator.shiftRight(shift).floatValue(); }'], 'a/src/main/java/org/apache/commons/math/fraction/BigFraction.java', 'b/src/main/java/org/apache/commons/math/fraction/BigFraction.java']
['Math-37', 2, 2, 2, 2, ['* @since 1.2 */ public Complex tan() { if (isNaN) { return NaN; } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary;', '* @since 1.2 */ public Complex tanh() { if (isNaN) { return NaN; } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);'], ['* @since 1.2 */ public Complex tan() { if (isNaN || Double.isInfinite(real)) { return NaN; } if (imaginary > 20.0) { return createComplex(0.0, 1.0); } if (imaginary < -20.0) { return createComplex(0.0, -1.0); } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary;', '* @since 1.2 */ public Complex tanh() { if (isNaN || Double.isInfinite(imaginary)) { return NaN; } if (real > 20.0) { return createComplex(1.0, 0.0); } if (real < -20.0) { return createComplex(-1.0, 0.0); } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);'], ['if (isNaN) {', 'if (isNaN) {'], ['if (isNaN || Double.isInfinite(real)) { if (imaginary > 20.0) { return createComplex(0.0, 1.0); } if (imaginary < -20.0) { return createComplex(0.0, -1.0); }', 'if (isNaN || Double.isInfinite(imaginary)) { if (real > 20.0) { return createComplex(1.0, 0.0); } if (real < -20.0) { return createComplex(-1.0, 0.0); }'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-38', 2, 2, 2, 2, ['final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; throw new PathIsExploredException(); // XXX } final int iptMinus1 = ipt; final int jptMinus1 = jpt; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); }', 'final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim'], ['final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; // throw new PathIsExploredException(); // XXX } final int iptMinus1 = ipt - 1; final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); }', 'final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); // throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim'], ['throw new PathIsExploredException(); // XXX final int iptMinus1 = ipt; final int jptMinus1 = jpt;', 'throw new PathIsExploredException(); // XXX'], ['// throw new PathIsExploredException(); // XXX final int iptMinus1 = ipt - 1; final int jptMinus1 = jpt - 1;', '// throw new PathIsExploredException(); // XXX'], 'a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java']
['Math-39', 1, 1, 1, 1, ['} stepSize = hNew; // next stages for (int k = 1; k < stages; ++k) {'], ['} stepSize = hNew; if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } } // next stages for (int k = 1; k < stages; ++k) {'], [''], ['if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } }'], 'a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java']
['Math-40', 1, 1, 1, 1, ['double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this targetY = -REDUCTION_FACTOR * yA; } else { // bracketing is balanced, try to find the root itself targetY = 0;'], ['double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB); } else { // bracketing is balanced, try to find the root itself targetY = 0;'], ['targetY = -REDUCTION_FACTOR * yB; targetY = -REDUCTION_FACTOR * yA;'], ['final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java']
['Math-41', 1, 1, 1, 1, ['} double sumWts = 0; for (int i = 0; i < weights.length; i++) { sumWts += weights[i]; }'], ['} double sumWts = 0; for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; }'], ['for (int i = 0; i < weights.length; i++) {'], ['for (int i = begin; i < begin + length; i++) {'], 'a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java', 'b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java']
['Math-42', 1, 1, 1, 1, ['continue; } Integer basicRow = getBasicRow(colIndex); // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);'], ['continue; } Integer basicRow = getBasicRow(colIndex); if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function coefficients[i] = 0; } else if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);'], ['if (basicRows.contains(basicRow)) {'], ['if (basicRow != null && basicRow == 0) { coefficients[i] = 0; } else if (basicRows.contains(basicRow)) {'], 'a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-43', 1, 1, 1, 1, ['secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these if (!(meanImpl instanceof Mean)) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { varianceImpl.increment(value); } if (!(geoMeanImpl instanceof GeometricMean)) { geoMeanImpl.increment(value); } n++;'], ['secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these if (meanImpl != mean) { meanImpl.increment(value); } if (varianceImpl != variance) { varianceImpl.increment(value); } if (geoMeanImpl != geoMean) { geoMeanImpl.increment(value); } n++;'], ['if (!(meanImpl instanceof Mean)) { if (!(varianceImpl instanceof Variance)) { if (!(geoMeanImpl instanceof GeometricMean)) {'], ['if (meanImpl != mean) { if (varianceImpl != variance) { if (geoMeanImpl != geoMean) {'], 'a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java', 'b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java']
['Math-44', 3, 3, 3, 3, [' double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); resetOccurred = false; // initialize the events states if needed if (! statesInitialized) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; }', 'System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; return eventT; }'], [' double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); // initialize the events states if needed if (! statesInitialized) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; }', 'System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; }'], ['resetOccurred = false;', '', ''], ['', 'for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }', 'for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }'], 'a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java']
['Math-45', 1, 1, 1, 1, ['*/ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);'], ['*/ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); } this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);'], [''], ['long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); }'], 'a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java', 'b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java']
['Math-46', 2, 2, 2, 2, [' if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 return isZero ? NaN : INF; } if (divisor.isInfinite() && !isInfinite()) {', '} if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 return isZero ? NaN : INF; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], [' if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 return NaN; } if (divisor.isInfinite() && !isInfinite()) {', '} if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], ['return isZero ? NaN : INF;', 'return isZero ? NaN : INF;'], ['return NaN;', 'return NaN;'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-47', 4, 4, 4, 4, ['/** Record whether this complex number is infinite. */ private final transient boolean isInfinite; /** Record whether this complex number is zero. */ /** * Create a complex number given only the real part.', 'isNaN = Double.isNaN(real) || Double.isNaN(imaginary); isInfinite = !isNaN && (Double.isInfinite(real) || Double.isInfinite(imaginary)); } /**', 'return NaN; } if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) { return NaN; } if (divisor.isInfinite() && !isInfinite()) {', 'return NaN; } if (divisor == 0d) { return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], ['/** Record whether this complex number is infinite. */ private final transient boolean isInfinite; /** Record whether this complex number is zero. */ private final transient boolean isZero; /** * Create a complex number given only the real part.', 'isNaN = Double.isNaN(real) || Double.isNaN(imaginary); isInfinite = !isNaN && (Double.isInfinite(real) || Double.isInfinite(imaginary)); isZero = real == 0 && imaginary == 0; } /**', 'return NaN; } if (divisor.isZero) { return isZero ? NaN : INF; } if (divisor.isInfinite() && !isInfinite()) {', 'return NaN; } if (divisor == 0d) { return isZero ? NaN : INF; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], ['', '', 'if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) { return NaN;', 'return NaN;'], ['private final transient boolean isZero;', 'isZero = real == 0 && imaginary == 0;', 'if (divisor.isZero) { return isZero ? NaN : INF;', 'return isZero ? NaN : INF;'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-48', 1, 1, 1, 1, ['case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. break; default: // Should never happen.'], ['case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. if (x == x1) { throw new ConvergenceException(); } break; default: // Should never happen.'], [''], ['if (x == x1) { throw new ConvergenceException(); }'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java']
['Math-49', 4, 4, 4, 4, ['public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));', 'public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]);', 'public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));', 'public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);'], ['public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));', 'public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]);', 'public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));', 'public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);'], ['Iterator iter = res.entries.iterator();', 'Iterator iter = res.entries.iterator();', 'Iterator iter = res.entries.iterator();', 'Iterator iter = res.entries.iterator();'], ['Iterator iter = entries.iterator();', 'Iterator iter = entries.iterator();', 'Iterator iter = entries.iterator();', 'Iterator iter = entries.iterator();'], 'a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java', 'b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java']
['Math-50', 1, 1, 1, 1, ['break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen.'], ['break; case REGULA_FALSI: // Nothing. break; default: // Should never happen.'], ['if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }'], [''], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java']
['Math-51', 1, 1, 1, 1, ['case PEGASUS: f0 *= f1 / (f1 + fx); break; // Update formula cannot make any progress: Update the // search interval. default: // Should never happen. } } // Update from [x0, x1] to [x0, x].'], ['case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); // Update formula cannot make any progress: Update the // search interval. x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x].'], [''], ['case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; throw new MathInternalError();'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java']
['Math-52', 2, 2, 2, 2, ['Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3 = u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2);', 'Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c == 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;'], ['Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3 = u1.crossProduct(u2); double c = k.dotProduct(u3); final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2);', 'Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c <= 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;'], ['if (c == 0) {', 'if (c == 0) { if (c == 0) {'], ['final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {', 'if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { if (c <= 0) {'], 'a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java', 'b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java']
['Math-53', 1, 1, 1, 1, ['public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }'], ['public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); if (isNaN || rhs.isNaN) { return NaN; } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }'], [''], ['if (isNaN || rhs.isNaN) { return NaN; }'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-54', 2, 2, 2, 2, ['// Zero or sub-normal if (x == 0) { // make sure 0 has the right sign return; }', ' Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }'], ['// Zero or sub-normal if (x == 0) { // make sure 0 has the right sign if ((bits & 0x8000000000000000L) != 0) { sign = -1; } return; }', ' Dfp y = this; boolean negate = false; int cmp0 = compare(this, getZero()); if (cmp0 == 0) { return sign < 0 ? -0.0 : +0.0; } else if (cmp0 < 0) { y = negate(); negate = true; }'], ['', 'if (lessThan(getZero())) {'], ['if ((bits & 0x8000000000000000L) != 0) { sign = -1; }', 'int cmp0 = compare(this, getZero()); if (cmp0 == 0) { return sign < 0 ? -0.0 : +0.0; } else if (cmp0 < 0) {'], 'a/src/main/java/org/apache/commons/math/dfp/Dfp.java', 'b/src/main/java/org/apache/commons/math/dfp/Dfp.java']
['Math-55', 2, 2, 2, 2, ['*/ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) { // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute', '// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); }'], ['*/ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) { final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp); // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute', '// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2); }'], ['', 'return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);'], ['final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp);', 'final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);'], 'a/src/main/java/org/apache/commons/math/geometry/Vector3D.java', 'b/src/main/java/org/apache/commons/math/geometry/Vector3D.java']
['Math-56', 1, 1, 1, 1, ['indices[i] = idx; } int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; return indices; }'], ['indices[i] = idx; } indices[last] = index - count; return indices; }'], ['int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;'], ['indices[last] = index - count;'], 'a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java', 'b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java']
['Math-57', 1, 1, 1, 1, ['while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. int sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);'], ['while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);'], ['int sum = 0;'], ['double sum = 0;'], 'a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java', 'b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java']
['Math-58', 1, 1, 1, 1, ['*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); return fit(new Gaussian.Parametric(), guess); } /**'], ['*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); return fit(guess); } /**'], ['return fit(new Gaussian.Parametric(), guess);'], ['return fit(guess);'], 'a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java', 'b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java']
['Math-59', 1, 1, 1, 1, ['* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); } /** Compute the maximum of two values'], ['* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); } /** Compute the maximum of two values'], ['return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);'], ['return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);'], 'a/src/main/java/org/apache/commons/math/util/FastMath.java', 'b/src/main/java/org/apache/commons/math/util/FastMath.java']
['Math-60', 1, 1, 1, 1, ['*/ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } } } /**'], ['*/ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; } return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } /**'], ['try { } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }'], ['if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; }'], 'a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java', 'b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java']
['Math-61', 2, 2, 2, 2, ['import java.io.Serializable; import org.apache.commons.math.MathException; import org.apache.commons.math.MathRuntimeException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils;', '*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));'], ['import java.io.Serializable; import org.apache.commons.math.MathException; import org.apache.commons.math.exception.NotStrictlyPositiveException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils;', '*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));'], ['import org.apache.commons.math.MathRuntimeException;', 'throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);'], ['import org.apache.commons.math.exception.NotStrictlyPositiveException;', 'throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);'], 'a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java', 'b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java']
['Math-62', 2, 2, 2, 2, ['final GoalType goal, final double min, final double max) throws FunctionEvaluationException { return optimize(f, goal, min, max, 0); } /** {@inheritDoc} */', '// Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {'], ['final GoalType goal, final double min, final double max) throws FunctionEvaluationException { return optimize(f, goal, min, max, min + 0.5 * (max - min)); } /** {@inheritDoc} */', '// Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {'], ['return optimize(f, goal, min, max, 0);', 'final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));'], ['return optimize(f, goal, min, max, min + 0.5 * (max - min));', 'final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, min, max, s);'], 'a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java']
['Math-63', 1, 1, 1, 1, ['* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { return (Double.isNaN(x) && Double.isNaN(y)) || x == y; } /**'], ['* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { return equals(x, y, 1); } /**'], ['return (Double.isNaN(x) && Double.isNaN(y)) || x == y;'], ['return equals(x, y, 1);'], 'a/src/main/java/org/apache/commons/math/util/MathUtils.java', 'b/src/main/java/org/apache/commons/math/util/MathUtils.java']
['Math-64', 10, 10, 10, 10, ['double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols];', 'boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix', "qrDecomposition(); // compute Qt.res qTy(residuals); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) {", 'if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); }', '} if (maxCosine <= orthoTolerance) { // convergence has been reached return current; }', 'double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; // determine the Levenberg-Marquardt parameter determineLMParameter(oldRes, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction double lmNorm = 0;', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); // compute the scaled actual reduction double actRed = -1.0;', 'xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); // tests for convergence. // we use the vectorial convergence checker } else { // failed iteration, reset the previous values cost = previousCost;', 'tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) &&', '(delta <= parRelativeTolerance * xNorm)) { return current; } } else { if (checker.converged(getIterations(), previous, current)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] oldObj = new double[rows]; double[] qtf = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols];', 'boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { for (int i=0;i<rows;i++) { qtf[i]=residuals[i]; } incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix', "qrDecomposition(); // compute Qt.res qTy(qtf); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) {", 'if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qtf[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); }', '} if (maxCosine <= orthoTolerance) { // convergence has been reached updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); return current; }', 'double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; tmpVec = objective; objective = oldObj; oldObj = tmpVec; // determine the Levenberg-Marquardt parameter determineLMParameter(qtf, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction double lmNorm = 0;', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); // compute the scaled actual reduction double actRed = -1.0;', 'xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); current = new VectorialPointValuePair(point, objective); // tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(getIterations(), previous, current)) { return current; } } } else { // failed iteration, reset the previous values cost = previousCost;', 'tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; tmpVec = objective; objective = oldObj; oldObj = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) &&', '(delta <= parRelativeTolerance * xNorm)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['', '', 'qTy(residuals);', 'sum += jacobian[i][pj] * residuals[i];', '', 'determineLMParameter(oldRes, delta, diag, work1, work2, work3);', 'current = new VectorialPointValuePair(point, objective);', '', '', '} else { if (checker.converged(getIterations(), previous, current)) { return current; }'], ['double[] oldObj = new double[rows]; double[] qtf = new double[rows];', 'for (int i=0;i<rows;i++) { qtf[i]=residuals[i]; }', 'qTy(qtf);', 'sum += jacobian[i][pj] * qtf[i];', 'updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective);', 'tmpVec = objective; objective = oldObj; oldObj = tmpVec; determineLMParameter(qtf, delta, diag, work1, work2, work3);', '', 'current = new VectorialPointValuePair(point, objective); if (checker != null) { if (checker.converged(getIterations(), previous, current)) { return current; } }', 'tmpVec = objective; objective = oldObj; oldObj = tmpVec;', ''], 'a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java']
['Math-65', 2, 2, 2, 2, ['* @return RMS value */ public double getRMS() { double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; } return Math.sqrt(criterion / rows); } /**', 'double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual / residualsWeights[i]; } return chiSquare; }'], ['* @return RMS value */ public double getRMS() { return Math.sqrt(getChiSquare() / rows); } /**', 'double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; }'], ['double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; } return Math.sqrt(criterion / rows);', 'chiSquare += residual * residual / residualsWeights[i];'], ['return Math.sqrt(getChiSquare() / rows);', 'chiSquare += residual * residual * residualsWeights[i];'], 'a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java']
['Math-66', 6, 6, 6, 6, ['* Construct a solver. */ public BrentOptimizer() { setMaxEvaluations(Integer.MAX_VALUE); setMaximalIterationCount(100); setAbsoluteAccuracy(1E-10); setRelativeAccuracy(1.0e-14); } /**', '*/ protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException { throw new UnsupportedOperationException(); } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); return localMin(getGoalType() == GoalType.MINIMIZE, f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy()); } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException { return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min)); } /** * Find the minimum of the function within the interval {@code (lo, hi)}.', '* the function. */ private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {', 'double w = x; double d = 0; double e = 0; double fx = computeObjectiveValue(f, x); if (goalType == GoalType.MAXIMIZE) { fx = -fx; } double fv = fx; double fw = fx; int count = 0; while (count < maximalIterationCount) { double m = 0.5 * (a + b); final double tol1 = eps * Math.abs(x) + t; final double tol2 = 2 * tol1;', 'u = x + d; } double fu = computeObjectiveValue(f, u); if (goalType == GoalType.MAXIMIZE) { fu = -fu; }', '} } } else { // termination setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); return x; } ++count; } throw new MaxIterationsExceededException(maximalIterationCount); } }'], ['* Construct a solver. */ public BrentOptimizer() { setMaxEvaluations(1000); setMaximalIterationCount(100); setAbsoluteAccuracy(1e-11); setRelativeAccuracy(1e-9); } /**', '*/ protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException { return localMin(getGoalType() == GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy()); } /** * Find the minimum of the function within the interval {@code (lo, hi)}.', '* the function. */ private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {', 'double w = x; double d = 0; double e = 0; double fx = computeObjectiveValue(x); if (!isMinim) { fx = -fx; } double fv = fx; double fw = fx; while (true) { double m = 0.5 * (a + b); final double tol1 = eps * Math.abs(x) + t; final double tol2 = 2 * tol1;', 'u = x + d; } double fu = computeObjectiveValue(u); if (!isMinim) { fu = -fu; }', '} } } else { // termination setFunctionValue(isMinim ? fx : -fx); return x; } incrementIterationsCounter(); } } }'], ['setMaxEvaluations(Integer.MAX_VALUE); setAbsoluteAccuracy(1E-10); setRelativeAccuracy(1.0e-14);', 'throw new UnsupportedOperationException(); } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); f, goalType, min, startValue, max, public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException { return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min)); }', 'UnivariateRealFunction f, GoalType goalType,', 'double fx = computeObjectiveValue(f, x); if (goalType == GoalType.MAXIMIZE) { int count = 0; while (count < maximalIterationCount) {', 'double fu = computeObjectiveValue(f, u); if (goalType == GoalType.MAXIMIZE) {', 'setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); ++count; throw new MaxIterationsExceededException(maximalIterationCount);'], ['setMaxEvaluations(1000); setAbsoluteAccuracy(1e-11); setRelativeAccuracy(1e-9);', 'getMin(), getStartValue(), getMax(),', '', 'double fx = computeObjectiveValue(x); if (!isMinim) { while (true) {', 'double fu = computeObjectiveValue(u); if (!isMinim) {', 'setFunctionValue(isMinim ? fx : -fx); incrementIterationsCounter();'], 'a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java']
['Math-67', 1, 1, 1, 1, [' /** {@inheritDoc} */ public double getFunctionValue() { return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult(); } /** {@inheritDoc} */'], [' /** {@inheritDoc} */ public double getFunctionValue() { return optimaValues[0]; } /** {@inheritDoc} */ public double getResult() { return optima[0]; } /** {@inheritDoc} */'], ['return optimizer.getFunctionValue(); return optimizer.getResult();'], ['return optimaValues[0]; return optima[0];'], 'a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java']
['Math-68', 5, 5, 5, 5, ['setMaxIterations(1000); // default values for the tuning parameters setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10);', '// outer loop lmPar = 0; boolean firstIteration = true; while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix updateJacobian(); qrDecomposition();', '} if (maxCosine <= orthoTolerance) { // convergence has been reached return new VectorialPointValuePair(point, objective); } // rescale if necessary', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); // compute the scaled actual reduction double actRed = -1.0;', '} // tests for convergence. // we use the vectorial convergence checker // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return new VectorialPointValuePair(point, objective); } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['setMaxIterations(1000); // default values for the tuning parameters setConvergenceChecker(null); setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10);', '// outer loop lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();', '} if (maxCosine <= orthoTolerance) { // convergence has been reached return current; } // rescale if necessary', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); // compute the scaled actual reduction double actRed = -1.0;', '} // tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(getIterations(), previous, current)) { return current; } } else { // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['', '', 'return new VectorialPointValuePair(point, objective);', '', 'return new VectorialPointValuePair(point, objective);'], ['setConvergenceChecker(null);', 'VectorialPointValuePair current = new VectorialPointValuePair(point, objective); VectorialPointValuePair previous = current;', 'return current;', 'current = new VectorialPointValuePair(point, objective);', 'if (checker != null) { if (checker.converged(getIterations(), previous, current)) { return current; } } else { return current; }'], 'a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java']
['Math-69', 1, 1, 1, 1, ['} else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); } } }'], ['} else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * tDistribution.cumulativeProbability(-t); } } }'], ['out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));'], ['out[i][j] = 2 * tDistribution.cumulativeProbability(-t);'], 'a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java', 'b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java']
['Math-70', 1, 1, 1, 1, ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); } /** {@inheritDoc} */'], ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(f, min, max); } /** {@inheritDoc} */'], ['return solve(min, max);'], ['return solve(f, min, max);'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java']
['Math-71', 2, 2, 2, 2, ['// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states loop = false; } else { // reject the step to match exactly the next switch time', '// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states loop = false; } else { // reject the step to match exactly the next switch time'], ['// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { // reject the step to match exactly the next switch time', '// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); stepSize = 0; loop = false; } else { // reject the step to match exactly the next switch time'], ['', ''], ['interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0;', 'interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); stepSize = 0;'], 'a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java']
['Math-72', 2, 2, 2, 2, ['// return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; }', '// return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; }'], ['// return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); return result; }', '// return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); return result; }'], ['setResult(yMin, 0);', 'setResult(yMax, 0);'], ['setResult(min, 0);', 'setResult(max, 0);'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java']
['Math-73', 1, 1, 1, 1, ['return solve(f, initial, yInitial, max, yMax, initial, yInitial); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);'], ['return solve(f, initial, yInitial, max, yMax, initial, yInitial); } if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);'], [''], ['if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); }'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java']
['Math-74', 1, 1, 1, 1, ['} if (firstTime) { final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance; } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);'], ['} if (firstTime) { final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);'], ['final double[] scale; scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); scale = vecAbsoluteTolerance;'], ['final double[] scale = new double[y0.length]; for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); }'], 'a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java']
['Math-75', 1, 1, 1, 1, ['*/ @Deprecated public double getPct(Object v) { return getCumPct((Comparable<?>) v); } /**'], ['*/ @Deprecated public double getPct(Object v) { return getPct((Comparable<?>) v); } /**'], ['return getCumPct((Comparable<?>) v);'], ['return getPct((Comparable<?>) v);'], 'a/src/main/java/org/apache/commons/math/stat/Frequency.java', 'b/src/main/java/org/apache/commons/math/stat/Frequency.java']
['Math-76', 2, 2, 2, 2, ['if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; for (int i = 0; i < p - 1; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } for (int j = 0; j < p; ++j) { wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; } for (int i = p; i < m; ++i) { wData[i] = new double[p];', '// the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; for (int i = 0; i < p - 1; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } for (int j = 0; j < p; ++j) { wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }'], ['if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; for (int i = 0; i < p; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; if (i < n - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } else { for (int j = 0; j < p; ++j) { wi[j] = mi * ei0[j] / singularValues[j]; } } } for (int i = p; i < m; ++i) { wData[i] = new double[p];', '// the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; for (int i = 0; i < p; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; if (i < m - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } else { for (int j = 0; j < p; ++j) { wi[j] = mi * ei0[j] / singularValues[j]; } } } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }'], ['eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); for (int i = 0; i < p - 1; ++i) { } wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];', 'eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); for (int i = 0; i < p - 1; ++i) { } wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];'], ['eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); for (int i = 0; i < p; ++i) { if (i < n - 1) { } else { wi[j] = mi * ei0[j] / singularValues[j]; } }', 'eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); for (int i = 0; i < p; ++i) { if (i < m - 1) { } else { wi[j] = mi * ei0[j] / singularValues[j]; } }'], 'a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java', 'b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java']
['Math-77', 2, 2, 2, 2, ['public double getLInfNorm() { double max = 0; for (double a : data) { max += Math.max(max, Math.abs(a)); } return max; }', 'return max; } public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from'], ['public double getLInfNorm() { double max = 0; for (double a : data) { max = Math.max(max, Math.abs(a)); } return max; }', 'return max; } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from'], ['max += Math.max(max, Math.abs(a));', 'public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; }'], ['max = Math.max(max, Math.abs(a));', ''], 'a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java', 'b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java']
['Math-78', 2, 2, 2, 2, ['if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb', "// this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing // this should never happen // variation direction, with respect to the integration direction increasing = gb >= ga;"], ['if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb', "// this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { // this should never happen throw MathRuntimeException.createInternalError(null); } } // variation direction, with respect to the integration direction increasing = gb >= ga;"], ['', ''], ['if (ga * gb > 0) {', 'final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { throw MathRuntimeException.createInternalError(null); } }'], 'a/src/main/java/org/apache/commons/math/ode/events/EventState.java', 'b/src/main/java/org/apache/commons/math/ode/events/EventState.java']
['Math-79', 1, 1, 1, 1, ['* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);'], ['* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { double sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);'], ['int sum = 0; final int dp = p1[i] - p2[i];'], ['double sum = 0; final double dp = p1[i] - p2[i];'], 'a/src/main/java/org/apache/commons/math/util/MathUtils.java', 'b/src/main/java/org/apache/commons/math/util/MathUtils.java']
['Math-80', 1, 1, 1, 1, ['private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];'], ['private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];'], ['int j = 4 * n - 1;'], ['int j = 4 * (n - 1);'], 'a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java', 'b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java']
['Math-81', 3, 3, 3, 3, ['lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax); }', 'diagMax = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) && (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2] = -sigma;', 'double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {'], ['lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; upperSpectra = Math.max(upperSpectra, upper); minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax); }', 'diagMax = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2] = -sigma;', 'double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 3) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {'], ['', 'for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&', 'if (end - start > 2) {'], ['upperSpectra = Math.max(upperSpectra, upper);', 'for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||', 'if (end - start > 3) {'], 'a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java', 'b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java']
['Math-82', 1, 1, 1, 1, ['for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;'], ['for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;'], ['if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {'], ['if (MathUtils.compareTo(entry, 0, epsilon) > 0) {'], 'a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java', 'b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java']
['Math-83', 2, 2, 2, 2, ['*/ private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) { Integer row = null; int start = getNumObjectiveFunctions(); for (int i = start; i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i;', '*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0'], ['*/ private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) { Integer row = null; int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0; for (int i = start; i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i;', '*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0'], ['int start = getNumObjectiveFunctions();', 'Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);'], ['int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;', 'Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset()); Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);'], 'a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-84', 2, 2, 2, 2, ['protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter();', 'final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex // check convergence return; }'], ['protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker(); while (true) { incrementIterationsCounter();', 'final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex return; } // check convergence final int iter = getIterations(); boolean converged = true; for (int i = 0; i < simplex.length; ++i) { converged &= checker.converged(iter, original[i], simplex[i]); } if (converged) { return; }'], ['', ''], ['final RealConvergenceChecker checker = getConvergenceChecker();', 'return; } final int iter = getIterations(); boolean converged = true; for (int i = 0; i < simplex.length; ++i) { converged &= checker.converged(iter, original[i], simplex[i]); } if (converged) {'], 'a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java', 'b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java']
['Math-85', 1, 1, 1, 1, ['} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( "number of iterations={0}, maximum iterations={1}, " + "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +'], ['} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb > 0.0 ) { throw new ConvergenceException( "number of iterations={0}, maximum iterations={1}, " + "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +'], ['if (fa * fb >= 0.0 ) {'], ['if (fa * fb > 0.0 ) {'], 'a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java', 'b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java']
['Math-86', 2, 2, 2, 2, [' final double[] lI = lTData[i]; if (lTData[i][i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); } // check off-diagonal elements (and reset them to 0) for (int j = i + 1; j < order; ++j) { final double[] lJ = lTData[j];', 'final double[] ltI = lTData[i]; // check diagonal element ltI[i] = Math.sqrt(ltI[i]); final double inverse = 1.0 / ltI[i];'], [' final double[] lI = lTData[i]; // check off-diagonal elements (and reset them to 0) for (int j = i + 1; j < order; ++j) { final double[] lJ = lTData[j];', 'final double[] ltI = lTData[i]; // check diagonal element if (ltI[i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); } ltI[i] = Math.sqrt(ltI[i]); final double inverse = 1.0 / ltI[i];'], ['if (lTData[i][i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); }', ''], ['', 'if (ltI[i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); }'], 'a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java', 'b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java']
['Math-87', 1, 1, 1, 1, ['private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; } } } return row;'], ['private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { return null; } } return row;'], ['if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { } else { }'], ['if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {'], 'a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-88', 1, 1, 1, 1, ['Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } } } } return new RealPointValuePair(coefficients, f.getValue(coefficients));'], ['Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0; } else { basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); } } return new RealPointValuePair(coefficients, f.getValue(coefficients));'], ['if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }'], ['Set<Integer> basicRows = new HashSet<Integer>(); if (basicRows.contains(basicRow)) { coefficients[i] = 0; } else { basicRows.add(basicRow);'], 'a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-89', 1, 1, 1, 1, ['*/ @Deprecated public void addValue(Object v) { addValue((Comparable<?>) v); } /**'], ['*/ @Deprecated public void addValue(Object v) { if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); } else { throw new IllegalArgumentException("Object must implement Comparable"); } } /**'], [''], ['if (v instanceof Comparable<?>){ } else { throw new IllegalArgumentException("Object must implement Comparable"); }'], 'a/src/java/org/apache/commons/math/stat/Frequency.java', 'b/src/java/org/apache/commons/math/stat/Frequency.java']
['Math-90', 2, 2, 2, 2, ['*/ @Deprecated public void addValue(Object v) { /** * Adds 1 to the frequency count for v.', '* @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());'], ['*/ @Deprecated public void addValue(Object v) { addValue((Comparable<?>) v); } /** * Adds 1 to the frequency count for v.', '* @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ public void addValue(Comparable<?>v){ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());'], ['', ''], ['addValue((Comparable<?>) v); }', 'public void addValue(Comparable<?>v){'], 'a/src/java/org/apache/commons/math/stat/Frequency.java', 'b/src/java/org/apache/commons/math/stat/Frequency.java']
['Math-91', 1, 1, 1, 1, ['* than <tt>object</tt>, 0 if they are equal. */ public int compareTo(Fraction object) { double nOd = doubleValue(); double dOn = object.doubleValue(); return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); }'], ['* than <tt>object</tt>, 0 if they are equal. */ public int compareTo(Fraction object) { long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator; return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); }'], ['double nOd = doubleValue(); double dOn = object.doubleValue();'], ['long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator;'], 'a/src/java/org/apache/commons/math/fraction/Fraction.java', 'b/src/java/org/apache/commons/math/fraction/Fraction.java']
['Math-92', 3, 3, 3, 3, ['if ((k == 1) || (k == n - 1)) { return n; } long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); } // Use symmetry for large k // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k // For n <= 61, the naive implementation cannot overflow. // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. return result; }', '* @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); } /**', '* For values small enough to do exact integer computation, * return the log of the exact value */ /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ /* * Sum logs for values that could overflow'], ['if ((k == 1) || (k == n - 1)) { return n; } // Use symmetry for large k if (k > n / 2) return binomialCoefficient(n, n - k); // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k long result = 1; if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. for (int j = 1, i = n - k + 1; j <= k; i++, j++) { result = result * i / j; } } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). long d = gcd(i, j); result = (result / (j / d)) * (i / d); } } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. for (int j = 1, i = n - k + 1; j <= k; i++, j++) { long d = gcd(i, j); result = mulAndCheck((result / (j / d)), (i / d)); } } return result; }', '* @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { if (n < k) { throw new IllegalArgumentException( "must have n >= k for binomial coefficient (n,k)"); } if (n < 0) { throw new IllegalArgumentException( "must have n >= 0 for binomial coefficient (n,k)"); } if ((n == k) || (k == 0)) { return 1d; } if ((k == 1) || (k == n - 1)) { return n; } if (k > n/2) { return binomialCoefficientDouble(n, n - k); } if (n < 67) { return binomialCoefficient(n,k); } double result = 1d; for (int i = 1; i <= k; i++) { result *= (double)(n - k + i) / (double)i; } return Math.floor(result + 0.5); } /**', '* For values small enough to do exact integer computation, * return the log of the exact value */ if (n < 67) { return Math.log(binomialCoefficient(n,k)); } /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ if (n < 1030) { return Math.log(binomialCoefficientDouble(n, k)); } /* * Sum logs for values that could overflow'], ['long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); }', 'return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);', ''], ['if (k > n / 2) return binomialCoefficient(n, n - k); long result = 1; if (n <= 61) { for (int j = 1, i = n - k + 1; j <= k; i++, j++) { result = result * i / j; } } else if (n <= 66) { for (int j = 1, i = n - k + 1; j <= k; i++, j++) { long d = gcd(i, j); result = (result / (j / d)) * (i / d); } } else { for (int j = 1, i = n - k + 1; j <= k; i++, j++) { long d = gcd(i, j); result = mulAndCheck((result / (j / d)), (i / d)); } }', 'if (n < k) { throw new IllegalArgumentException( "must have n >= k for binomial coefficient (n,k)"); } if (n < 0) { throw new IllegalArgumentException( "must have n >= 0 for binomial coefficient (n,k)"); } if ((n == k) || (k == 0)) { return 1d; } if ((k == 1) || (k == n - 1)) { return n; } if (k > n/2) { return binomialCoefficientDouble(n, n - k); } if (n < 67) { return binomialCoefficient(n,k); } double result = 1d; for (int i = 1; i <= k; i++) { result *= (double)(n - k + i) / (double)i; } return Math.floor(result + 0.5);', 'if (n < 67) { return Math.log(binomialCoefficient(n,k)); } if (n < 1030) { return Math.log(binomialCoefficientDouble(n, k)); }'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-93', 3, 3, 3, 3, ['* @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "factorial value is too large to fit in a long"); }', 'if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }', 'if (n < 0) { throw new IllegalArgumentException("must have n > 0 for n!"); } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);'], ['* @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } if (n > 20) { throw new ArithmeticException( "factorial value is too large to fit in a long"); }', 'if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } if (n < 21) { return factorial(n); } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }', 'if (n < 0) { throw new IllegalArgumentException("must have n > 0 for n!"); } if (n < 21) { return Math.log(factorial(n)); } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);'], ['long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) {', '', ''], ['if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } if (n > 20) {', 'if (n < 21) { return factorial(n); }', 'if (n < 21) { return Math.log(factorial(n)); }'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-94', 1, 1, 1, 1, ['* @since 1.1 */ public static int gcd(int u, int v) { if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to'], ['* @since 1.1 */ public static int gcd(int u, int v) { if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to'], ['if (u * v == 0) {'], ['if ((u == 0) || (v == 0)) {'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-95', 1, 1, 1, 1, ['* @return initial domain value */ protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; }'], ['* @return initial domain value */ protected double getInitialDomain(double p) { double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); if (d > 2.0) { // use mean ret = d / (d - 2.0); } return ret; }'], ['double ret;'], ['double ret = 1.0; if (d > 2.0) { }'], 'a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java', 'b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java']
['Math-96', 1, 1, 1, 1, ['if (rhs.isNaN()) { ret = this.isNaN(); } else { ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception'], ['if (rhs.isNaN()) { ret = this.isNaN(); } else { ret = (real == rhs.real) && (imaginary == rhs.imaginary); } } catch (ClassCastException ex) { // ignore exception'], ['ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));'], ['ret = (real == rhs.real) && (imaginary == rhs.imaginary);'], 'a/src/java/org/apache/commons/math/complex/Complex.java', 'b/src/java/org/apache/commons/math/complex/Complex.java']
['Math-97', 1, 1, 1, 1, [' // Verify bracketing double sign = yMin * yMax; if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException ("Function values at endpoints do not have different signs." + " Endpoints: [" + min + "," + max + "]" + " Values: [" + yMin + "," + yMax + "]"); } else { // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); // either min or max is a root } return ret;'], [' // Verify bracketing double sign = yMin * yMax; if (sign > 0) { // check if either value is close to a zero if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException ("Function values at endpoints do not have different signs." + " Endpoints: [" + min + "," + max + "]" + " Values: [" + yMin + "," + yMax + "]"); } } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); } else { // either min or max is a root if (yMin == 0.0) { ret = min; } else { ret = max; } } return ret;'], ['if (sign >= 0) { } else {'], ['if (sign > 0) { if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { } } else if (sign < 0){ } else { if (yMin == 0.0) { ret = min; } else { ret = max; }'], 'a/src/java/org/apache/commons/math/analysis/BrentSolver.java', 'b/src/java/org/apache/commons/math/analysis/BrentSolver.java']
['Math-98', 2, 2, 2, 2, ['} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); final BigDecimal[] out = new BigDecimal[v.length]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) {', 'if (v.length != nCols) { throw new IllegalArgumentException("vector has wrong length"); } final double[] out = new double[v.length]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;'], ['} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) {', 'if (v.length != nCols) { throw new IllegalArgumentException("vector has wrong length"); } final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;'], ['final BigDecimal[] out = new BigDecimal[v.length];', 'final double[] out = new double[v.length];'], ['final BigDecimal[] out = new BigDecimal[nRows];', 'final double[] out = new double[nRows];'], 'a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java', 'b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java']
['Math-99', 2, 2, 2, 2, ['int u = p; int v = q; if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to', 'return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); return lcm; }'], ['int u = p; int v = q; if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw MathRuntimeException.createArithmeticException( "overflow: gcd({0}, {1}) is 2^31", new Object[] { p, q }); } return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to', 'return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); if (lcm == Integer.MIN_VALUE){ throw new ArithmeticException("overflow: lcm is 2^31"); } return lcm; }'], ['', ''], ['if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw MathRuntimeException.createArithmeticException( "overflow: gcd({0}, {1}) is 2^31", new Object[] { p, q }); }', 'if (lcm == Integer.MIN_VALUE){ throw new ArithmeticException("overflow: lcm is 2^31"); }'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-100', 2, 2, 2, 2, [' // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; final int cols = problem.getAllParameters().length; final int max = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) {', 'public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; int p = problem.getAllParameters().length; if (m <= p) { throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(m), new Integer(p)}); } double[] errors = new double[problem.getAllParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {'], [' // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; final int cols = problem.getUnboundParameters().length; final int max = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) {', 'public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; int p = problem.getUnboundParameters().length; if (m <= p) { throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(m), new Integer(p)}); } double[] errors = new double[problem.getUnboundParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {'], ['final int cols = problem.getAllParameters().length;', 'int p = problem.getAllParameters().length; double[] errors = new double[problem.getAllParameters().length];'], ['final int cols = problem.getUnboundParameters().length;', 'int p = problem.getUnboundParameters().length; double[] errors = new double[problem.getUnboundParameters().length];'], 'a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java', 'b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java']
['Math-101', 1, 1, 1, 1, ['int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index'], ['int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; if ((startIndex >= source.length()) || (endIndex > source.length()) || source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index'], ['if ('], ['if ((startIndex >= source.length()) || (endIndex > source.length()) ||'], 'a/src/java/org/apache/commons/math/complex/ComplexFormat.java', 'b/src/java/org/apache/commons/math/complex/ComplexFormat.java']
['Math-102', 1, 1, 1, 1, ['throw new IllegalArgumentException( "observed counts must be non-negative and expected counts must be postive"); } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; } return sumSq; }'], ['throw new IllegalArgumentException( "observed counts must be non-negative and expected counts must be postive"); } double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; } } return sumSq; }'], [''], ['double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { }'], 'a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java', 'b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java']
['Math-103', 1, 1, 1, 1, ['* convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } /**'], ['* convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } } } /**'], [''], ['try { } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } }'], 'a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java', 'b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java']
['Math-104', 1, 1, 1, 1, ['private static final long serialVersionUID = -6587513359895466954L; /** Maximum allowed numerical error. */ private static final double DEFAULT_EPSILON = 10e-9; /** Lanczos coefficients */ private static double[] lanczos ='], ['private static final long serialVersionUID = -6587513359895466954L; /** Maximum allowed numerical error. */ private static final double DEFAULT_EPSILON = 10e-15; /** Lanczos coefficients */ private static double[] lanczos ='], ['private static final double DEFAULT_EPSILON = 10e-9;'], ['private static final double DEFAULT_EPSILON = 10e-15;'], 'a/src/java/org/apache/commons/math/special/Gamma.java', 'b/src/java/org/apache/commons/math/special/Gamma.java']
['Math-105', 1, 1, 1, 1, ['* @return sum of squared errors associated with the regression model */ public double getSumSquaredErrors() { return sumYY - sumXY * sumXY / sumXX; } /**'], ['* @return sum of squared errors associated with the regression model */ public double getSumSquaredErrors() { return Math.max(0d, sumYY - sumXY * sumXY / sumXX); } /**'], ['return sumYY - sumXY * sumXY / sumXX;'], ['return Math.max(0d, sumYY - sumXY * sumXY / sumXX);'], 'a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java', 'b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java']
['Math-106', 2, 2, 2, 2, ["return null; } // minus signs should be leading, invalid expression // parse '/' int startIndex = pos.getIndex();", 'return null; } // minus signs must be leading, invalid int w = whole.intValue(); int n = num.intValue();'], ["return null; } if (num.intValue() < 0) { // minus signs should be leading, invalid expression pos.setIndex(initialIndex); return null; } // parse '/' int startIndex = pos.getIndex();", 'return null; } if (den.intValue() < 0) { // minus signs must be leading, invalid pos.setIndex(initialIndex); return null; } int w = whole.intValue(); int n = num.intValue();'], ['', ''], ['if (num.intValue() < 0) { pos.setIndex(initialIndex); return null; }', 'if (den.intValue() < 0) { pos.setIndex(initialIndex); return null; }'], 'a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java', 'b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java']
['Cli-1', 10, 10, 10, 10, ['package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; /** * <p>Represents list of arguments parsed against', 'private List args = new LinkedList(); /** the processed options */ private Map options = new HashMap(); private Map names = new HashMap(); /** Map of unique options for ease to get complete list of options */ // private Set allOptions = new HashSet(); private Map hashcodeMap = new HashMap(); /** * Creates a command line.', '*/ public boolean hasOption(String opt) { return options.containsKey(opt); } /**', '{ String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }', '*/ public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; }', '* @param opt short or long name of the option * @return Canonicalized option */ /** * Retrieves the array of values, if any, of an option.', '*/ void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } /**', '*/ public Iterator iterator() { return hashcodeMap.values().iterator(); } /**', '*/ public Option[] getOptions() { Collection processed = options.values(); // reinitialise array Option[] optionsArray = new Option[processed.size()];', '// return the array return (Option[]) processed.toArray(optionsArray); } No newline at end of file }'], ['package org.apache.commons.cli; import java.util.Collection; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Set; import java.util.HashSet; /** * <p>Represents list of arguments parsed against', 'private List args = new LinkedList(); /** the processed options */ private Set options = new HashSet(); /** Map of unique options for ease to get complete list of options */ // private Set allOptions = new HashSet(); /** * Creates a command line.', '*/ public boolean hasOption(String opt) { return options.contains( resolveOption(opt)); } /**', '{ String res = getOptionValue(opt); Option option = resolveOption(opt); if (option == null) { return null; } Object type = option.getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }', '*/ public String[] getOptionValues(String opt) { Option key = resolveOption( opt ); if (options.contains(key)) { return key.getValues(); } return null; }', '* @param opt short or long name of the option * @return Canonicalized option */ private Option resolveOption( String opt ) { opt = Util.stripLeadingHyphens(opt); for ( Iterator it = options.iterator(); it.hasNext(); ) { Option option = (Option) it.next(); if (opt.equals(option.getOpt())) { return option; } if (opt.equals( option.getLongOpt())) { return option; } } return null; } /** * Retrieves the array of values, if any, of an option.', '*/ void addOption(Option opt) { options.add(opt); } /**', '*/ public Iterator iterator() { return options.iterator(); } /**', '*/ public Option[] getOptions() { Collection processed = options; // reinitialise array Option[] optionsArray = new Option[processed.size()];', '// return the array return (Option[]) processed.toArray(optionsArray); } } No newline at end of file'], ['import java.util.HashMap; import java.util.Map;', 'private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap();', 'return options.containsKey(opt);', 'if (!options.containsKey(opt)) Object type = ((Option) options.get(opt)).getType();', 'opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) key = (String) names.get(opt); if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); }', '', 'hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt);', 'return hashcodeMap.values().iterator();', 'Collection processed = options.values();', '}'], ['import java.util.Set; import java.util.HashSet;', 'private Set options = new HashSet();', 'return options.contains( resolveOption(opt));', 'Option option = resolveOption(opt); if (option == null) Object type = option.getType();', 'Option key = resolveOption( opt ); if (options.contains(key)) return key.getValues();', 'private Option resolveOption( String opt ) { opt = Util.stripLeadingHyphens(opt); for ( Iterator it = options.iterator(); it.hasNext(); ) { Option option = (Option) it.next(); if (opt.equals(option.getOpt())) { return option; } if (opt.equals( option.getLongOpt())) { return option; } } return null; }', 'options.add(opt);', 'return options.iterator();', 'Collection processed = options;', '}'], 'a/src/java/org/apache/commons/cli/CommandLine.java', 'b/src/java/org/apache/commons/cli/CommandLine.java']
['Cli-2', 1, 1, 1, 1, ['} else { tokens.add("-" + ch); } } } No newline at end of file }'], ['} else { tokens.add(token); break; } } } } No newline at end of file'], ['tokens.add("-" + ch); }'], ['tokens.add(token); break; }'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-3', 2, 2, 2, 2, [' import java.util.Date; import org.apache.commons.lang.math.NumberUtils; /** * This is a temporary implementation. TypeHandler will handle the * pluggableness of OptionTypes and it will direct all of these types', '{ try { return NumberUtils.createNumber(str); } catch (NumberFormatException nfe) {'], [' import java.util.Date; /** * This is a temporary implementation. TypeHandler will handle the * pluggableness of OptionTypes and it will direct all of these types', "{ try { if( str != null ) { if( str.indexOf('.') != -1 ) { return Double.valueOf(str); } else { return Long.valueOf(str); } } } catch (NumberFormatException nfe) {"], ['import org.apache.commons.lang.math.NumberUtils;', 'return NumberUtils.createNumber(str);'], ['', "if( str != null ) { if( str.indexOf('.') != -1 ) { return Double.valueOf(str); } else { return Long.valueOf(str); } }"], 'a/src/java/org/apache/commons/cli/TypeHandler.java', 'b/src/java/org/apache/commons/cli/TypeHandler.java']
['Cli-4', 1, 1, 1, 1, ['if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); StringBuffer buff = new StringBuffer(); // loop through the required options'], ['if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); StringBuffer buff = new StringBuffer("Missing required option"); buff.append(requiredOptions.size() == 1 ? "" : "s"); buff.append(": "); // loop through the required options'], ['StringBuffer buff = new StringBuffer();'], ['StringBuffer buff = new StringBuffer("Missing required option"); buff.append(requiredOptions.size() == 1 ? "" : "s"); buff.append(": ");'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-5', 1, 1, 1, 1, ['*/ static String stripLeadingHyphens(String str) { if (str.startsWith("--")) { return str.substring(2, str.length());'], ['*/ static String stripLeadingHyphens(String str) { if (str == null) { return null; } if (str.startsWith("--")) { return str.substring(2, str.length());'], [''], ['if (str == null) { return null; }'], 'a/src/java/org/apache/commons/cli/Util.java', 'b/src/java/org/apache/commons/cli/Util.java']
['Cli-6', 2, 2, 2, 2, ['// temp variable Option option; // iterate over the options for (Iterator i = options.getOptions().iterator(); i.hasNext();) { // get the next Option option = (Option) i.next();', 'buff.append("["); } // for each option in the OptionGroup for (Iterator i = group.getOptions().iterator(); i.hasNext();) { // whether the option is required or not is handled at group level appendOption(buff, (Option) i.next(), true);'], ['// temp variable Option option; List optList = new ArrayList(options.getOptions()); Collections.sort(optList, new OptionComparator()); // iterate over the options for (Iterator i = optList.iterator(); i.hasNext();) { // get the next Option option = (Option) i.next();', 'buff.append("["); } List optList = new ArrayList(group.getOptions()); Collections.sort(optList, new OptionComparator()); // for each option in the OptionGroup for (Iterator i = optList.iterator(); i.hasNext();) { // whether the option is required or not is handled at group level appendOption(buff, (Option) i.next(), true);'], ['for (Iterator i = options.getOptions().iterator(); i.hasNext();)', 'for (Iterator i = group.getOptions().iterator(); i.hasNext();)'], ['List optList = new ArrayList(options.getOptions()); Collections.sort(optList, new OptionComparator()); for (Iterator i = optList.iterator(); i.hasNext();)', 'List optList = new ArrayList(group.getOptions()); Collections.sort(optList, new OptionComparator()); for (Iterator i = optList.iterator(); i.hasNext();)'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-7', 2, 2, 2, 2, ['*/ package org.apache.commons.cli2.builder; import java.util.HashSet; import java.util.Iterator; import java.util.Set; import org.apache.commons.cli2.Argument;', 'this.abuilder = abuilder; } private final Set options = new HashSet(); /** * Creates a new Option instance.'], ['*/ package org.apache.commons.cli2.builder; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Set; import org.apache.commons.cli2.Argument;', 'this.abuilder = abuilder; } private final Set options = new LinkedHashSet(); /** * Creates a new Option instance.'], ['import java.util.HashSet;', 'private final Set options = new HashSet();'], ['import java.util.LinkedHashSet;', 'private final Set options = new LinkedHashSet();'], 'a/src/java/org/apache/commons/cli2/builder/PatternBuilder.java', 'b/src/java/org/apache/commons/cli2/builder/PatternBuilder.java']
['Cli-8', 1, 1, 1, 1, ['while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, nextLineTabStop); if (pos == -1) {'], ['while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) {'], ['pos = findWrapPos(text, width, nextLineTabStop);'], ['pos = findWrapPos(text, width, 0);'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-9', 1, 1, 1, 1, ['while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }'], ['while (iter.hasNext()) { buff.append(iter.next()); buff.append(", "); } throw new MissingOptionException(buff.substring(0, buff.length() - 2)); } }'], ['throw new MissingOptionException(buff.toString());'], ['buff.append(", "); throw new MissingOptionException(buff.substring(0, buff.length() - 2));'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-10', 2, 2, 2, 2, ['*/ package org.apache.commons.cli; import java.util.Arrays; import java.util.Enumeration; import java.util.Iterator;', ' protected void setOptions(final Options options) { this.options = options; this.requiredOptions = options.getRequiredOptions(); } protected Options getOptions() {'], ['*/ package org.apache.commons.cli; import java.util.ArrayList; import java.util.Arrays; import java.util.Enumeration; import java.util.Iterator;', ' protected void setOptions(final Options options) { this.options = options; this.requiredOptions = new ArrayList(options.getRequiredOptions()); } protected Options getOptions() {'], ['', 'this.requiredOptions = options.getRequiredOptions();'], ['import java.util.ArrayList;', 'this.requiredOptions = new ArrayList(options.getRequiredOptions());'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-11', 1, 1, 1, 1, ['} // if the Option has a value if (option.hasArg() && (option.getArgName() != null)) { buff.append(" <").append(option.getArgName()).append(">"); }'], ['} // if the Option has a value if (option.hasArg() && option.hasArgName()) { buff.append(" <").append(option.getArgName()).append(">"); }'], ['if (option.hasArg() && (option.getArgName() != null))'], ['if (option.hasArg() && option.hasArgName())'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-12', 1, 1, 1, 1, ['} else { if (options.hasOption(arg.substring(0, 2))) { // the format is --foo=value or -foo=value // the format is a special properties option (-Dproperty=value) tokens.add(arg.substring(0, 2)); // -D tokens.add(arg.substring(2)); // property=value'], ["} else { if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) { // the format is --foo=value or -foo=value tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) { // the format is a special properties option (-Dproperty=value) tokens.add(arg.substring(0, 2)); // -D tokens.add(arg.substring(2)); // property=value"], ['if (options.hasOption(arg.substring(0, 2)))'], ["if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) {"], 'a/src/java/org/apache/commons/cli/GnuParser.java', 'b/src/java/org/apache/commons/cli/GnuParser.java']
['Cli-13', 3, 3, 3, 3, ['* @param option the Option associated with the values * @return a list of values or an empty List if none are found */ /** * Sets the default values for an Option in the CommandLine', 'return valueList; } // First grab the command line values // Finally use an empty list public Boolean getSwitch(final Option option, final Boolean defaultValue) {', 'final Option option) throws OptionException { // count of arguments processed for this option. int argumentCount = 0; while (arguments.hasNext() && (argumentCount < maximum)) { final String allValuesQuoted = (String) arguments.next();'], ['* @param option the Option associated with the values * @return a list of values or an empty List if none are found */ List getUndefaultedValues(final Option option); /** * Sets the default values for an Option in the CommandLine', 'return valueList; } public List getUndefaultedValues(Option option) { // First grab the command line values List valueList = (List) values.get(option); // Finally use an empty list if (valueList == null) { valueList = Collections.EMPTY_LIST; } return valueList; } public Boolean getSwitch(final Option option, final Boolean defaultValue) {', 'final Option option) throws OptionException { // count of arguments processed for this option. int argumentCount = commandLine.getUndefaultedValues(option).size(); while (arguments.hasNext() && (argumentCount < maximum)) { final String allValuesQuoted = (String) arguments.next();'], ['', '', 'int argumentCount = 0;'], ['List getUndefaultedValues(final Option option);', 'public List getUndefaultedValues(Option option) { List valueList = (List) values.get(option); if (valueList == null) { valueList = Collections.EMPTY_LIST; } return valueList; }', 'int argumentCount = commandLine.getUndefaultedValues(option).size();'], 'a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java', 'b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java']
['Cli-14', 2, 2, 2, 2, [' // needs validation? boolean validate = option.isRequired() || option instanceof Group; if (validate) { option.validate(commandLine); } // if the child option is present then validate it if (commandLine.hasOption(option)) {', ' break; } option.validate(commandLine); } }'], [' // needs validation? boolean validate = option.isRequired() || option instanceof Group; // if the child option is present then validate it if (commandLine.hasOption(option)) {', ' break; } validate = true; } if (validate) { option.validate(commandLine); } }'], ['if (validate) { option.validate(commandLine); }', ''], ['', 'validate = true; } if (validate) {'], 'a/src/java/org/apache/commons/cli2/option/GroupImpl.java', 'b/src/java/org/apache/commons/cli2/option/GroupImpl.java']
['Cli-15', 1, 1, 1, 1, ['List valueList = (List) values.get(option); // grab the correct default values if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); } // if there are more default values as specified, add them to // the list. // copy the list first return valueList == null ? Collections.EMPTY_LIST : valueList; }'], ['List valueList = (List) values.get(option); // grab the correct default values if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); } // augment the list with the default values if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { // if there are more default values as specified, add them to // the list. if (defaultValues.size() > valueList.size()) { // copy the list first valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } } return valueList == null ? Collections.EMPTY_LIST : valueList; }'], ['if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); }'], ['if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { if (defaultValues.size() > valueList.size()) { valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } }'], 'a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java', 'b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java']
['Cli-16', 6, 6, 6, 6, ['* * @return the parent of this option */ /** * Sets the parent of this option. This method is called when the option is', '* * @param parent the parent option */ }', '} // ensure that all parent options are also added } public void addValue(final Option option,', '// process the options for (final Iterator i = options.iterator(); i.hasNext();) { final Option option = (Option) i.next(); if (option instanceof Argument) { i.remove();', 'public abstract class OptionImpl implements Option { private final int id; private final boolean required; /** * Creates an OptionImpl with the specified id', '// nothing to do normally } protected void checkPrefixes(final Set prefixes) { // nothing to do if empty prefix list'], ['* * @return the parent of this option */ Option getParent(); /** * Sets the parent of this option. This method is called when the option is', '* * @param parent the parent option */ void setParent(Option parent); }', '} // ensure that all parent options are also added Option parent = option.getParent(); while (parent != null && !options.contains(parent)) { options.add(parent); parent = parent.getParent(); } } public void addValue(final Option option,', '// process the options for (final Iterator i = options.iterator(); i.hasNext();) { final Option option = (Option) i.next(); option.setParent(this); if (option instanceof Argument) { i.remove();', 'public abstract class OptionImpl implements Option { private final int id; private final boolean required; private Option parent; /** * Creates an OptionImpl with the specified id', '// nothing to do normally } public Option getParent() { return parent; } public void setParent(Option parent) { this.parent = parent; } protected void checkPrefixes(final Set prefixes) { // nothing to do if empty prefix list'], ['', '', '', '', '', ''], ['Option getParent();', 'void setParent(Option parent);', 'Option parent = option.getParent(); while (parent != null && !options.contains(parent)) { options.add(parent); parent = parent.getParent(); }', 'option.setParent(this);', 'private Option parent;', 'public Option getParent() { return parent; } public void setParent(Option parent) { this.parent = parent; }'], 'a/src/java/org/apache/commons/cli2/option/OptionImpl.java', 'b/src/java/org/apache/commons/cli2/option/OptionImpl.java']
['Cli-17', 1, 1, 1, 1, ['else if (stopAtNonOption) { process(token.substring(i)); } else {'], ['else if (stopAtNonOption) { process(token.substring(i)); break; } else {'], [''], ['break;'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-18', 3, 3, 3, 3, ['// single hyphen else if ("-".equals(token)) { processSingleHyphen(token); } else if (token.startsWith("-")) {', 'tokens.add(value); } } private void processSingleHyphen(String hyphen) { tokens.add(hyphen); } /** * <p>If an {@link Option} exists for <code>token</code> then', 'else if (stopAtNonOption) { eatTheRest = true; } }'], ['// single hyphen else if ("-".equals(token)) { tokens.add(token); } else if (token.startsWith("-")) {', 'tokens.add(value); } } /** * <p>If an {@link Option} exists for <code>token</code> then', 'else if (stopAtNonOption) { eatTheRest = true; tokens.add(token); } }'], ['processSingleHyphen(token);', 'private void processSingleHyphen(String hyphen) { tokens.add(hyphen); }', ''], ['tokens.add(token);', '', 'tokens.add(token);'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-19', 1, 1, 1, 1, ['if (options.hasOption(token)) { currentOption = options.getOption(token); tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token); } } /**'], ['if (options.hasOption(token)) { currentOption = options.getOption(token); } else if (stopAtNonOption) { eatTheRest = true; } tokens.add(token); } /**'], ['tokens.add(token); tokens.add(token);'], [' tokens.add(token);'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-20', 1, 1, 1, 1, ['// handle long option --foo or --foo=bar if (token.startsWith("--")) { if (token.indexOf(\'=\') != -1) { tokens.add(token.substring(0, token.indexOf(\'=\'))); tokens.add(token.substring(token.indexOf(\'=\') + 1, token.length())); } else { tokens.add(token); } }'], ['// handle long option --foo or --foo=bar if (token.startsWith("--")) { int pos = token.indexOf(\'=\'); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) { process(token); } else { tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); } } }'], ["if (token.indexOf('=') != -1) tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); tokens.add(token);"], ["int pos = token.indexOf('='); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) process(token); tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); }"], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-21', 6, 6, 6, 6, ['* * @return the current option */ /** * Sets the current option. This method is called by concrete option', '* * @param currentOption the new current option */ }', 'private final Map defaultSwitches = new HashMap(); private final List normalised; private final Set prefixes; /** * Creates a new WriteableCommandLineImpl rooted on the specified Option, to', 'final List arguments) { this.prefixes = rootOption.getPrefixes(); this.normalised = arguments; } public void addOption(Option option) { options.add(option);', '*/ public boolean looksLikeOption(final String trigger) { // this is a reentrant call for (final Iterator i = prefixes.iterator(); i.hasNext();) { final String prefix = (String) i.next(); if (trigger.startsWith(prefix)) { return true; } } return false; } public String toString() {', '*/ private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) { return commandLine.looksLikeOption(trigger); } }'], ['* * @return the current option */ Option getCurrentOption(); /** * Sets the current option. This method is called by concrete option', '* * @param currentOption the new current option */ void setCurrentOption(Option currentOption); }', 'private final Map defaultSwitches = new HashMap(); private final List normalised; private final Set prefixes; private Option currentOption; private String checkForOption; /** * Creates a new WriteableCommandLineImpl rooted on the specified Option, to', 'final List arguments) { this.prefixes = rootOption.getPrefixes(); this.normalised = arguments; setCurrentOption(rootOption); } public Option getCurrentOption() { return currentOption; } public void setCurrentOption(Option currentOption) { this.currentOption = currentOption; } public void addOption(Option option) { options.add(option);', '*/ public boolean looksLikeOption(final String trigger) { if (checkForOption != null) { // this is a reentrant call return !checkForOption.equals(trigger); } checkForOption = trigger; try { for (final Iterator i = prefixes.iterator(); i.hasNext();) { final String prefix = (String) i.next(); if (trigger.startsWith(prefix)) { if (getCurrentOption().canProcess(this, trigger) || getCurrentOption().findOption(trigger) != null) { return true; } } } return false; } finally { checkForOption = null; } } public String toString() {', '*/ private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) { Option oldOption = commandLine.getCurrentOption(); try { commandLine.setCurrentOption(this); return commandLine.looksLikeOption(trigger); } finally { commandLine.setCurrentOption(oldOption); } } }'], ['', '', '', '', '', ''], ['Option getCurrentOption();', 'void setCurrentOption(Option currentOption);', 'private Option currentOption; private String checkForOption;', 'setCurrentOption(rootOption); public Option getCurrentOption() { return currentOption; } public void setCurrentOption(Option currentOption) { this.currentOption = currentOption; }', 'if (checkForOption != null) { return !checkForOption.equals(trigger); } checkForOption = trigger; try { if (getCurrentOption().canProcess(this, trigger) || getCurrentOption().findOption(trigger) != null) { } } finally { checkForOption = null; }', 'Option oldOption = commandLine.getCurrentOption(); try { commandLine.setCurrentOption(this); } finally { commandLine.setCurrentOption(oldOption); }'], 'a/src/java/org/apache/commons/cli2/option/GroupImpl.java', 'b/src/java/org/apache/commons/cli2/option/GroupImpl.java']
['Cli-22', 7, 7, 7, 7, ['private boolean eatTheRest; /** holder for the current option */ /** the command line Options */ private Options options;', ' if (!options.hasOption(opt)) { processNonOptionToken(token); } else { tokens.add(opt); if (pos != -1)', 'burstToken(token, stopAtNonOption); } } else if (stopAtNonOption) { processNonOptionToken(token); } else { tokens.add(token); } gobble(iter);', '* * @param value The current token */ private void processNonOptionToken(String value) { eatTheRest = true; tokens.add("--"); tokens.add(value); }', 'eatTheRest = true; } tokens.add(token); }', '*/ protected void burstToken(String token, boolean stopAtNonOption) { Option currentOption; for (int i = 1; i < token.length(); i++) { String ch = String.valueOf(token.charAt(i));', '} else if (stopAtNonOption) { processNonOptionToken(token.substring(i)); break; } else'], ['private boolean eatTheRest; /** holder for the current option */ private Option currentOption; /** the command line Options */ private Options options;', ' if (!options.hasOption(opt)) { processNonOptionToken(token, stopAtNonOption); } else { currentOption = options.getOption(opt); tokens.add(opt); if (pos != -1)', 'burstToken(token, stopAtNonOption); } } else { processNonOptionToken(token, stopAtNonOption); } gobble(iter);', '* * @param value The current token */ private void processNonOptionToken(String value, boolean stopAtNonOption) { if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) { eatTheRest = true; tokens.add("--"); } tokens.add(value); }', 'eatTheRest = true; } if (options.hasOption(token)) { currentOption = options.getOption(token); } tokens.add(token); }', '*/ protected void burstToken(String token, boolean stopAtNonOption) { for (int i = 1; i < token.length(); i++) { String ch = String.valueOf(token.charAt(i));', '} else if (stopAtNonOption) { processNonOptionToken(token.substring(i), true); break; } else'], ['', 'processNonOptionToken(token);', 'else if (stopAtNonOption) { processNonOptionToken(token); } tokens.add(token);', 'private void processNonOptionToken(String value)', '', 'Option currentOption;', 'processNonOptionToken(token.substring(i));'], ['private Option currentOption;', 'processNonOptionToken(token, stopAtNonOption); currentOption = options.getOption(opt);', 'processNonOptionToken(token, stopAtNonOption);', 'private void processNonOptionToken(String value, boolean stopAtNonOption) if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) { }', 'if (options.hasOption(token)) { currentOption = options.getOption(token); }', '', 'processNonOptionToken(token.substring(i), true);'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-23', 2, 2, 2, 2, [' while (true) { int lastPos = pos; text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0);', 'sb.append(text); return sb; } else if (pos == lastPos) { throw new RuntimeException("Text too long for line - throwing exception to avoid infinite loop [CLI-162]: " + text); } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);'], [' while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0);', 'sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);'], ['int lastPos = pos;', '} else if (pos == lastPos) { throw new RuntimeException("Text too long for line - throwing exception to avoid infinite loop [CLI-162]: " + text);'], ['', '} if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb;'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-24', 1, 1, 1, 1, ['if (nextLineTabStop >= width) { // stops infinite loop happening throw new IllegalStateException("Total width is less than the width of the argument and indent " + "- no room for the description"); } // all following lines must be padded with nextLineTabStop space'], ['if (nextLineTabStop >= width) { // stops infinite loop happening nextLineTabStop = width - 1; } // all following lines must be padded with nextLineTabStop space'], ['throw new IllegalStateException("Total width is less than the width of the argument and indent " + "- no room for the description");'], ['nextLineTabStop = width - 1;'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-25', 1, 1, 1, 1, ['if (nextLineTabStop >= width) { // stops infinite loop happening nextLineTabStop = width - 1; } // all following lines must be padded with nextLineTabStop space'], ['if (nextLineTabStop >= width) { // stops infinite loop happening nextLineTabStop = 1; } // all following lines must be padded with nextLineTabStop space'], ['nextLineTabStop = width - 1;'], ['nextLineTabStop = 1;'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-26', 2, 2, 2, 2, ['*/ public static Option create(String opt) throws IllegalArgumentException { // create the option Option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt);', 'option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); // reset the OptionBuilder properties OptionBuilder.reset(); // return the Option instance return option;'], ['*/ public static Option create(String opt) throws IllegalArgumentException { Option option = null; try { // create the option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt);', 'option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); } finally { // reset the OptionBuilder properties OptionBuilder.reset(); } // return the Option instance return option;'], ['Option option = new Option(opt, description);', ''], ['Option option = null; try { option = new Option(opt, description);', '} finally { }'], 'a/src/java/org/apache/commons/cli/OptionBuilder.java', 'b/src/java/org/apache/commons/cli/OptionBuilder.java']
['Cli-27', 1, 1, 1, 1, ['// if no option has already been selected or the // same option is being reselected then set the // selected member variable if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt(); } else {'], ['// if no option has already been selected or the // same option is being reselected then set the // selected member variable if (selected == null || selected.equals(option.getKey())) { selected = option.getKey(); } else {'], ['if (selected == null || selected.equals(option.getOpt())) selected = option.getOpt();'], ['if (selected == null || selected.equals(option.getKey())) selected = option.getKey();'], 'a/src/java/org/apache/commons/cli/OptionGroup.java', 'b/src/java/org/apache/commons/cli/OptionGroup.java']
['Cli-28', 1, 1, 1, 1, ["{ // if the value is not yes, true or 1 then don't add the // option to the CommandLine break; } cmd.addOption(opt);"], ["{ // if the value is not yes, true or 1 then don't add the // option to the CommandLine continue; } cmd.addOption(opt);"], ['break;'], ['continue;'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-29', 1, 1, 1, 1, ['*/ static String stripLeadingAndTrailingQuotes(String str) { if (str.startsWith("\\"")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith("\\"")) { str = str.substring(0, length - 1); } return str;'], ['*/ static String stripLeadingAndTrailingQuotes(String str) { int length = str.length(); if (length > 1 && str.startsWith("\\"") && str.endsWith("\\"") && str.substring(1, length - 1).indexOf(\'"\') == -1) { str = str.substring(1, length - 1); } return str;'], ['if (str.startsWith("\\"")) { str = str.substring(1, str.length()); } if (str.endsWith("\\"")) str = str.substring(0, length - 1);'], ['if (length > 1 && str.startsWith("\\"") && str.endsWith("\\"") && str.substring(1, length - 1).indexOf(\'"\') == -1) str = str.substring(1, length - 1);'], 'a/src/java/org/apache/commons/cli/Util.java', 'b/src/java/org/apache/commons/cli/Util.java']
['Cli-30', 2, 2, 2, 2, ['{ String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = options.getOption(option); // if the option is part of a group, check if another option of the group has been selected // get the value from the properties String value = properties.getProperty(option);', '{ String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); // if the option is part of a group, check if another option of the group has been selected // get the value from the properties instance String value = properties.getProperty(option);'], ['{ String option = e.nextElement().toString(); Option opt = options.getOption(option); if (opt == null) { throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } // if the option is part of a group, check if another option of the group has been selected OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) { // get the value from the properties String value = properties.getProperty(option);', '{ String option = e.nextElement().toString(); Option opt = options.getOption(option); if (opt == null) { throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } // if the option is part of a group, check if another option of the group has been selected OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) { // get the value from the properties instance String value = properties.getProperty(option);'], ['if (!cmd.hasOption(option)) Option opt = options.getOption(option);', 'if (!cmd.hasOption(option)) Option opt = getOptions().getOption(option);'], ['Option opt = options.getOption(option); if (opt == null) throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) {', 'Option opt = options.getOption(option); if (opt == null) throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) {'], 'a/src/main/java/org/apache/commons/cli/Parser.java', 'b/src/main/java/org/apache/commons/cli/Parser.java']
['Cli-31', 3, 3, 3, 3, ['} // if the Option has a value and a non blank argname if (option.hasArg() && option.hasArgName()) { buff.append(option.getOpt() == null ? longOptSeparator : " "); buff.append("<").append(option.getArgName()).append(">"); } // if the Option is not a required option', 'private String longOpt; /** the name of the argument for this option */ private String argName = "arg"; /** description of the option */ private String description;', 'private static void reset() { description = null; argName = "arg"; longopt = null; type = null; required = false;'], ['} // if the Option has a value and a non blank argname if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0)) { buff.append(option.getOpt() == null ? longOptSeparator : " "); buff.append("<").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(">"); } // if the Option is not a required option', 'private String longOpt; /** the name of the argument for this option */ private String argName; /** description of the option */ private String description;', 'private static void reset() { description = null; argName = null; longopt = null; type = null; required = false;'], ['if (option.hasArg() && option.hasArgName()) buff.append("<").append(option.getArgName()).append(">");', 'private String argName = "arg";', 'argName = "arg";'], ['if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0)) buff.append("<").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(">");', 'private String argName;', 'argName = null;'], 'a/src/main/java/org/apache/commons/cli/OptionBuilder.java', 'b/src/main/java/org/apache/commons/cli/OptionBuilder.java']
['Cli-32', 1, 1, 1, 1, [" // if we didn't find one, simply chop at startPos+width pos = startPos + width; while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; } return pos == text.length() ? -1 : pos; }"], [" // if we didn't find one, simply chop at startPos+width pos = startPos + width; return pos == text.length() ? -1 : pos; }"], ["while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; }"], [''], 'a/src/main/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/main/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-33', 2, 2, 2, 2, ['{ StringBuffer sb = new StringBuffer(text.length()); renderWrappedText(sb, width, nextLineTabStop, text); pw.println(sb.toString()); }', '* @param nextLineTabStop The position on the next line for the first tab. * @param text The text to be rendered. */ // cannot happen /** * Finds the next text wrap position after <code>startPos</code> for the'], ['{ StringBuffer sb = new StringBuffer(text.length()); renderWrappedTextBlock(sb, width, nextLineTabStop, text); pw.println(sb.toString()); }', '* @param nextLineTabStop The position on the next line for the first tab. * @param text The text to be rendered. */ private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) { try { BufferedReader in = new BufferedReader(new StringReader(text)); String line; boolean firstLine = true; while ((line = in.readLine()) != null) { if (!firstLine) { sb.append(getNewLine()); } else { firstLine = false; } renderWrappedText(sb, width, nextLineTabStop, line); } } catch (IOException e) { // cannot happen } return sb; } /** * Finds the next text wrap position after <code>startPos</code> for the'], ['renderWrappedText(sb, width, nextLineTabStop, text);', ''], ['renderWrappedTextBlock(sb, width, nextLineTabStop, text);', 'private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) { try { BufferedReader in = new BufferedReader(new StringReader(text)); String line; boolean firstLine = true; while ((line = in.readLine()) != null) { if (!firstLine) { sb.append(getNewLine()); } else { firstLine = false; } renderWrappedText(sb, width, nextLineTabStop, line); } } catch (IOException e) { } return sb; }'], 'a/src/main/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/main/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-34', 2, 2, 2, 2, ['private int numberOfArgs = UNINITIALIZED; /** the type of this Option */ private Class type; /** the list of argument values **/ private List values = new ArrayList();', 'description = null; argName = null; longopt = null; type = null; required = false; numberOfArgs = Option.UNINITIALIZED; optionalArg = false;'], ['private int numberOfArgs = UNINITIALIZED; /** the type of this Option */ private Class type = String.class; /** the list of argument values **/ private List values = new ArrayList();', 'description = null; argName = null; longopt = null; type = String.class; required = false; numberOfArgs = Option.UNINITIALIZED; optionalArg = false;'], ['private Class type;', 'type = null;'], ['private Class type = String.class;', 'type = String.class;'], 'a/src/main/java/org/apache/commons/cli/OptionBuilder.java', 'b/src/main/java/org/apache/commons/cli/OptionBuilder.java']
['Cli-35', 1, 1, 1, 1, ['List<String> matchingOpts = new ArrayList<String>(); // for a perfect match return the single option only for (String longOpt : longOpts.keySet()) {'], ['List<String> matchingOpts = new ArrayList<String>(); // for a perfect match return the single option only if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); } for (String longOpt : longOpts.keySet()) {'], [''], ['if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); }'], 'a/src/main/java/org/apache/commons/cli/Options.java', 'b/src/main/java/org/apache/commons/cli/Options.java']
['Cli-36', 4, 4, 4, 4, [' import java.io.Serializable; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; /**', 'private static final long serialVersionUID = 1L; /** hold the options */ private final Map<String, Option> optionMap = new HashMap<String, Option>(); /** the name of the selected option */ private String selected;', 'import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.List;', 'private final List<Object> requiredOpts = new ArrayList<Object>(); /** a map of the option groups */ private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>(); /** * Add the specified option group.'], [' import java.io.Serializable; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; /**', 'private static final long serialVersionUID = 1L; /** hold the options */ private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>(); /** the name of the selected option */ private String selected;', 'import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.List;', 'private final List<Object> requiredOpts = new ArrayList<Object>(); /** a map of the option groups */ private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<String, OptionGroup>(); /** * Add the specified option group.'], ['import java.util.HashMap;', 'private final Map<String, Option> optionMap = new HashMap<String, Option>();', 'import java.util.HashMap;', 'private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>();'], ['import java.util.LinkedHashMap;', 'private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();', '', 'private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<String, OptionGroup>();'], 'a/src/main/java/org/apache/commons/cli/Options.java', 'b/src/main/java/org/apache/commons/cli/Options.java']
['Cli-37', 1, 1, 1, 1, ['private boolean isShortOption(String token) { // short options (-S, -SV, -S=V, -SV1=V2, -S1S2) return token.startsWith("-") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2)); // remove leading "-" and "=value" } /**'], ['private boolean isShortOption(String token) { // short options (-S, -SV, -S=V, -SV1=V2, -S1S2) if (!token.startsWith("-") || token.length() == 1) { return false; } // remove leading "-" and "=value" int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName); } /**'], ['return token.startsWith("-") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));'], ['if (!token.startsWith("-") || token.length() == 1) { return false; } int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName);'], 'a/src/main/java/org/apache/commons/cli/DefaultParser.java', 'b/src/main/java/org/apache/commons/cli/DefaultParser.java']
['Cli-38', 1, 1, 1, 1, ['// remove leading "-" and "=value" int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName); // check for several concatenated short options } /**'], ['// remove leading "-" and "=value" int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); if (options.hasShortOption(optName)) { return true; } // check for several concatenated short options return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0))); } /**'], ['return options.hasShortOption(optName);'], ['if (options.hasShortOption(optName)) { return true; } return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));'], 'a/src/main/java/org/apache/commons/cli/DefaultParser.java', 'b/src/main/java/org/apache/commons/cli/DefaultParser.java']
['Cli-39', 2, 2, 2, 2, ['} else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) {', '* @return The file input stream represented by <code>str</code>. * @throws ParseException if the file is not exist or not readable */ /** * Returns the File[] represented by <code>str</code>.'], ['} else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) {', '* @return The file input stream represented by <code>str</code>. * @throws ParseException if the file is not exist or not readable */ public static FileInputStream openFile(String str) throws ParseException { try { return new FileInputStream(str); } catch (FileNotFoundException e) { throw new ParseException("Unable to find file: " + str); } } /** * Returns the File[] represented by <code>str</code>.'], ['return createFile(str);', ''], ['return openFile(str);', 'public static FileInputStream openFile(String str) throws ParseException { try { return new FileInputStream(str); } catch (FileNotFoundException e) { throw new ParseException("Unable to find file: " + str); } }'], 'a/src/main/java/org/apache/commons/cli/TypeHandler.java', 'b/src/main/java/org/apache/commons/cli/TypeHandler.java']
['Cli-40', 1, 1, 1, 1, ['} else { return null; } }'], ['} else { throw new ParseException("Unable to handle the class: " + clazz); } }'], ['return null;'], ['throw new ParseException("Unable to handle the class: " + clazz);'], 'a/src/main/java/org/apache/commons/cli/TypeHandler.java', 'b/src/main/java/org/apache/commons/cli/TypeHandler.java']
['Chart-1', 1, 1, 1, 1, ['} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount();'], ['} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset == null) { return result; } int seriesCount = dataset.getRowCount();'], ['if (dataset != null) {'], ['if (dataset == null) {'], 'a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java', 'b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java']
['Chart-2', 2, 2, 2, 2, ['for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } }', 'for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } }'], ['for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value = intervalXYData.getXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } }', 'for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value = ixyd.getYValue(series, item); double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } }'], ['', ''], ['double value = intervalXYData.getXValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } maximum = Math.max(maximum, lvalue); minimum = Math.min(minimum, uvalue);', 'double value = ixyd.getYValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } maximum = Math.max(maximum, lvalue); minimum = Math.min(minimum, uvalue);'], 'a/source/org/jfree/data/general/DatasetUtilities.java', 'b/source/org/jfree/data/general/DatasetUtilities.java']
['Chart-3', 1, 1, 1, 1, ['throw new IllegalArgumentException("Requires start <= end."); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) {'], ['throw new IllegalArgumentException("Requires start <= end."); } TimeSeries copy = (TimeSeries) super.clone(); copy.minY = Double.NaN; copy.maxY = Double.NaN; copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) {'], [''], ['copy.minY = Double.NaN; copy.maxY = Double.NaN;'], 'a/source/org/jfree/data/time/TimeSeries.java', 'b/source/org/jfree/data/time/TimeSeries.java']
['Chart-4', 2, 2, 2, 2, ['} } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) {', 'includedAnnotations.add(a); } } } }'], ['} } if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) {', 'includedAnnotations.add(a); } } } } }'], ['', ''], ['if (r != null) {', '}'], 'a/source/org/jfree/chart/plot/XYPlot.java', 'b/source/org/jfree/chart/plot/XYPlot.java']
['Chart-5', 1, 1, 1, 1, ['if (x == null) { throw new IllegalArgumentException("Null \'x\' argument."); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone();'], ['if (x == null) { throw new IllegalArgumentException("Null \'x\' argument."); } if (this.allowDuplicateXValues) { add(x, y); return null; } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone();'], ['if (index >= 0 && !this.allowDuplicateXValues) {'], ['if (this.allowDuplicateXValues) { add(x, y); return null; } if (index >= 0) {'], 'a/source/org/jfree/data/xy/XYSeries.java', 'b/source/org/jfree/data/xy/XYSeries.java']
['Chart-6', 1, 1, 1, 1, ['if (!(obj instanceof ShapeList)) { return false; } return super.equals(obj); }'], ['if (!(obj instanceof ShapeList)) { return false; } ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true; }'], ['return super.equals(obj);'], ['ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true;'], 'a/source/org/jfree/chart/util/ShapeList.java', 'b/source/org/jfree/chart/util/ShapeList.java']
['Chart-7', 1, 1, 1, 1, ['} if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) {'], ['} if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) {'], ['long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()'], ['long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()'], 'source/org/jfree/data/time/TimePeriodValues.java\t(revision 1087)', 'source/org/jfree/data/time/TimePeriodValues.java\t(revision 1086)']
['Chart-8', 1, 1, 1, 1, ['*/ public Week(Date time, TimeZone zone) { // defer argument checking... this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); } /**'], ['*/ public Week(Date time, TimeZone zone) { // defer argument checking... this(time, zone, Locale.getDefault()); } /**'], ['this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());'], ['this(time, zone, Locale.getDefault());'], 'a/source/org/jfree/data/time/Week.java', 'b/source/org/jfree/data/time/Week.java']
['Chart-9', 1, 1, 1, 1, ['endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) {'], ['endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if ((endIndex < 0) || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {'], ['if (endIndex < 0) {'], ['if ((endIndex < 0) || (endIndex < startIndex)) {'], 'a/source/org/jfree/data/time/TimeSeries.java', 'b/source/org/jfree/data/time/TimeSeries.java']
['Chart-10', 1, 1, 1, 1, ['* @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { return " title=\\"" + toolTipText + "\\" alt=\\"\\""; }'], ['* @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { return " title=\\"" + ImageMapUtilities.htmlEscape(toolTipText) + "\\" alt=\\"\\""; }'], ['return " title=\\"" + toolTipText'], ['return " title=\\"" + ImageMapUtilities.htmlEscape(toolTipText)'], 'a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java', 'b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java']
['Chart-11', 1, 1, 1, 1, ['return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();'], ['return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();'], ['PathIterator iterator2 = p1.getPathIterator(null);'], ['PathIterator iterator2 = p2.getPathIterator(null);'], 'a/source/org/jfree/chart/util/ShapeUtilities.java', 'b/source/org/jfree/chart/util/ShapeUtilities.java']
['Chart-12', 1, 1, 1, 1, ['*/ public MultiplePiePlot(CategoryDataset dataset) { super(); this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();'], ['*/ public MultiplePiePlot(CategoryDataset dataset) { super(); setDataset(dataset); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();'], ['this.dataset = dataset;'], ['setDataset(dataset);'], 'a/source/org/jfree/chart/plot/MultiplePiePlot.java', 'b/source/org/jfree/chart/plot/MultiplePiePlot.java']
['Chart-13', 1, 1, 1, 1, ['h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);'], ['h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);'], ['new Range(0.0, constraint.getWidth() - w[2]),'], ['new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),'], 'a/source/org/jfree/chart/block/BorderArrangement.java', 'b/source/org/jfree/chart/block/BorderArrangement.java']
['Chart-14', 4, 4, 4, 4, ['markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();'], ['markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();'], ['', '', '', ''], ['if (markers == null) { return false; }', 'if (markers == null) { return false; }', 'if (markers == null) { return false; }', 'if (markers == null) { return false; }'], 'a/source/org/jfree/chart/plot/XYPlot.java', 'b/source/org/jfree/chart/plot/XYPlot.java']
['Chart-15', 2, 2, 2, 2, ['* @return The percent. */ public double getMaximumExplodePercent() { double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {', ' PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); state.setLatestAngle(plot.getStartAngle()); return state;'], ['* @return The percent. */ public double getMaximumExplodePercent() { if (this.dataset == null) { return 0.0; } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {', ' PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); } state.setLatestAngle(plot.getStartAngle()); return state;'], ['', ''], ['if (this.dataset == null) { return 0.0; }', 'if (this.dataset != null) { }'], 'a/source/org/jfree/chart/plot/PiePlot.java', 'b/source/org/jfree/chart/plot/PiePlot.java']
['Chart-16', 2, 2, 2, 2, [' } else { this.seriesKeys = null; this.categoryKeys = null; } }', 'if (categoryKeys == null) { throw new IllegalArgumentException("Null \'categoryKeys\' argument."); } if (categoryKeys.length != this.startData[0].length) { throw new IllegalArgumentException( "The number of categories does not match the data."); }'], [' } else { this.seriesKeys = new Comparable[0]; this.categoryKeys = new Comparable[0]; } }', 'if (categoryKeys == null) { throw new IllegalArgumentException("Null \'categoryKeys\' argument."); } if (categoryKeys.length != getCategoryCount()) { throw new IllegalArgumentException( "The number of categories does not match the data."); }'], ['this.seriesKeys = null; this.categoryKeys = null;', 'if (categoryKeys.length != this.startData[0].length) {'], ['this.seriesKeys = new Comparable[0]; this.categoryKeys = new Comparable[0];', 'if (categoryKeys.length != getCategoryCount()) {'], 'a/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java', 'b/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java']
['Chart-17', 1, 1, 1, 1, ['* subclasses may differ. */ public Object clone() throws CloneNotSupportedException { Object clone = createCopy(0, getItemCount() - 1); return clone; }'], ['* subclasses may differ. */ public Object clone() throws CloneNotSupportedException { TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data); return clone; }'], ['Object clone = createCopy(0, getItemCount() - 1);'], ['TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data);'], 'a/source/org/jfree/data/time/TimeSeries.java', 'b/source/org/jfree/data/time/TimeSeries.java']
['Chart-18', 3, 3, 3, 3, ['public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); if (index < this.keys.size()) { rebuildIndex(); } } /**', 'public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { return; } removeValue(index); }', '* @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); rowData.removeValue(columnKey); } this.columnKeys.remove(columnKey); }'], ['public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); rebuildIndex(); } /**', 'public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { throw new UnknownKeyException("The key (" + key + ") is not recognised."); } removeValue(index); }', '* @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { if (columnKey == null) { throw new IllegalArgumentException("Null \'columnKey\' argument."); } if (!this.columnKeys.contains(columnKey)) { throw new UnknownKeyException("Unknown key: " + columnKey); } Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); int index = rowData.getIndex(columnKey); if (index >= 0) { rowData.removeValue(columnKey); } } this.columnKeys.remove(columnKey); }'], ['if (index < this.keys.size()) { }', 'return;', ''], ['', 'throw new UnknownKeyException("The key (" + key + ") is not recognised.");', 'if (columnKey == null) { throw new IllegalArgumentException("Null \'columnKey\' argument."); } if (!this.columnKeys.contains(columnKey)) { throw new UnknownKeyException("Unknown key: " + columnKey); } int index = rowData.getIndex(columnKey); if (index >= 0) { }'], 'a/source/org/jfree/data/DefaultKeyedValues2D.java', 'b/source/org/jfree/data/DefaultKeyedValues2D.java']
['Chart-19', 2, 2, 2, 2, ['* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { return this.domainAxes.indexOf(axis); }', '* @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();'], ['* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); } return this.domainAxes.indexOf(axis); }', '* @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();'], ['', ''], ['if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); }', 'if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); }'], 'a/source/org/jfree/chart/plot/CategoryPlot.java', 'b/source/org/jfree/chart/plot/CategoryPlot.java']
['Chart-20', 1, 1, 1, 1, ['*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, paint, stroke, alpha); this.value = value; }'], ['*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; }'], ['super(paint, stroke, paint, stroke, alpha);'], ['super(paint, stroke, outlinePaint, outlineStroke, alpha);'], 'a/source/org/jfree/chart/plot/ValueMarker.java', 'b/source/org/jfree/chart/plot/ValueMarker.java']
['Chart-21', 3, 3, 3, 3, ['&& this.minimumRangeValueColumn == c)) { updateBounds(); } double minval = Double.NaN; if (item.getMinOutlier() != null) {', 'this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } this.rangeBounds = new Range(this.minimumRangeValue, this.maximumRangeValue);', '*/ private void updateBounds() { this.minimumRangeValue = Double.NaN; this.maximumRangeValue = Double.NaN; } /**'], ['&& this.minimumRangeValueColumn == c)) { updateBounds(); } else { double minval = Double.NaN; if (item.getMinOutlier() != null) {', 'this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } } this.rangeBounds = new Range(this.minimumRangeValue, this.maximumRangeValue);', '*/ private void updateBounds() { this.minimumRangeValue = Double.NaN; this.minimumRangeValueRow = -1; this.minimumRangeValueColumn = -1; this.maximumRangeValue = Double.NaN; this.maximumRangeValueRow = -1; this.maximumRangeValueColumn = -1; int rowCount = getRowCount(); int columnCount = getColumnCount(); for (int r = 0; r < rowCount; r++) { for (int c = 0; c < columnCount; c++) { BoxAndWhiskerItem item = getItem(r, c); if (item != null) { Number min = item.getMinOutlier(); if (min != null) { double minv = min.doubleValue(); if (!Double.isNaN(minv)) { if (minv < this.minimumRangeValue || Double.isNaN( this.minimumRangeValue)) { this.minimumRangeValue = minv; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } } } Number max = item.getMaxOutlier(); if (max != null) { double maxv = max.doubleValue(); if (!Double.isNaN(maxv)) { if (maxv > this.maximumRangeValue || Double.isNaN( this.maximumRangeValue)) { this.maximumRangeValue = maxv; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; } } } } } } } /**'], ['', '', ''], ['else {', '}', 'this.minimumRangeValueRow = -1; this.minimumRangeValueColumn = -1; this.maximumRangeValueRow = -1; this.maximumRangeValueColumn = -1; int rowCount = getRowCount(); int columnCount = getColumnCount(); for (int r = 0; r < rowCount; r++) { for (int c = 0; c < columnCount; c++) { BoxAndWhiskerItem item = getItem(r, c); if (item != null) { Number min = item.getMinOutlier(); if (min != null) { double minv = min.doubleValue(); if (!Double.isNaN(minv)) { if (minv < this.minimumRangeValue || Double.isNaN( this.minimumRangeValue)) { this.minimumRangeValue = minv; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } } } Number max = item.getMaxOutlier(); if (max != null) { double maxv = max.doubleValue(); if (!Double.isNaN(maxv)) { if (maxv > this.maximumRangeValue || Double.isNaN( this.maximumRangeValue)) { this.maximumRangeValue = maxv; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; } } } } } }'], 'a/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java', 'b/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java']
['Chart-22', 4, 4, 4, 4, ['throw new UnknownKeyException("Column key (" + columnKey + ") not recognised."); } if (row >= 0) { KeyedObjects rowData = (KeyedObjects) this.rows.get(row); return rowData.getObject(columnKey); } else { return null;', '} // 2. check whether the column is now empty. } /**', '*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); removeRow(index); }', 'Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { KeyedObjects rowData = (KeyedObjects) iterator.next(); rowData.removeValue(columnKey); } this.columnKeys.remove(columnKey); }'], ['throw new UnknownKeyException("Column key (" + columnKey + ") not recognised."); } KeyedObjects rowData = (KeyedObjects) this.rows.get(row); int index = rowData.getIndex(columnKey); if (index >= 0) { return rowData.getObject(index); } else { return null;', '} // 2. check whether the column is now empty. allNull = true; for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getObject(columnIndex) != null) { allNull = false; break; } } if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); } } /**', '*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); if (index < 0) { throw new UnknownKeyException("Row key (" + rowKey + ") not recognised."); } removeRow(index); }', 'Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { KeyedObjects rowData = (KeyedObjects) iterator.next(); int i = rowData.getIndex(columnKey); if (i >= 0) { rowData.removeValue(i); } } this.columnKeys.remove(columnKey); }'], ['if (row >= 0) { return rowData.getObject(columnKey);', '', '', 'rowData.removeValue(columnKey);'], ['int index = rowData.getIndex(columnKey); if (index >= 0) { return rowData.getObject(index);', 'allNull = true; for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getObject(columnIndex) != null) { allNull = false; break; } } if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); }', 'if (index < 0) { throw new UnknownKeyException("Row key (" + rowKey + ") not recognised."); }', 'int i = rowData.getIndex(columnKey); if (i >= 0) { rowData.removeValue(i); }'], 'a/source/org/jfree/data/KeyedObjects2D.java', 'b/source/org/jfree/data/KeyedObjects2D.java']
['Chart-23', 1, 1, 1, 1, ['* * @since 1.0.7 */ /** * Returns an icon.'], ['* * @since 1.0.7 */ public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); } /** * Returns an icon.'], [''], ['public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); }'], 'a/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java', 'b/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java']
['Chart-24', 1, 1, 1, 1, ['public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }'], ['public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }'], ['int g = (int) ((value - this.lowerBound) / (this.upperBound'], ['int g = (int) ((v - this.lowerBound) / (this.upperBound'], 'a/source/org/jfree/chart/renderer/GrayPaintScale.java', 'b/source/org/jfree/chart/renderer/GrayPaintScale.java']
['Chart-25', 6, 6, 6, 6, [' // BAR X Number meanValue = dataset.getMeanValue(row, column); double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);', ' // BAR Y Number meanValue = dataset.getMeanValue(row, column); double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);'], [' // BAR X Number meanValue = dataset.getMeanValue(row, column); if (meanValue == null) { return; } double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); } CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);', ' // BAR Y Number meanValue = dataset.getMeanValue(row, column); if (meanValue == null) { return; } double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); } CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);'], ['', 'double valueDelta = dataset.getStdDevValue(row, column).doubleValue();', '', '', 'double valueDelta = dataset.getStdDevValue(row, column).doubleValue();', ''], ['if (meanValue == null) { return; }', 'Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue();', '}', 'if (meanValue == null) { return; }', 'Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue();', '}'], 'a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java', 'b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java']
['Chart-26', 1, 1, 1, 1, ['} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } } return state;'], ['} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } } } return state;'], [''], ['if (owner != null) { }'], 'a/source/org/jfree/chart/axis/Axis.java', 'b/source/org/jfree/chart/axis/Axis.java']
['Lang-1', 1, 1, 1, 1, ['} } if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { // too many for Long return createBigInteger(str); } if (hexDigits > 8) { // too many for an int return createLong(str); } return createInteger(str);'], ["} } if (pfxLen > 0) { // we have a hex number char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } final int hexDigits = str.length() - pfxLen; if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);"], ['if (hexDigits > 16) { // too many for Long if (hexDigits > 8) { // too many for an int'], ["char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int"], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-2', 1, 1, 1, 1, ['if (str == null) { return null; } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException("Invalid locale format: " + str);'], ['if (str == null) { return null; } if (str.contains("#")) { // LANG-879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException("Invalid locale format: " + str); } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException("Invalid locale format: " + str);'], [''], ['if (str.contains("#")) { // LANG-879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException("Invalid locale format: " + str); }'], 'a/src/main/java/org/apache/commons/lang3/LocaleUtils.java', 'b/src/main/java/org/apache/commons/lang3/LocaleUtils.java']
['Lang-3', 1, 1, 1, 1, ['//Must be a Float, Double, BigDecimal final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number }'], ['//Must be a Float, Double, BigDecimal final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number }'], [''], ['if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float } if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double }'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-4', 3, 3, 3, 3, ['*/ public class LookupTranslator extends CharSequenceTranslator { private final HashMap<CharSequence, CharSequence> lookupMap; private final int shortest; private final int longest;', '* @param lookup CharSequence[][] table of size [*][2] */ public LookupTranslator(final CharSequence[]... lookup) { lookupMap = new HashMap<CharSequence, CharSequence>(); int _shortest = Integer.MAX_VALUE; int _longest = 0; if (lookup != null) { for (final CharSequence[] seq : lookup) { this.lookupMap.put(seq[0], seq[1]); final int sz = seq[0].length(); if (sz < _shortest) { _shortest = sz;', '// descend so as to get a greedy algorithm for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq); if (result != null) { out.write(result.toString()); return i;'], ['*/ public class LookupTranslator extends CharSequenceTranslator { private final HashMap<String, CharSequence> lookupMap; private final int shortest; private final int longest;', '* @param lookup CharSequence[][] table of size [*][2] */ public LookupTranslator(final CharSequence[]... lookup) { lookupMap = new HashMap<String, CharSequence>(); int _shortest = Integer.MAX_VALUE; int _longest = 0; if (lookup != null) { for (final CharSequence[] seq : lookup) { this.lookupMap.put(seq[0].toString(), seq[1]); final int sz = seq[0].length(); if (sz < _shortest) { _shortest = sz;', '// descend so as to get a greedy algorithm for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq.toString()); if (result != null) { out.write(result.toString()); return i;'], ['private final HashMap<CharSequence, CharSequence> lookupMap;', 'lookupMap = new HashMap<CharSequence, CharSequence>(); this.lookupMap.put(seq[0], seq[1]);', 'final CharSequence result = lookupMap.get(subSeq);'], ['private final HashMap<String, CharSequence> lookupMap;', 'lookupMap = new HashMap<String, CharSequence>(); this.lookupMap.put(seq[0].toString(), seq[1]);', 'final CharSequence result = lookupMap.get(subSeq.toString());'], 'a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java']
['Lang-5', 2, 2, 2, 2, ['throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch0 = str.charAt(0); final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str);', 'throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); } //-----------------------------------------------------------------------'], ['throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch0 = str.charAt(0); if (ch0 == \'_\') { if (len < 3) { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 3) { return new Locale("", str.substring(1, 3)); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(3) != \'_\') { throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale("", str.substring(1, 3), str.substring(4)); } else { final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str);', 'throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); } } //-----------------------------------------------------------------------'], ['', ''], ['if (ch0 == \'_\') { if (len < 3) { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 3) { return new Locale("", str.substring(1, 3)); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(3) != \'_\') { throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale("", str.substring(1, 3), str.substring(4)); } else {', '}'], 'a/src/main/java/org/apache/commons/lang3/LocaleUtils.java', 'b/src/main/java/org/apache/commons/lang3/LocaleUtils.java']
['Lang-6', 1, 1, 1, 1, ['// // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pos)); } } }'], ['// // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pt)); } } }'], ['pos += Character.charCount(Character.codePointAt(input, pos));'], ['pos += Character.charCount(Character.codePointAt(input, pt));'], 'a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java']
['Lang-7', 2, 2, 2, 2, ['if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith("-")) { // drop -', 'if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return new BigDecimal(str); }'], ['if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith("-")) { // drop -', 'if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.trim().startsWith("--")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. throw new NumberFormatException(str + " is not a valid number."); } return new BigDecimal(str); }'], ['if (str.startsWith("--")) { return null; }', ''], ['', 'if (str.trim().startsWith("--")) { throw new NumberFormatException(str + " is not a valid number."); }'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-8', 3, 3, 3, 3, ['private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final TimeZone zone; private final String mStandard; private final String mDaylight;', 'TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mLocale = locale; mStyle = style; zone = timeZone; mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);', '*/ @Override public void appendTo(StringBuffer buffer, Calendar calendar) { if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));'], ['private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight;', 'TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mLocale = locale; mStyle = style; mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);', '*/ @Override public void appendTo(StringBuffer buffer, Calendar calendar) { TimeZone zone = calendar.getTimeZone(); if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));'], ['private final TimeZone zone;', 'zone = timeZone;', ''], ['', '', 'TimeZone zone = calendar.getTimeZone();'], 'a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java']
['Lang-9', 1, 1, 1, 1, ['currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }'], ['currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException("Failed to parse \\""+pattern+"\\" ; gave up at index "+patternMatcher.regionStart()); } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }'], [''], ['if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException("Failed to parse \\""+pattern+"\\" ; gave up at index "+patternMatcher.regionStart()); }'], 'a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java']
['Lang-10', 1, 1, 1, 1, ['* @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append("\\\\s*+"); } continue; } wasWhite= false; switch(c) { case \'\\\'\': if(unquote) {'], ["* @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); switch(c) { case '\\'': if(unquote) {"], ['boolean wasWhite= false; if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append("\\\\s*+"); } continue; } wasWhite= false;'], [''], 'a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java']
['Lang-11', 1, 1, 1, 1, ["start = ' '; } } } char[] buffer = new char[count];"], ['start = \' \'; } } } else { if (end <= start) { throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); } } char[] buffer = new char[count];'], [''], ['} else { if (end <= start) { throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); }'], 'a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java', 'b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java']
['Lang-12', 1, 1, 1, 1, ['} else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = \'z\' + 1; start = \' \'; } } char[] buffer = new char[count];'], ['} else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); } if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = \'z\' + 1; start = \' \'; } } } char[] buffer = new char[count];'], [''], ['if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); } if (chars != null) { end = chars.length; } else { }'], 'a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java', 'b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java']
['Lang-13', 3, 3, 3, 3, ['* class here is a workaround, see the JIRA issue LANG-626. </p> */ static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private ClassLoader classLoader; /**', 'super(in); this.classLoader = classLoader; } /**', 'try { return Class.forName(name, false, classLoader); } catch (ClassNotFoundException ex) { return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); } }'], ['* class here is a workaround, see the JIRA issue LANG-626. </p> */ static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private static final Map<String, Class<?>> primitiveTypes = new HashMap<String, Class<?>>(); private ClassLoader classLoader; /**', 'super(in); this.classLoader = classLoader; primitiveTypes.put("byte", byte.class); primitiveTypes.put("short", short.class); primitiveTypes.put("int", int.class); primitiveTypes.put("long", long.class); primitiveTypes.put("float", float.class); primitiveTypes.put("double", double.class); primitiveTypes.put("boolean", boolean.class); primitiveTypes.put("char", char.class); primitiveTypes.put("void", void.class); } /**', 'try { return Class.forName(name, false, classLoader); } catch (ClassNotFoundException ex) { try { return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); } catch (ClassNotFoundException cnfe) { Class<?> cls = primitiveTypes.get(name); if (cls != null) return cls; else throw cnfe; } } }'], ['', '', ''], ['private static final Map<String, Class<?>> primitiveTypes = new HashMap<String, Class<?>>();', 'primitiveTypes.put("byte", byte.class); primitiveTypes.put("short", short.class); primitiveTypes.put("int", int.class); primitiveTypes.put("long", long.class); primitiveTypes.put("float", float.class); primitiveTypes.put("double", double.class); primitiveTypes.put("boolean", boolean.class); primitiveTypes.put("char", char.class); primitiveTypes.put("void", void.class);', 'try { } catch (ClassNotFoundException cnfe) { Class<?> cls = primitiveTypes.get(name); if (cls != null) return cls; else throw cnfe; }'], 'a/src/main/java/org/apache/commons/lang3/SerializationUtils.java', 'b/src/main/java/org/apache/commons/lang3/SerializationUtils.java']
['Lang-14', 1, 1, 1, 1, ['if (cs1 == null || cs2 == null) { return false; } return cs1.equals(cs2); } /**'], ['if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); } /**'], [''], ['if (cs1 instanceof String && cs2 instanceof String) { } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-15', 2, 2, 2, 2, ['toClass, typeVarAssigns); // now to check each type argument for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { Type toTypeArg = entry.getValue(); Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the', ': new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); // has target class been reached? if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) { return typeVarAssigns; }'], ['toClass, typeVarAssigns); // now to check each type argument for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the', ': new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); // has target class been reached? if (toClass.equals(cls)) { return typeVarAssigns; }'], ['for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { Type toTypeArg = entry.getValue(); Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());', 'if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {'], ['for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);', 'if (toClass.equals(cls)) {'], 'a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java', 'b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java']
['Lang-16', 1, 1, 1, 1, ['// a wrong value. return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);'], ['// a wrong value. return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);'], ['if (str.startsWith("0x") || str.startsWith("-0x")) {'], ['if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) {'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-17', 1, 1, 1, 1, ['return; } int pos = 0; int len = Character.codePointCount(input, 0, input.length()); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); } else { // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++; } }'], ['return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pos)); } } }'], ['int len = Character.codePointCount(input, 0, input.length()); else { if (pos < len - 2) { } else { pos++; } } pos--; pos++;'], ['int len = input.length(); pos+= c.length; continue;'], 'a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java']
['Lang-18', 1, 1, 1, 1, ["rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': // month in year (text and number)"], ["rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; } else { rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); } break; case 'M': // month in year (text and number)"], ['if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); rule = TwoDigitYearField.INSTANCE;'], ['if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);'], 'a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java']
['Lang-19', 3, 3, 3, 3, ["public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;", "isHex = true; // Check there's more than just an x after the &# } int end = start; // Note that this supports character codes without a ; on the end while(input.charAt(end) != ';') { end++; }", 'out.write(entityValue); } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0; }'], ["public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;", "isHex = true; // Check there's more than just an x after the &# if(start == seqEnd) { return 0; } } int end = start; // Note that this supports character codes without a ; on the end while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) ) { end++; }", "out.write(entityValue); } boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';'); return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0); } return 0; }"], ["if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {", "while(input.charAt(end) != ';')", 'return 2 + (end - start) + (isHex ? 1 : 0) + 1;'], ["if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {", "if(start == seqEnd) { return 0; } while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )", "boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';'); return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);"], 'a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java']
['Lang-20', 2, 2, 2, 2, ['return EMPTY; } StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {', 'return EMPTY; } StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {'], ['return EMPTY; } StringBuilder buf = new StringBuilder(noOfItems * 16); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {', 'return EMPTY; } StringBuilder buf = new StringBuilder(noOfItems * 16); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {'], ['StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);', 'StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());'], ['StringBuilder buf = new StringBuilder(noOfItems * 16);', 'StringBuilder buf = new StringBuilder(noOfItems * 16);'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-21', 1, 1, 1, 1, ['return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&'], ['return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&'], ['cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&'], ['cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&'], 'a/src/main/java/org/apache/commons/lang3/time/DateUtils.java', 'b/src/main/java/org/apache/commons/lang3/time/DateUtils.java']
['Lang-22', 1, 1, 1, 1, ['*/ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to'], ['*/ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException("overflow: gcd is 2^31"); } return Math.abs(u) + Math.abs(v); } //if either operand is abs 1, return 1: if (Math.abs(u) == 1 || Math.abs(v) == 1) { return 1; } // keep u and v negative, as negative integers range down to'], ['if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {'], ['if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException("overflow: gcd is 2^31"); } return Math.abs(u) + Math.abs(v); } if (Math.abs(u) == 1 || Math.abs(v) == 1) {'], 'a/src/main/java/org/apache/commons/lang3/math/Fraction.java', 'b/src/main/java/org/apache/commons/lang3/math/Fraction.java']
['Lang-23', 2, 2, 2, 2, ['*/ public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final String DUMMY_PATTERN = ""; private static final String ESCAPED_QUOTE = "\'\'";', '* @param obj the object to compare to * @return true if this object equals the other, otherwise false */ /** * Return the hashcode. * * @return the hashcode */ /** * Get a custom format from a format description.'], ['*/ public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final int HASH_SEED = 31; private static final String DUMMY_PATTERN = ""; private static final String ESCAPED_QUOTE = "\'\'";', '* @param obj the object to compare to * @return true if this object equals the other, otherwise false */ @Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (!super.equals(obj)) { return false; } if (ObjectUtils.notEqual(getClass(), obj.getClass())) { return false; } ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj; if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { return false; } if (ObjectUtils.notEqual(registry, rhs.registry)) { return false; } return true; } /** * Return the hashcode. * * @return the hashcode */ @Override public int hashCode() { int result = super.hashCode(); result = HASH_SEED * result + ObjectUtils.hashCode(registry); result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); return result; } /** * Get a custom format from a format description.'], ['', ''], ['private static final int HASH_SEED = 31;', '@Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (!super.equals(obj)) { return false; } if (ObjectUtils.notEqual(getClass(), obj.getClass())) { return false; } ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj; if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { return false; } if (ObjectUtils.notEqual(registry, rhs.registry)) { return false; } return true; } @Override public int hashCode() { int result = super.hashCode(); result = HASH_SEED * result + ObjectUtils.hashCode(registry); result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); return result; }'], 'a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java', 'b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java']
['Lang-24', 1, 1, 1, 1, ["if (chars[i] == 'l' || chars[i] == 'L') { // not allowing L with an exponent or decimal point return foundDigit && !hasExp; } // last character is illegal return false;"], ["if (chars[i] == 'l' || chars[i] == 'L') { // not allowing L with an exponent or decimal point return foundDigit && !hasExp && !hasDecPoint; } // last character is illegal return false;"], ['return foundDigit && !hasExp;'], ['return foundDigit && !hasExp && !hasDecPoint;'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-25', 1, 1, 1, 1, ['{"\\u00C7", "&Ccedil;"}, // - uppercase C, cedilla {"\\u00C8", "&Egrave;"}, // - uppercase E, grave accent {"\\u00C9", "&Eacute;"}, // - uppercase E, acute accent {"\\u00CB", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CC", "&Euml;"}, // - uppercase E, umlaut {"\\u00CD", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CE", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CF", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00D0", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D1", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D2", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D3", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D4", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D5", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D6", "&Otilde;"}, // - uppercase O, tilde {"\\u00D7", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D8", "&times;"}, // multiplication sign {"\\u00D9", "&Oslash;"}, // - uppercase O, slash {"\\u00DA", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DB", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DC", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DD", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DE", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DF", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00E0", "&szlig;"}, // - lowercase sharps, German {"\\u00E1", "&agrave;"}, // - lowercase a, grave accent {"\\u00E2", "&aacute;"}, // - lowercase a, acute accent {"\\u00E3", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E4", "&atilde;"}, // - lowercase a, tilde {"\\u00E5", "&auml;"}, // - lowercase a, umlaut {"\\u00E5", "&aring;"}, // - lowercase a, ring {"\\u00E6", "&aelig;"}, // - lowercase ae {"\\u00E7", "&ccedil;"}, // - lowercase c, cedilla'], ['{"\\u00C7", "&Ccedil;"}, // - uppercase C, cedilla {"\\u00C8", "&Egrave;"}, // - uppercase E, grave accent {"\\u00C9", "&Eacute;"}, // - uppercase E, acute accent {"\\u00CA", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CB", "&Euml;"}, // - uppercase E, umlaut {"\\u00CC", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CD", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CE", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00CF", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D0", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D1", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D2", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D3", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D4", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D5", "&Otilde;"}, // - uppercase O, tilde {"\\u00D6", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D7", "&times;"}, // multiplication sign {"\\u00D8", "&Oslash;"}, // - uppercase O, slash {"\\u00D9", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DA", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DB", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DC", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DD", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DE", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00DF", "&szlig;"}, // - lowercase sharps, German {"\\u00E0", "&agrave;"}, // - lowercase a, grave accent {"\\u00E1", "&aacute;"}, // - lowercase a, acute accent {"\\u00E2", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E3", "&atilde;"}, // - lowercase a, tilde {"\\u00E4", "&auml;"}, // - lowercase a, umlaut {"\\u00E5", "&aring;"}, // - lowercase a, ring {"\\u00E6", "&aelig;"}, // - lowercase ae {"\\u00E7", "&ccedil;"}, // - lowercase c, cedilla'], ['{"\\u00CB", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CC", "&Euml;"}, // - uppercase E, umlaut {"\\u00CD", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CE", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CF", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00D0", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D1", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D2", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D3", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D4", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D5", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D6", "&Otilde;"}, // - uppercase O, tilde {"\\u00D7", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D8", "&times;"}, // multiplication sign {"\\u00D9", "&Oslash;"}, // - uppercase O, slash {"\\u00DA", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DB", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DC", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DD", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DE", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DF", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00E0", "&szlig;"}, // - lowercase sharps, German {"\\u00E1", "&agrave;"}, // - lowercase a, grave accent {"\\u00E2", "&aacute;"}, // - lowercase a, acute accent {"\\u00E3", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E4", "&atilde;"}, // - lowercase a, tilde {"\\u00E5", "&auml;"}, // - lowercase a, umlaut'], ['{"\\u00CA", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CB", "&Euml;"}, // - uppercase E, umlaut {"\\u00CC", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CD", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CE", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00CF", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D0", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D1", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D2", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D3", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D4", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D5", "&Otilde;"}, // - uppercase O, tilde {"\\u00D6", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D7", "&times;"}, // multiplication sign {"\\u00D8", "&Oslash;"}, // - uppercase O, slash {"\\u00D9", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DA", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DB", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DC", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DD", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DE", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00DF", "&szlig;"}, // - lowercase sharps, German {"\\u00E0", "&agrave;"}, // - lowercase a, grave accent {"\\u00E1", "&aacute;"}, // - lowercase a, acute accent {"\\u00E2", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E3", "&atilde;"}, // - lowercase a, tilde {"\\u00E4", "&auml;"}, // - lowercase a, umlaut'], 'a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java']
['Lang-26', 1, 1, 1, 1, ['* @return the formatted string */ public String format(Date date) { Calendar c = new GregorianCalendar(mTimeZone); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }'], ['* @return the formatted string */ public String format(Date date) { Calendar c = new GregorianCalendar(mTimeZone, mLocale); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }'], ['Calendar c = new GregorianCalendar(mTimeZone);'], ['Calendar c = new GregorianCalendar(mTimeZone, mLocale);'], 'a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java']
['Lang-27', 2, 2, 2, 2, ['if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos);', 'mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str;'], ['if (decPos > -1) { if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos);', 'mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str;'], ['if (expPos < decPos) {', ''], ['if (expPos < decPos || expPos > str.length()) {', 'if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); }'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-28', 1, 1, 1, 1, ['return 0; } out.write(entityValue); return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;'], ['return 0; } if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { out.write(entityValue); } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;'], [''], ['if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { }'], 'a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java']
['Lang-29', 1, 1, 1, 1, ['* * @return the version, for example 131 for Java 1.3.1 */ static float toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }'], ['* * @return the version, for example 131 for Java 1.3.1 */ static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }'], ['static float toJavaVersionInt(String version) {'], ['static int toJavaVersionInt(String version) {'], 'a/src/main/java/org/apache/commons/lang3/SystemUtils.java', 'b/src/main/java/org/apache/commons/lang3/SystemUtils.java']
['Lang-30', 7, 7, 7, 7, ['return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { // ch is a supplementary character return i; } } }', '* <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; }', 'char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // missing low surrogate, fine, like String.indexOf(String) if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else {', '* @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }', 'return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i;', 'int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND;', 'return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { // missing low surrogate, fine, like String.indexOf(String) // ch is in the Basic Multilingual Plane return false; } } }'], ['return INDEX_NOT_FOUND; } int csLen = cs.length(); int csLast = csLen - 1; int searchLen = searchChars.length; int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return i; } } else { return i; } } } }', '* <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(String cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; }', 'char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (Character.isHighSurrogate(ch)) { if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) return true; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else {', '* @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(String cs, String searchChars) { if (searchChars == null) { return false; }', 'return INDEX_NOT_FOUND; } int csLen = cs.length(); int csLast = csLen - 1; int searchLen = searchChars.length; int searchLast = searchLen - 1; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { continue outer; } } else { continue outer; } } } return i;', 'int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); boolean chFound = searchChars.indexOf(ch) >= 0; if (i + 1 < strLen && Character.isHighSurrogate(ch)) { char ch2 = str.charAt(i + 1); if (chFound && searchChars.indexOf(ch2) < 0) { return i; } } else { if (!chFound) { return i; } } } return INDEX_NOT_FOUND;', 'return true; } int csLen = cs.length(); int csLast = csLen - 1; int searchLen = searchChars.length; int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { if (Character.isHighSurrogate(ch)) { if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) return false; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return false; } } else { // ch is in the Basic Multilingual Plane return false; } } } }'], ['', 'public static boolean containsAny(CharSequence cs, char[] searchChars) {', 'if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) {', 'public static boolean containsAny(CharSequence cs, String searchChars) {', '', 'if (searchChars.indexOf(ch) < 0) {', ''], ['int csLast = csLen - 1; int searchLast = searchLen - 1; if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return i; } } else { }', 'public static boolean containsAny(String cs, char[] searchChars) {', 'if (Character.isHighSurrogate(ch)) { if (j == searchLast) { return true; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {', 'public static boolean containsAny(String cs, String searchChars) {', 'int csLast = csLen - 1; int searchLast = searchLen - 1; if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { continue outer; } } else { }', 'boolean chFound = searchChars.indexOf(ch) >= 0; if (i + 1 < strLen && Character.isHighSurrogate(ch)) { char ch2 = str.charAt(i + 1); if (chFound && searchChars.indexOf(ch2) < 0) { } } else { if (!chFound) { return i; }', 'int csLast = csLen - 1; int searchLast = searchLen - 1; if (Character.isHighSurrogate(ch)) { if (j == searchLast) { return false; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return false; } } else { }'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-31', 1, 1, 1, 1, ['} int csLength = cs.length(); int searchLength = searchChars.length; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { // ch is a supplementary character // ch is in the Basic Multilingual Plane return true; } } }'], ['} int csLength = cs.length(); int searchLength = searchChars.length; int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { // ch is in the Basic Multilingual Plane return true; } } } }'], [''], ['int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { }'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-32', 4, 4, 4, 4, ['* * @since 2.3 */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { @Override protected Set<IDKey> initialValue() { return new HashSet<IDKey>(); } }; /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()', '* @since 2.3 */ static boolean isRegistered(Object value) { return getRegistry().contains(new IDKey(value)); } /**', '* The object to register. */ static void register(Object value) { getRegistry().add(new IDKey(value)); }', '* @since 2.3 */ static void unregister(Object value) { getRegistry().remove(new IDKey(value)); } /**'], ['* * @since 2.3 */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>(); /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()', '* @since 2.3 */ static boolean isRegistered(Object value) { Set<IDKey> registry = getRegistry(); return registry != null && registry.contains(new IDKey(value)); } /**', '* The object to register. */ static void register(Object value) { synchronized (HashCodeBuilder.class) { if (getRegistry() == null) { REGISTRY.set(new HashSet<IDKey>()); } } getRegistry().add(new IDKey(value)); }', '* @since 2.3 */ static void unregister(Object value) { Set<IDKey> s = getRegistry(); if (s != null) { s.remove(new IDKey(value)); synchronized (HashCodeBuilder.class) { if (s.isEmpty()) { REGISTRY.remove(); } } } } /**'], ['private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { @Override protected Set<IDKey> initialValue() { return new HashSet<IDKey>(); } };', 'return getRegistry().contains(new IDKey(value));', '', 'getRegistry().remove(new IDKey(value));'], ['private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();', 'Set<IDKey> registry = getRegistry(); return registry != null && registry.contains(new IDKey(value));', 'synchronized (HashCodeBuilder.class) { if (getRegistry() == null) { REGISTRY.set(new HashSet<IDKey>()); } }', 'Set<IDKey> s = getRegistry(); if (s != null) { s.remove(new IDKey(value)); synchronized (HashCodeBuilder.class) { if (s.isEmpty()) { REGISTRY.remove(); } } }'], 'a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java', 'b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java']
['Lang-33', 1, 1, 1, 1, ['} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }'], ['} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; }'], ['classes[i] = array[i].getClass();'], ['classes[i] = array[i] == null ? null : array[i].getClass();'], 'a/src/main/java/org/apache/commons/lang3/ClassUtils.java', 'b/src/main/java/org/apache/commons/lang3/ClassUtils.java']
['Lang-34', 2, 2, 2, 2, ['* @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); } /**', '*/ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); return m.containsKey(value); } /**'], ['* @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { return REGISTRY.get(); } /**', '*/ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); return m != null && m.containsKey(value); } /**'], ['return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();', 'return m.containsKey(value);'], ['return REGISTRY.get();', 'return m != null && m.containsKey(value);'], 'a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java', 'b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java']
['Lang-35', 2, 2, 2, 2, ['} else if (element != null) { type = element.getClass(); } else { type = Object.class; } @SuppressWarnings("unchecked") // type must be T T[] newArray = (T[]) copyArrayGrow1(array, type);', '} else if (element != null) { clss = element.getClass(); } else { return (T[]) new Object[] { null }; } @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T final T[] newArray = (T[]) add(array, index, element, clss);'], ['} else if (element != null) { type = element.getClass(); } else { throw new IllegalArgumentException("Arguments cannot both be null"); } @SuppressWarnings("unchecked") // type must be T T[] newArray = (T[]) copyArrayGrow1(array, type);', '} else if (element != null) { clss = element.getClass(); } else { throw new IllegalArgumentException("Array and element cannot both be null"); } @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T final T[] newArray = (T[]) add(array, index, element, clss);'], ['type = Object.class;', 'return (T[]) new Object[] { null };'], ['throw new IllegalArgumentException("Arguments cannot both be null");', 'throw new IllegalArgumentException("Array and element cannot both be null");'], 'a/src/main/java/org/apache/commons/lang3/ArrayUtils.java', 'b/src/main/java/org/apache/commons/lang3/ArrayUtils.java']
['Lang-36', 2, 2, 2, 2, ['} dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else {', "// can't have an E at the last byte return false; } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"], ["} dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else {", "// can't have an E at the last byte return false; } if (chars[i] == '.') { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; } // single trailing decimal point after non-exponent is ok return foundDigit; } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"], ['if (!Character.isDigit(lastChar)) {', ''], ["if (!Character.isDigit(lastChar) && lastChar != '.') {", "if (chars[i] == '.') { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; } // single trailing decimal point after non-exponent is ok return foundDigit; }"], 'a/src/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-37', 1, 1, 1, 1, ['final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); // Check if problem is incompatible types return joinedArray; }'], ['final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); } catch (ArrayStoreException ase) { // Check if problem is incompatible types final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "+type1.getName()); } throw ase; // No, so rethrow original } return joinedArray; }'], [''], ['try { } catch (ArrayStoreException ase) { final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "+type1.getName()); } throw ase; // No, so rethrow original }'], 'a/src/java/org/apache/commons/lang3/ArrayUtils.java', 'b/src/java/org/apache/commons/lang3/ArrayUtils.java']
['Lang-38', 1, 1, 1, 1, ['*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }'], ['*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { calendar.getTime(); /// LANG-538 calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }'], [''], ['calendar.getTime(); /// LANG-538'], 'a/src/java/org/apache/commons/lang3/time/FastDateFormat.java', 'b/src/java/org/apache/commons/lang3/time/FastDateFormat.java']
['Lang-39', 1, 1, 1, 1, [' // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches'], [' // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches'], [''], ['if (searchList[i] == null || replacementList[i] == null) { continue; }'], 'a/src/java/org/apache/commons/lang3/StringUtils.java', 'b/src/java/org/apache/commons/lang3/StringUtils.java']
['Lang-40', 1, 1, 1, 1, ['if (str == null || searchStr == null) { return false; } return contains(str.toUpperCase(), searchStr.toUpperCase()); } // IndexOfAny chars'], ['if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } // IndexOfAny chars'], ['return contains(str.toUpperCase(), searchStr.toUpperCase());'], ['int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;'], 'a/src/java/org/apache/commons/lang/StringUtils.java', 'b/src/java/org/apache/commons/lang/StringUtils.java']
['Lang-41', 3, 3, 3, 3, ['return StringUtils.EMPTY; } // Handle array encoding // Strip Object type encoding int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf(', 'if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } // Package name', '* @return the package name or an empty string */ public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY; } // Strip array encoding // Strip Object type encoding int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) {'], ['return StringUtils.EMPTY; } StringBuffer arrayPrefix = new StringBuffer(); // Handle array encoding if (className.startsWith("[")) { while (className.charAt(0) == \'[\') { className = className.substring(1); arrayPrefix.append("[]"); } // Strip Object type encoding if (className.charAt(0) == \'L\' && className.charAt(className.length() - 1) == \';\') { className = className.substring(1, className.length() - 1); } } if (reverseAbbreviationMap.containsKey(className)) { className = reverseAbbreviationMap.get(className); } int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf(', 'if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out + arrayPrefix; } // Package name', "* @return the package name or an empty string */ public static String getPackageName(String className) { if (className == null || className.length() == 0) { return StringUtils.EMPTY; } // Strip array encoding while (className.charAt(0) == '[') { className = className.substring(1); } // Strip Object type encoding if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { className = className.substring(1); } int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) {"], ['', 'return out;', 'if (className == null) {'], ['StringBuffer arrayPrefix = new StringBuffer(); if (className.startsWith("[")) { while (className.charAt(0) == \'[\') { className = className.substring(1); arrayPrefix.append("[]"); } if (className.charAt(0) == \'L\' && className.charAt(className.length() - 1) == \';\') { className = className.substring(1, className.length() - 1); } } if (reverseAbbreviationMap.containsKey(className)) { className = reverseAbbreviationMap.get(className); }', 'return out + arrayPrefix;', "if (className == null || className.length() == 0) { while (className.charAt(0) == '[') { className = className.substring(1); } if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { className = className.substring(1); }"], 'a/src/java/org/apache/commons/lang/ClassUtils.java', 'b/src/java/org/apache/commons/lang/ClassUtils.java']
['Lang-42', 1, 1, 1, 1, ['public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) { if (c > 0x7F) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\');'], ['public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { if (c >= 0x010000 && i < len - 1) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\'); i++; } else if (c > 0x7F) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\');'], ['char c = str.charAt(i); if (c > 0x7F) {'], ['int c = Character.codePointAt(str, i); if (c >= 0x010000 && i < len - 1) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\'); i++; } else if (c > 0x7F) {'], 'a/src/java/org/apache/commons/lang/Entities.java', 'b/src/java/org/apache/commons/lang/Entities.java']
['Lang-43', 1, 1, 1, 1, ['int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;'], ['int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;'], [''], ['next(pos);'], 'a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java', 'b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java']
['Lang-44', 1, 1, 1, 1, ['if (val.length() == 0) { throw new NumberFormatException("\\"\\" is not a valid number."); } if (val.startsWith("--")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear'], ['if (val.length() == 0) { throw new NumberFormatException("\\"\\" is not a valid number."); } if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + " is not a valid number."); } if (val.startsWith("--")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear'], [''], ['if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + " is not a valid number."); }'], 'a/src/java/org/apache/commons/lang/NumberUtils.java', 'b/src/java/org/apache/commons/lang/NumberUtils.java']
['Lang-45', 1, 1, 1, 1, [' // if the lower value is greater than the length of the string, // set to the length of the string // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {'], [' // if the lower value is greater than the length of the string, // set to the length of the string if (lower > str.length()) { lower = str.length(); } // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {'], [''], ['if (lower > str.length()) { lower = str.length(); }'], 'a/src/java/org/apache/commons/lang/WordUtils.java', 'b/src/java/org/apache/commons/lang/WordUtils.java']
['Lang-46', 7, 7, 7, 7, ['* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { return escapeJavaStyleString(str, false); } /**', '* @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, false); } /**', '* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { return escapeJavaStyleString(str, true); } /**', '* @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, true); } /**', '* @param escapeForwardSlash TODO * @return the escaped string */ private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); escapeJavaStyleString(writer, str, escapeSingleQuotes); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter', '* @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { if (out == null) { throw new IllegalArgumentException("The Writer must not be null"); }', "out.write('\\\\'); break; case '/' : out.write('\\\\'); out.write('/'); break; default :"], ['* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { return escapeJavaStyleString(str, false, false); } /**', '* @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, false, false); } /**', '* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { return escapeJavaStyleString(str, true, true); } /**', '* @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, true, true); } /**', '* @param escapeForwardSlash TODO * @return the escaped string */ private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter', '* @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, boolean escapeForwardSlash) throws IOException { if (out == null) { throw new IllegalArgumentException("The Writer must not be null"); }', "out.write('\\\\'); break; case '/' : if (escapeForwardSlash) { out.write('\\\\'); } out.write('/'); break; default :"], ['return escapeJavaStyleString(str, false);', 'escapeJavaStyleString(out, str, false);', 'return escapeJavaStyleString(str, true);', 'escapeJavaStyleString(out, str, true);', 'private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { escapeJavaStyleString(writer, str, escapeSingleQuotes);', 'private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {', ''], ['return escapeJavaStyleString(str, false, false);', 'escapeJavaStyleString(out, str, false, false);', 'return escapeJavaStyleString(str, true, true);', 'escapeJavaStyleString(out, str, true, true);', 'private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);', 'private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, boolean escapeForwardSlash) throws IOException {', 'if (escapeForwardSlash) { }'], 'a/src/java/org/apache/commons/lang/StringEscapeUtils.java', 'b/src/java/org/apache/commons/lang/StringEscapeUtils.java']
['Lang-47', 2, 2, 2, 2, ['if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size);', 'if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size);'], ['if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); if (str == null) { str = ""; } int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size);', 'if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); if (str == null) { str = ""; } int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size);'], ['', ''], ['if (str == null) { str = ""; }', 'if (str == null) { str = ""; }'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-48', 1, 1, 1, 1, ['} Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); } else if (lhs.getClass() != rhs.getClass()) { // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] this.setEquals(false);'], ['} Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); } } else if (lhs.getClass() != rhs.getClass()) { // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] this.setEquals(false);'], [''], ['if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { }'], 'a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java', 'b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java']
['Lang-49', 1, 1, 1, 1, ['* @return a new reduced fraction instance, or this if no simplification possible */ public Fraction reduce() { int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this;'], ['* @return a new reduced fraction instance, or this if no simplification possible */ public Fraction reduce() { if (numerator == 0) { return equals(ZERO) ? this : ZERO; } int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this;'], [''], ['if (numerator == 0) { return equals(ZERO) ? this : ZERO; }'], 'a/src/java/org/apache/commons/lang/math/Fraction.java', 'b/src/java/org/apache/commons/lang/math/Fraction.java']
['Lang-50', 2, 2, 2, 2, ['key = new Pair(key, timeZone); } if (locale != null) { key = new Pair(key, locale); } FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key); if (format == null) { if (locale == null) { locale = Locale.getDefault(); } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale); String pattern = formatter.toPattern();', 'if (timeZone != null) { key = new Pair(key, timeZone); } if (locale != null) { key = new Pair(key, locale); } FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key); if (format == null) { if (locale == null) { locale = Locale.getDefault(); } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);'], ['key = new Pair(key, timeZone); } if (locale == null) { locale = Locale.getDefault(); } key = new Pair(key, locale); FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key); if (format == null) { try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale); String pattern = formatter.toPattern();', 'if (timeZone != null) { key = new Pair(key, timeZone); } if (locale == null) { locale = Locale.getDefault(); } key = new Pair(key, locale); FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key); if (format == null) { try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);'], ['if (locale != null) { key = new Pair(key, locale); if (locale == null) { locale = Locale.getDefault(); }', 'if (locale != null) { key = new Pair(key, locale); if (locale == null) { locale = Locale.getDefault(); }'], ['if (locale == null) { locale = Locale.getDefault(); key = new Pair(key, locale);', 'if (locale == null) { locale = Locale.getDefault(); key = new Pair(key, locale);'], 'a/src/java/org/apache/commons/lang/time/FastDateFormat.java', 'b/src/java/org/apache/commons/lang/time/FastDateFormat.java']
['Lang-51', 1, 1, 1, 1, ["(str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0);"], ["(str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } return false; } case 4: { char ch = str.charAt(0);"], [''], ['return false;'], 'a/src/java/org/apache/commons/lang/BooleanUtils.java', 'b/src/java/org/apache/commons/lang/BooleanUtils.java']
['Lang-52', 1, 1, 1, 1, ["out.write('\\\\'); out.write('\\\\'); break; default : out.write(ch); break;"], ["out.write('\\\\'); out.write('\\\\'); break; case '/': out.write('\\\\'); out.write('/'); break; default : out.write(ch); break;"], [''], ["case '/': out.write('\\\\'); out.write('/'); break;"], 'a/src/java/org/apache/commons/lang/StringEscapeUtils.java', 'b/src/java/org/apache/commons/lang/StringEscapeUtils.java']
['Lang-53', 1, 1, 1, 1, ['int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; } } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } // truncate minutes'], ['int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; } if (field == Calendar.SECOND) { done = true; } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); } if (field == Calendar.MINUTE) { done = true; } // truncate minutes'], ['} }'], ['} }'], 'a/src/java/org/apache/commons/lang/time/DateUtils.java', 'b/src/java/org/apache/commons/lang/time/DateUtils.java']
['Lang-54', 1, 1, 1, 1, ['throw new IllegalArgumentException("Invalid locale format: " + str); } char ch3 = str.charAt(3); char ch4 = str.charAt(4); if (ch3 < \'A\' || ch3 > \'Z\' || ch4 < \'A\' || ch4 > \'Z\') { throw new IllegalArgumentException("Invalid locale format: " + str);'], ['throw new IllegalArgumentException("Invalid locale format: " + str); } char ch3 = str.charAt(3); if (ch3 == \'_\') { return new Locale(str.substring(0, 2), "", str.substring(4)); } char ch4 = str.charAt(4); if (ch3 < \'A\' || ch3 > \'Z\' || ch4 < \'A\' || ch4 > \'Z\') { throw new IllegalArgumentException("Invalid locale format: " + str);'], [''], ['if (ch3 == \'_\') { return new Locale(str.substring(0, 2), "", str.substring(4)); }'], 'a/src/java/org/apache/commons/lang/LocaleUtils.java', 'b/src/java/org/apache/commons/lang/LocaleUtils.java']
['Lang-55', 1, 1, 1, 1, ['if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException("Stopwatch is not running. "); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }'], ['if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException("Stopwatch is not running. "); } if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }'], [''], ['if(this.runningState == STATE_RUNNING) { }'], 'a/src/java/org/apache/commons/lang/time/StopWatch.java', 'b/src/java/org/apache/commons/lang/time/StopWatch.java']
['Lang-56', 2, 2, 2, 2, ['/** * The parsed rules. */ private Rule[] mRules; /** * The estimated maximum length. */ private int mMaxLengthEstimate; //----------------------------------------------------------------------- /**', ' // Serializing //----------------------------------------------------------------------- // Rules //-----------------------------------------------------------------------'], ['/** * The parsed rules. */ private transient Rule[] mRules; /** * The estimated maximum length. */ private transient int mMaxLengthEstimate; //----------------------------------------------------------------------- /**', ' // Serializing //----------------------------------------------------------------------- private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); init(); } // Rules //-----------------------------------------------------------------------'], ['private Rule[] mRules; private int mMaxLengthEstimate;', ''], ['private transient Rule[] mRules; private transient int mMaxLengthEstimate;', 'private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); init(); }'], 'a/src/java/org/apache/commons/lang/time/FastDateFormat.java', 'b/src/java/org/apache/commons/lang/time/FastDateFormat.java']
['Lang-57', 1, 1, 1, 1, ['* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); } //-----------------------------------------------------------------------'], ['* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { return availableLocaleList().contains(locale); } //-----------------------------------------------------------------------'], ['return cAvailableLocaleSet.contains(locale);'], ['return availableLocaleList().contains(locale);'], 'a/src/java/org/apache/commons/lang/LocaleUtils.java', 'b/src/java/org/apache/commons/lang/LocaleUtils.java']
['Lang-58', 1, 1, 1, 1, ["case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {"], ["case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {"], ["&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {"], ["&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {"], 'a/src/java/org/apache/commons/lang/math/NumberUtils.java', 'b/src/java/org/apache/commons/lang/math/NumberUtils.java']
['Lang-59', 1, 1, 1, 1, ['String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);'], ['String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);'], ['str.getChars(0, strLen, buffer, size);'], ['str.getChars(0, width, buffer, size);'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-60', 2, 2, 2, 2, ['*/ public boolean contains(char ch) { char[] thisBuf = buffer; for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; }', 'return -1; } char[] thisBuf = buffer; for (int i = startIndex; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return i; }'], ['*/ public boolean contains(char ch) { char[] thisBuf = buffer; for (int i = 0; i < this.size; i++) { if (thisBuf[i] == ch) { return true; }', 'return -1; } char[] thisBuf = buffer; for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; }'], ['for (int i = 0; i < thisBuf.length; i++) {', 'for (int i = startIndex; i < thisBuf.length; i++) {'], ['for (int i = 0; i < this.size; i++) {', 'for (int i = startIndex; i < size; i++) {'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-61', 1, 1, 1, 1, ['return -1; } char[] thisBuf = buffer; int len = thisBuf.length - strLen; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {'], ['return -1; } char[] thisBuf = buffer; int len = size - strLen + 1; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {'], ['int len = thisBuf.length - strLen;'], ['int len = size - strLen + 1;'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-62', 2, 2, 2, 2, ['} else { entityValue = Integer.parseInt(entityName.substring(1)); } } catch (NumberFormatException ex) { entityValue = -1; }', "case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } } catch (NumberFormatException e) { } } } else { //escaped value content is an entity name"], ['} else { entityValue = Integer.parseInt(entityName.substring(1)); } if (entityValue > 0xFFFF) { entityValue = -1; } } catch (NumberFormatException ex) { entityValue = -1; }', "case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); break; } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } if (entityValue > 0xFFFF) { entityValue = -1; } } catch (NumberFormatException e) { entityValue = -1; } } } else { //escaped value content is an entity name"], ['', ''], ['if (entityValue > 0xFFFF) { entityValue = -1; }', 'break; if (entityValue > 0xFFFF) { entityValue = -1; } entityValue = -1;'], 'a/src/java/org/apache/commons/lang/Entities.java', 'b/src/java/org/apache/commons/lang/Entities.java']
['Lang-63', 2, 2, 2, 2, ["days -= 1; } while (days < 0) { days += 31; //days += 31; // TODO: Need tests to show this is bad and the new code is good. // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days. // Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; } while (months < 0) { months += 12; years -= 1; } milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years); // This next block of code adds in values that // aren't requested. This allows the user to ask for the", '} return buffer.toString(); } static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } } static final Object y = "y"; static final Object M = "M";'], ["days -= 1; } while (days < 0) { end.add(Calendar.MONTH, -1); days += end.getActualMaximum(Calendar.DAY_OF_MONTH); //days += 31; // TODO: Need tests to show this is bad and the new code is good. // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days. // Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; end.add(Calendar.MONTH, 1); } while (months < 0) { months += 12; years -= 1; } // This next block of code adds in values that // aren't requested. This allows the user to ask for the", '} return buffer.toString(); } static final Object y = "y"; static final Object M = "M";'], ['days += 31; milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years);', 'static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }'], ['end.add(Calendar.MONTH, -1); days += end.getActualMaximum(Calendar.DAY_OF_MONTH); end.add(Calendar.MONTH, 1);', ''], 'a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java', 'b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java']
['Lang-64', 2, 2, 2, 2, ['* @throws NullPointerException if other is <code>null</code> */ public int compareTo(Object other) { return iValue - ((ValuedEnum) other).iValue; }', '* @param other the object to determine the value for * @return the value */ // ignore - should never happen // ignore - should never happen // ignore - should never happen /** * <p>Human readable description of this <code>Enum</code> item.</p>'], ['* @throws NullPointerException if other is <code>null</code> */ public int compareTo(Object other) { if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( "Different enum class \'" + ClassUtils.getShortClassName(other.getClass()) + "\'"); } return iValue - ((ValuedEnum) other).iValue; }', '* @param other the object to determine the value for * @return the value */ private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod("getValue", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { // ignore - should never happen } catch (IllegalAccessException e) { // ignore - should never happen } catch (InvocationTargetException e) { // ignore - should never happen } throw new IllegalStateException("This should not happen"); } /** * <p>Human readable description of this <code>Enum</code> item.</p>'], ['', ''], ['if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( "Different enum class \'" + ClassUtils.getShortClassName(other.getClass()) + "\'"); }', 'private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod("getValue", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { } catch (IllegalAccessException e) { } catch (InvocationTargetException e) { } throw new IllegalStateException("This should not happen"); }'], 'a/src/java/org/apache/commons/lang/enums/ValuedEnum.java', 'b/src/java/org/apache/commons/lang/enums/ValuedEnum.java']
['Lang-65', 3, 3, 3, 3, ['throw new ArithmeticException("Calendar value too large for accurate calculations"); } // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59', '// Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods. // truncate milliseconds // truncate seconds // truncate minutes // reset time // ----------------- Fix for LANG-59 ----------------------- END ---------------- boolean roundUp = false;', 'roundUp = offset > ((max - min) / 2); } //We need to remove this field val.set(fields[i][0], val.get(fields[i][0]) - offset); } throw new IllegalArgumentException("The field " + field + " is not supported");'], ['throw new ArithmeticException("Calendar value too large for accurate calculations"); } if (field == Calendar.MILLISECOND) { return; } // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59', '// Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods. Date date = val.getTime(); long time = date.getTime(); boolean done = false; // truncate milliseconds int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; } } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } // truncate minutes int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } // reset time if (date.getTime() != time) { date.setTime(time); val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ---------------- boolean roundUp = false;', 'roundUp = offset > ((max - min) / 2); } //We need to remove this field if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); } } throw new IllegalArgumentException("The field " + field + " is not supported");'], ['', '', ''], ['if (field == Calendar.MILLISECOND) { return; }', 'Date date = val.getTime(); long time = date.getTime(); boolean done = false; int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; } } int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } if (date.getTime() != time) { date.setTime(time); val.setTime(date); }', 'if (offset != 0) { }'], 'a/src/java/org/apache/commons/lang/time/DateUtils.java', 'b/src/java/org/apache/commons/lang/time/DateUtils.java']
['Compress-1', 1, 1, 1, 1, ['*/ public void close() throws IOException { if (!this.closed) { super.close(); this.closed = true; }'], ['*/ public void close() throws IOException { if (!this.closed) { this.finish(); super.close(); this.closed = true; }'], [''], ['this.finish();'], 'a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java']
['Compress-2', 6, 6, 6, 6, ['* If getNextEnxtry has been called, the entry metadata is stored in * currentEntry. */ /* * The offset where the current entry started. -1 if no entry has been * called */ public ArArchiveInputStream( final InputStream pInput ) { input = pInput;', '* if the entry could not be read */ public ArArchiveEntry getNextArEntry() throws IOException { // hit EOF before previous entry was complete // TODO: throw an exception instead? if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes();', '} } // hit eof if (input.available() == 0) { return null; } if (offset % 2 != 0) { read(); } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6];', '} } return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length) .trim())); }', 'closed = true; input.close(); } } public int read() throws IOException { final int ret = input.read(); offset += (ret > 0 ? 1 : 0); return ret; } public int read(byte[] b) throws IOException {', ' public int read(byte[] b, final int off, final int len) throws IOException { int toRead = len; final int ret = this.input.read(b, off, toRead); offset += (ret > 0 ? ret : 0); return ret;'], ['* If getNextEnxtry has been called, the entry metadata is stored in * currentEntry. */ private ArArchiveEntry currentEntry = null; /* * The offset where the current entry started. -1 if no entry has been * called */ private long entryOffset = -1; public ArArchiveInputStream( final InputStream pInput ) { input = pInput;', '* if the entry could not be read */ public ArArchiveEntry getNextArEntry() throws IOException { if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); while (offset < entryEnd) { int x = read(); if (x == -1) { // hit EOF before previous entry was complete // TODO: throw an exception instead? return null; } } currentEntry = null; } if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes();', '} } if (offset % 2 != 0) { if (read() < 0) { // hit eof return null; } } if (input.available() == 0) { return null; } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6];', '} } entryOffset = offset; currentEntry = new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length) .trim())); return currentEntry; }', 'closed = true; input.close(); } currentEntry = null; } public int read() throws IOException { byte[] single = new byte[1]; int num = read(single, 0, 1); return num == -1 ? -1 : single[0] & 0xff; } public int read(byte[] b) throws IOException {', ' public int read(byte[] b, final int off, final int len) throws IOException { int toRead = len; if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); if (len > 0 && entryEnd > offset) { toRead = (int) Math.min(len, entryEnd - offset); } else { return -1; } } final int ret = this.input.read(b, off, toRead); offset += (ret > 0 ? ret : 0); return ret;'], ['', '', 'if (offset % 2 != 0) { read(); }', 'return new ArArchiveEntry(new String(name).trim(),', 'final int ret = input.read(); offset += (ret > 0 ? 1 : 0); return ret;', ''], ['private ArArchiveEntry currentEntry = null; private long entryOffset = -1;', 'if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); while (offset < entryEnd) { int x = read(); if (x == -1) { return null; } } currentEntry = null; }', 'if (offset % 2 != 0) { if (read() < 0) { return null; } }', 'entryOffset = offset; currentEntry = new ArArchiveEntry(new String(name).trim(), return currentEntry;', 'currentEntry = null; byte[] single = new byte[1]; int num = read(single, 0, 1); return num == -1 ? -1 : single[0] & 0xff;', 'if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); if (len > 0 && entryEnd > offset) { toRead = (int) Math.min(len, entryEnd - offset); } else { return -1; } }'], 'a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java']
['Compress-3', 4, 4, 4, 4, ['private boolean closed = false; /* Indicates if putArchiveEntry has been called without closeArchiveEntry */ private final OutputStream out;', '* @throws IOException on error */ public void finish() throws IOException { writeEOFRecord(); writeEOFRecord(); }', 'currSize = entry.getSize(); } currName = entry.getName(); } /**', '+ "\' before the \'" + currSize + "\' bytes specified in the header were written"); } } /**'], ['private boolean closed = false; /* Indicates if putArchiveEntry has been called without closeArchiveEntry */ private boolean haveUnclosedEntry = false; private final OutputStream out;', '* @throws IOException on error */ public void finish() throws IOException { if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); }', 'currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; } /**', '+ "\' before the \'" + currSize + "\' bytes specified in the header were written"); } haveUnclosedEntry = false; } /**'], ['', '', '', ''], ['private boolean haveUnclosedEntry = false;', 'if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); }', 'haveUnclosedEntry = true;', 'haveUnclosedEntry = false;'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java']
['Compress-4', 4, 4, 4, 4, ['*/ public void close() throws IOException { if (!this.closed) { this.finish(); out.close(); this.closed = true; }', '*/ public void close() throws IOException { if (!closed) { finish(); buffer.close(); out.close(); closed = true;', '* @exception IOException if an I/O error occurs. */ public void close() throws IOException { finish(); if (raf != null) { raf.close(); }', 'results.addedFromChangeSet(change.getEntry().getName()); } } return results; }'], ['*/ public void close() throws IOException { if (!this.closed) { out.close(); this.closed = true; }', '*/ public void close() throws IOException { if (!closed) { buffer.close(); out.close(); closed = true;', '* @exception IOException if an I/O error occurs. */ public void close() throws IOException { if (raf != null) { raf.close(); }', 'results.addedFromChangeSet(change.getEntry().getName()); } } out.finish(); return results; }'], ['this.finish();', 'finish();', 'finish();', ''], ['', '', '', 'out.finish();'], 'a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java', 'b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java']
['Compress-5', 1, 1, 1, 1, ['} catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0 && inf.finished()) { return -1; } crc.update(buffer, start, read); return read;'], ['} catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0) { if (inf.finished()) { return -1; } else if (lengthOfLastRead == -1) { throw new IOException("Truncated ZIP file"); } } crc.update(buffer, start, read); return read;'], ['if (read == 0 && inf.finished()) { return -1;'], ['if (read == 0) { if (inf.finished()) { return -1; } else if (lengthOfLastRead == -1) { throw new IOException("Truncated ZIP file"); }'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-6', 2, 2, 2, 2, ['*/ public ZipArchiveEntry(String name) { super(name); } /**', 'return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; if (name == null) { if (other.name != null) { return false; } } else if (!name.equals(other.name)) { return false; } return true;'], ['*/ public ZipArchiveEntry(String name) { super(name); setName(name); } /**', 'return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } return true;'], ['', 'if (name == null) { if (other.name != null) { } else if (!name.equals(other.name)) {'], ['setName(name);', 'String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { } else if (!myName.equals(otherName)) {'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-7', 1, 1, 1, 1, ['int end = offset + length; for (int i = offset; i < end; ++i) { if (buffer[i] == 0) { break; } result.append((char) buffer[i]); } return result.toString();'], ['int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; } result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString();'], ['if (buffer[i] == 0) { result.append((char) buffer[i]);'], ['byte b = buffer[i]; if (b == 0) { // Trailing null result.append((char) (b & 0xFF)); // Allow for sign-extension'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-8', 1, 1, 1, 1, ["*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } // Skip leading spaces if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; } } // Must have trailing NUL or space // May have additional NUL or space stillPadding = false; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("], ['*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); } boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; } // Skip leading spaces while (start < end){ if (buffer[start] == \' \'){ start++; } else { break; } } // Must have trailing NUL or space byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } // May have additional NUL or space trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < \'0\' || currentByte > \'7\'){ throw new IllegalArgumentException('], ["boolean stillPadding = true; final byte currentByte = buffer[i]; if (currentByte == 0) { if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { } stillPadding = false;"], ['if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); } boolean allNUL = true; if (buffer[i] != 0){ allNUL = false; } if (allNUL) { return 0L; } while (start < end){ if (buffer[start] == \' \'){ start++; } else { } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start];'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-9', 2, 2, 2, 2, ['} /** * Ends the TAR archive without closing the underlying OutputStream.', 'numToWrite -= num; wOffset += num; } count(numToWrite); } /**'], ['} @Deprecated @Override public int getCount() { return (int) getBytesWritten(); } @Override public long getBytesWritten() { return ((CountingOutputStream) out).getBytesWritten(); } /** * Ends the TAR archive without closing the underlying OutputStream.', 'numToWrite -= num; wOffset += num; } } /**'], ['', 'count(numToWrite);'], ['@Deprecated @Override public int getCount() { return (int) getBytesWritten(); } @Override public long getBytesWritten() { return ((CountingOutputStream) out).getBytesWritten(); }', ''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java']
['Compress-10', 2, 2, 2, 2, ['// the hashcode - see COMPRESS-164 // Map needs to be reconstructed in order to keep central // directory order for (ZipArchiveEntry ze : entries.keySet()) { OffsetEntry offsetEntry = entries.get(ze); long offset = offsetEntry.headerOffset; archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); byte[] b = new byte[SHORT];', 'nameMap.put(ze.getName(), ze); } } } }'], ['// the hashcode - see COMPRESS-164 // Map needs to be reconstructed in order to keep central // directory order Map<ZipArchiveEntry, OffsetEntry> origMap = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries); entries.clear(); for (ZipArchiveEntry ze : origMap.keySet()) { OffsetEntry offsetEntry = origMap.get(ze); long offset = offsetEntry.headerOffset; archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); byte[] b = new byte[SHORT];', 'nameMap.put(ze.getName(), ze); } } entries.put(ze, offsetEntry); } }'], ['for (ZipArchiveEntry ze : entries.keySet()) { OffsetEntry offsetEntry = entries.get(ze);', ''], ['Map<ZipArchiveEntry, OffsetEntry> origMap = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries); entries.clear(); for (ZipArchiveEntry ze : origMap.keySet()) { OffsetEntry offsetEntry = origMap.get(ze);', 'entries.put(ze, offsetEntry);'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java']
['Compress-11', 2, 2, 2, 2, ['return new TarArchiveInputStream(in); } // COMPRESS-117 - improve auto-recognition try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); tais.getNextEntry();', '// autodetection, simply not a TAR // ignored } } catch (IOException e) { throw new ArchiveException("Could not use reset and mark operations.", e); }'], ['return new TarArchiveInputStream(in); } // COMPRESS-117 - improve auto-recognition if (signatureLength >= 512) { try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); tais.getNextEntry();', '// autodetection, simply not a TAR // ignored } } } catch (IOException e) { throw new ArchiveException("Could not use reset and mark operations.", e); }'], ['', ''], ['if (signatureLength >= 512) {', '}'], 'a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java', 'b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java']
['Compress-12', 1, 1, 1, 1, ['return null; } currEntry = new TarArchiveEntry(headerBuf); entryOffset = 0; entrySize = currEntry.getSize();'], ['return null; } try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize();'], ['currEntry = new TarArchiveEntry(headerBuf);'], ['try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-13', 1, 1, 1, 1, ['* @param name the name to use */ protected void setName(String name) { this.name = name; }'], ['* @param name the name to use */ protected void setName(String name) { if (name != null && getPlatform() == PLATFORM_FAT && name.indexOf("/") == -1) { name = name.replace(\'\\\\\', \'/\'); } this.name = name; }'], [''], ['if (name != null && getPlatform() == PLATFORM_FAT && name.indexOf("/") == -1) { name = name.replace(\'\\\\\', \'/\'); }'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-14', 1, 1, 1, 1, ['throw new IllegalArgumentException("Length "+length+" must be at least 2"); } boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; }'], ['throw new IllegalArgumentException("Length "+length+" must be at least 2"); } if (buffer[start] == 0) { return 0L; }'], ['boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) {'], ['if (buffer[start] == 0) {'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-15', 1, 1, 1, 1, ['String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes()'], ['String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { myComment = ""; } if (otherComment == null) { otherComment = ""; } return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes()'], ['if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false;'], ['myComment = ""; } if (otherComment == null) { otherComment = ""; && myComment.equals(otherComment)'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-16', 1, 1, 1, 1, ['try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); // COMPRESS-191 - verify the header checksum tais.getNextEntry(); return new TarArchiveInputStream(in); } catch (Exception e) { // NOPMD // can generate IllegalArgumentException as well // as IOException'], ['try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); // COMPRESS-191 - verify the header checksum if (tais.getNextTarEntry().isCheckSumOK()) { return new TarArchiveInputStream(in); } } catch (Exception e) { // NOPMD // can generate IllegalArgumentException as well // as IOException'], ['tais.getNextEntry();'], ['if (tais.getNextTarEntry().isCheckSumOK()) { }'], 'a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java', 'b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java']
['Compress-17', 1, 1, 1, 1, ["} // May have additional NULs or spaces trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--; } for ( ;start < end; start++) {"], ["} // May have additional NULs or spaces trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) {"], ["if (trailer == 0 || trailer == ' '){"], ["while (start < end - 1 && (trailer == 0 || trailer == ' ')) { trailer = buffer[end - 1];"], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-18', 1, 1, 1, 1, ['void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException { String name = "./PaxHeaders.X/" + stripTo7Bits(entryName); // TarEntry\'s constructor would think this is a directory // and not allow any data to be written if (name.length() >= TarConstants.NAMELEN) { name = name.substring(0, TarConstants.NAMELEN - 1); }'], ['void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException { String name = "./PaxHeaders.X/" + stripTo7Bits(entryName); while (name.endsWith("/")) { // TarEntry\'s constructor would think this is a directory // and not allow any data to be written name = name.substring(0, name.length() - 1); } if (name.length() >= TarConstants.NAMELEN) { name = name.substring(0, TarConstants.NAMELEN - 1); }'], [''], ['while (name.endsWith("/")) { name = name.substring(0, name.length() - 1); }'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java']
['Compress-19', 1, 1, 1, 1, ['+ (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); if (rawCentralDirectoryData.length != expectedLength) { throw new ZipException("central directory zip64 extended" + " information extra field\'s length" + " doesn\'t match central directory"'], ['+ (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); if (rawCentralDirectoryData.length < expectedLength) { throw new ZipException("central directory zip64 extended" + " information extra field\'s length" + " doesn\'t match central directory"'], ['if (rawCentralDirectoryData.length != expectedLength) {'], ['if (rawCentralDirectoryData.length < expectedLength) {'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java']
['Compress-20', 6, 6, 6, 6, [' ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (mode != 0){ ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16));', 'ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry name: "+name + " Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());', 'ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8));', 'ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+ name + " Occured at byte: " + getBytesRead()); }', 'ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord));', 'ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+name + "Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());'], [' ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0 ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16));', 'ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry name: "+name + " Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());', 'ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (CpioUtil.fileType(mode) != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8));', 'ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+ name + " Occured at byte: " + getBytesRead()); }', 'ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (CpioUtil.fileType(mode) != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord));', 'ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+name + "Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());'], ['if (mode != 0){', 'if (mode == 0 && !name.equals(CPIO_TRAILER)){', 'if (mode != 0) {', 'if (mode == 0 && !name.equals(CPIO_TRAILER)){', 'if (mode != 0){', 'if (mode == 0 && !name.equals(CPIO_TRAILER)){'], ['if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0', 'if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){', 'if (CpioUtil.fileType(mode) != 0) {', 'if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){', 'if (CpioUtil.fileType(mode) != 0){', 'if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){'], 'a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java']
['Compress-21', 1, 1, 1, 1, ['int shift = 7; for (int i = 0; i < length; i++) { cache |= ((bits.get(i) ? 1 : 0) << shift); --shift; if (shift == 0) { header.write(cache); shift = 7; cache = 0; } } if (length > 0 && shift > 0) { header.write(cache); } }'], ['int shift = 7; for (int i = 0; i < length; i++) { cache |= ((bits.get(i) ? 1 : 0) << shift); if (--shift < 0) { header.write(cache); shift = 7; cache = 0; } } if (shift != 7) { header.write(cache); } }'], ['--shift; if (shift == 0) { if (length > 0 && shift > 0) {'], ['if (--shift < 0) { if (shift != 7) {'], 'a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java', 'b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java']
['Compress-22', 7, 7, 7, 7, ['private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2;', ' init(true); initBlock(); setupBlock(); } @Override', '} private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException {', '} this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', 'this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', ' private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;', 'private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE;'], ['private InputStream in; private final boolean decompressConcatenated; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2;', ' init(true); initBlock(); } @Override', '} private int read0() throws IOException { switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: return setupBlock(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: return setupRandPartB(); case RAND_PART_C_STATE: return setupRandPartC(); case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: return setupNoRandPartB(); case NO_RAND_PART_C_STATE: return setupNoRandPartC(); default: throw new IllegalStateException(); } } private boolean init(boolean isFirstStream) throws IOException {', '} this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', 'this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', ' private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;', 'private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE;'], ['private int currentChar = -1;', 'setupBlock();', 'final int retChar = this.currentChar; throw new IllegalStateException(); setupRandPartB(); break; setupRandPartC(); break; setupNoRandPartB(); break; setupNoRandPartC(); break; return retChar;', 'this.currentChar = su_ch2Shadow;', 'this.currentChar = su_ch2Shadow;', 'this.currentChar = this.su_ch2;', 'this.currentChar = su_ch2Shadow;'], ['', '', 'return setupBlock(); return setupRandPartB(); return setupRandPartC(); return setupNoRandPartB(); return setupNoRandPartC();', '', '', '', ''], 'a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java', 'b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java']
['Compress-23', 1, 1, 1, 1, ['byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { dictSize |= (coder.properties[i + 1] << (8 * i)); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException("Dictionary larger than 4GiB maximum size");'], ['byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException("Dictionary larger than 4GiB maximum size");'], ['dictSize |= (coder.properties[i + 1] << (8 * i));'], ['dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);'], 'a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java', 'b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java']
['Compress-24', 1, 1, 1, 1, ["// space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) {"], ["// space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) {"], ["if (trailer == 0 || trailer == ' '){ } else { exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1];"], ["while (start < end && (trailer == 0 || trailer == ' ')) { trailer = buffer[end - 1]; } if (start == end) { exceptionMessage(buffer, offset, length, start, trailer));"], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-25', 1, 1, 1, 1, ["this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor; // haven't read anything so far } public ZipArchiveEntry getNextZipEntry() throws IOException {"], ["this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor; // haven't read anything so far buf.limit(0); } public ZipArchiveEntry getNextZipEntry() throws IOException {"], [''], ['buf.limit(0);'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-26', 1, 1, 1, 1, ['numToSkip -= skipped; } return available - numToSkip; }'], ['numToSkip -= skipped; } if (numToSkip > 0) { byte[] skipBuf = new byte[SKIP_BUF_SIZE]; while (numToSkip > 0) { int read = readFully(input, skipBuf, 0, (int) Math.min(numToSkip, SKIP_BUF_SIZE)); if (read < 1) { break; } numToSkip -= read; } } return available - numToSkip; }'], [''], ['if (numToSkip > 0) { byte[] skipBuf = new byte[SKIP_BUF_SIZE]; while (numToSkip > 0) { int read = readFully(input, skipBuf, 0, (int) Math.min(numToSkip, SKIP_BUF_SIZE)); if (read < 1) { break; } numToSkip -= read; } }'], 'a/src/main/java/org/apache/commons/compress/utils/IOUtils.java', 'b/src/main/java/org/apache/commons/compress/utils/IOUtils.java']
['Compress-27', 1, 1, 1, 1, ['end--; trailer = buffer[end - 1]; } if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) { final byte currentByte = buffer[start];'], ['end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start];'], ['if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); }'], [''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-28', 1, 1, 1, 1, ['numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; }'], ['numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; }'], ['count(totalRead);'], ['if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } count(totalRead);'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-29', 14, 14, 14, 14, ['} } if (JAR.equalsIgnoreCase(archiverName)) { return new JarArchiveOutputStream(out); } if (CPIO.equalsIgnoreCase(archiverName)) { if (entryEncoding != null) {', 'return new CpioArchiveInputStream(in); } } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return new ArjArchiveInputStream(in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Construct the cpio input stream with a blocksize of {@link', 'public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) { this.in = in; this.blockSize = blockSize; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Construct the cpio output stream with a specified format, a', '} this.entryFormat = format; this.blockSize = blockSize; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', "private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Constructor using the platform's default encoding for file", 'throws ArchiveException { this.raw = new TapeInputStream(is); this.hasHitEOF = false; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); try {', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Constructor for TarInputStream.', 'String encoding) { this.is = is; this.hasHitEOF = false; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.recordSize = recordSize; this.blockSize = blockSize;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII =', 'public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) { out = new CountingOutputStream(os); this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.assemLen = 0;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** Whether to look for and use Unicode extra fields. */ private final boolean useUnicodeExtraFields;', 'String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) { zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; in = new PushbackInputStream(inputStream, buf.capacity());'], ['} } if (JAR.equalsIgnoreCase(archiverName)) { if (entryEncoding != null) { return new JarArchiveOutputStream(out, entryEncoding); } else { return new JarArchiveOutputStream(out); } } if (CPIO.equalsIgnoreCase(archiverName)) { if (entryEncoding != null) {', 'return new CpioArchiveInputStream(in); } } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { if (entryEncoding != null) { return new ArjArchiveInputStream(in, entryEncoding); } else { return new ArjArchiveInputStream(in); } } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Construct the cpio input stream with a blocksize of {@link', 'public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) { this.in = in; this.blockSize = blockSize; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Construct the cpio output stream with a specified format, a', '} this.entryFormat = format; this.blockSize = blockSize; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', "private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Constructor using the platform's default encoding for file", 'throws ArchiveException { this.raw = new TapeInputStream(is); this.hasHitEOF = false; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); try {', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Constructor for TarInputStream.', 'String encoding) { this.is = is; this.hasHitEOF = false; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.recordSize = recordSize; this.blockSize = blockSize;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII =', 'public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) { out = new CountingOutputStream(os); this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.assemLen = 0;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** Whether to look for and use Unicode extra fields. */ private final boolean useUnicodeExtraFields;', 'String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) { this.encoding = encoding; zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; in = new PushbackInputStream(inputStream, buf.capacity());'], ['', '', '', '', '', '', '', '', '', '', '', '', '', ''], ['if (entryEncoding != null) { return new JarArchiveOutputStream(out, entryEncoding); } else { }', 'if (entryEncoding != null) { return new ArjArchiveInputStream(in, entryEncoding); } else { }', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-30', 1, 1, 1, 1, ['if (this.in == null) { throw new IOException("stream closed"); } final int hi = offs + len; int destOffs = offs;'], ['if (this.in == null) { throw new IOException("stream closed"); } if (len == 0) { return 0; } final int hi = offs + len; int destOffs = offs;'], [''], ['if (len == 0) { return 0; }'], 'a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java', 'b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java']
['Compress-31', 1, 1, 1, 1, [" for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte == 0) { break; } // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("], [" for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("], ['if (currentByte == 0) { break; }'], [''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-32', 1, 1, 1, 1, ['} else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){'], ['} else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Long.parseLong(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Long.parseLong(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){'], ['currEntry.setGroupId(Integer.parseInt(val)); currEntry.setUserId(Integer.parseInt(val));'], ['currEntry.setGroupId(Long.parseLong(val)); currEntry.setUserId(Long.parseLong(val));'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-33', 3, 3, 3, 3, ['return new ZCompressorInputStream(in); } if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {', '* @since 1.9 */ public class DeflateCompressorInputStream extends CompressorInputStream { private final InputStream in;', '* * @since 1.9 */ }'], ['return new ZCompressorInputStream(in); } if (DeflateCompressorInputStream.matches(signature, signatureLength)) { return new DeflateCompressorInputStream(in); } if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {', '* @since 1.9 */ public class DeflateCompressorInputStream extends CompressorInputStream { private static final int MAGIC_1 = 0x78; private static final int MAGIC_2a = 0x01; private static final int MAGIC_2b = 0x5e; private static final int MAGIC_2c = 0x9c; private static final int MAGIC_2d = 0xda; private final InputStream in;', '* * @since 1.9 */ public static boolean matches(byte[] signature, int length) { return length > 3 && signature[0] == MAGIC_1 && ( signature[1] == (byte) MAGIC_2a || signature[1] == (byte) MAGIC_2b || signature[1] == (byte) MAGIC_2c || signature[1] == (byte) MAGIC_2d); } }'], ['', '', ''], ['if (DeflateCompressorInputStream.matches(signature, signatureLength)) { return new DeflateCompressorInputStream(in); }', 'private static final int MAGIC_1 = 0x78; private static final int MAGIC_2a = 0x01; private static final int MAGIC_2b = 0x5e; private static final int MAGIC_2c = 0x9c; private static final int MAGIC_2d = 0xda;', 'public static boolean matches(byte[] signature, int length) { return length > 3 && signature[0] == MAGIC_1 && ( signature[1] == (byte) MAGIC_2a || signature[1] == (byte) MAGIC_2b || signature[1] == (byte) MAGIC_2c || signature[1] == (byte) MAGIC_2d); }'], 'a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java', 'b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java']
['Compress-34', 2, 2, 2, 2, ['*/ public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable { private static final ZipShort HEADER_ID = new ZipShort(0x7875); private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000); private static final long serialVersionUID = 1L;', '* @return a <code>ZipShort</code> for the length of the data of this extra field */ public ZipShort getCentralDirectoryLength() { return getLocalFileDataLength(); } /**'], ['*/ public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable { private static final ZipShort HEADER_ID = new ZipShort(0x7875); private static final ZipShort ZERO = new ZipShort(0); private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000); private static final long serialVersionUID = 1L;', '* @return a <code>ZipShort</code> for the length of the data of this extra field */ public ZipShort getCentralDirectoryLength() { return ZERO; } /**'], ['', 'return getLocalFileDataLength();'], ['private static final ZipShort ZERO = new ZipShort(0);', 'return ZERO;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java']
['Compress-35', 2, 2, 2, 2, ['* @since 1.5 */ public static boolean verifyCheckSum(byte[] header) { long storedSum = 0; long unsignedSum = 0; long signedSum = 0;', "for (int i = 0; i < header.length; i++) { byte b = header[i]; if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) { if ('0' <= b && b <= '7' && digits++ < 6) { storedSum = storedSum * 8 + b - '0'; } else if (digits > 0) { digits = 6; } b = ' '; } unsignedSum += 0xff & b;"], ['* @since 1.5 */ public static boolean verifyCheckSum(byte[] header) { long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN); long unsignedSum = 0; long signedSum = 0;', "for (int i = 0; i < header.length; i++) { byte b = header[i]; if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) { b = ' '; } unsignedSum += 0xff & b;"], ['long storedSum = 0;', "if ('0' <= b && b <= '7' && digits++ < 6) { storedSum = storedSum * 8 + b - '0'; } else if (digits > 0) { digits = 6; }"], ['long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);', ''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-36', 1, 1, 1, 1, ['} private InputStream getCurrentStream() throws IOException { if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }'], ['} private InputStream getCurrentStream() throws IOException { if (archive.files[currentEntryIndex].getSize() == 0) { return new ByteArrayInputStream(new byte[0]); } if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }'], [''], ['if (archive.files[currentEntryIndex].getSize() == 0) { return new ByteArrayInputStream(new byte[0]); }'], 'a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java', 'b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java']
['Compress-37', 1, 1, 1, 1, ["int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) {"], ["int read = 0; while((ch = i.read()) != -1) { read++; if (ch == '\\n') { // blank line in header break; } else if (ch == ' '){ // End of length string // Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) {"], ["if (ch == ' '){"], ["if (ch == '\\n') { // blank line in header break; } else if (ch == ' '){ // End of length string"], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-38', 1, 1, 1, 1, ['return true; } if (getName().endsWith("/")) { return true; }'], ['return true; } if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith("/")) { return true; }'], ['if (getName().endsWith("/")) {'], ['if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith("/")) {'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java']
['Compress-39', 2, 2, 2, 2, ['*/ public class ArchiveUtils { /** Private constructor to prevent instantiation of this utility class. */ private ArchiveUtils(){', '* @since Compress 1.12 */ public static String sanitize(String s) { final char[] chars = s.toCharArray(); final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) {'], ['*/ public class ArchiveUtils { private static final int MAX_SANITIZED_NAME_LENGTH = 255; /** Private constructor to prevent instantiation of this utility class. */ private ArchiveUtils(){', "* @since Compress 1.12 */ public static String sanitize(String s) { final char[] cs = s.toCharArray(); final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH); if (cs.length > MAX_SANITIZED_NAME_LENGTH) { for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) { chars[i] = '.'; } } final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) {"], ['', 'final char[] chars = s.toCharArray();'], ['private static final int MAX_SANITIZED_NAME_LENGTH = 255;', "final char[] cs = s.toCharArray(); final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH); if (cs.length > MAX_SANITIZED_NAME_LENGTH) { for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) { chars[i] = '.'; } }"], 'a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java', 'b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java']
['Compress-40', 3, 3, 3, 3, ['if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte;', '} bitsCachedSize += 8; } // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count;', 'bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; } }'], ['if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte;', '} bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count;', 'bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; } }'], ['while (bitsCachedSize < count) {', '', ''], ['while (bitsCachedSize < count && bitsCachedSize < 57) {', 'int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } if (overflowBits == 0) {', '} else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; }'], 'a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java', 'b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java']
['Compress-41', 1, 1, 1, 1, ['if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { hitCentralDirectory = true; skipRemainderOfArchive(); } if (!sig.equals(ZipLong.LFH_SIG)) { return null; } int off = WORD;'], ['if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { hitCentralDirectory = true; skipRemainderOfArchive(); return null; } if (!sig.equals(ZipLong.LFH_SIG)) { throw new ZipException(String.format("Unexpected record signature: 0X%X", sig.getValue())); } int off = WORD;'], ['return null;'], ['return null; throw new ZipException(String.format("Unexpected record signature: 0X%X", sig.getValue()));'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-42', 2, 2, 2, 2, ['* Bits used to indicate the filesystem object type. * @since 1.14 */ /** * Indicates symbolic links. */', '* @return true if the entry represents a unix symlink, false otherwise. */ public boolean isUnixSymlink() { return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG; } /**'], ['* Bits used to indicate the filesystem object type. * @since 1.14 */ int FILE_TYPE_FLAG = 0170000; /** * Indicates symbolic links. */', '* @return true if the entry represents a unix symlink, false otherwise. */ public boolean isUnixSymlink() { return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG; } /**'], ['', 'return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;'], ['int FILE_TYPE_FLAG = 0170000;', 'return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-43', 4, 4, 4, 4, [' final long localHeaderStart = streamCompressor.getTotalBytesWritten(); final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart); metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod()))); entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset writeCounted(localHeader); entry.dataStart = streamCompressor.getTotalBytesWritten();', ' //store method in local variable to prevent multiple method calls final int zipMethod = ze.getMethod(); final boolean dataDescriptor = usesDataDescriptor(zipMethod); putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);', '* @throws IOException on error */ protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException { if (ze.getMethod() != DEFLATED || channel != null) { return; } writeCounted(DD_SIG);', 'return versionNeededToExtractMethod(zipMethod); } private boolean usesDataDescriptor(final int zipMethod) { return zipMethod == DEFLATED && channel == null; } private int versionNeededToExtractMethod(int zipMethod) {'], [' final long localHeaderStart = streamCompressor.getTotalBytesWritten(); final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart); metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased))); entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset writeCounted(localHeader); entry.dataStart = streamCompressor.getTotalBytesWritten();', ' //store method in local variable to prevent multiple method calls final int zipMethod = ze.getMethod(); final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased); putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);', '* @throws IOException on error */ protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException { if (!usesDataDescriptor(ze.getMethod(), false)) { return; } writeCounted(DD_SIG);', 'return versionNeededToExtractMethod(zipMethod); } private boolean usesDataDescriptor(final int zipMethod, boolean phased) { return !phased && zipMethod == DEFLATED && channel == null; } private int versionNeededToExtractMethod(int zipMethod) {'], ['metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));', 'final boolean dataDescriptor = usesDataDescriptor(zipMethod);', 'if (ze.getMethod() != DEFLATED || channel != null) {', 'private boolean usesDataDescriptor(final int zipMethod) { return zipMethod == DEFLATED && channel == null;'], ['metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));', 'final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);', 'if (!usesDataDescriptor(ze.getMethod(), false)) {', 'private boolean usesDataDescriptor(final int zipMethod, boolean phased) { return !phased && zipMethod == DEFLATED && channel == null;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java']
['Compress-44', 1, 1, 1, 1, [' public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) { this.checksum = checksum; this.in = in;'], [' public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) { if ( checksum == null ){ throw new NullPointerException("Parameter checksum must not be null"); } if ( in == null ){ throw new NullPointerException("Parameter in must not be null"); } this.checksum = checksum; this.in = in;'], [''], ['if ( checksum == null ){ throw new NullPointerException("Parameter checksum must not be null"); } if ( in == null ){ throw new NullPointerException("Parameter in must not be null"); }'], 'a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java', 'b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java']
['Compress-45', 1, 1, 1, 1, [' if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length;'], [' if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } else { formatBigIntegerBinary(value, buf, offset, length, negative); } buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length;'], ['formatBigIntegerBinary(value, buf, offset, length, negative);'], ['} else { formatBigIntegerBinary(value, buf, offset, length, negative);'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-46', 1, 1, 1, 1, ['} private static ZipLong unixTimeToZipLong(long l) { final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { throw new IllegalArgumentException("X5455 timestamps must fit in a signed 32 bit integer: " + l); } return new ZipLong(l);'], ['} private static ZipLong unixTimeToZipLong(long l) { if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw new IllegalArgumentException("X5455 timestamps must fit in a signed 32 bit integer: " + l); } return new ZipLong(l);'], ['final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) {'], ['if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java']
['Compress-47', 3, 3, 3, 3, ['if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze); } return false; }', 'throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry); } int read; if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {', '* Whether the compressed size for the entry is either known or * not required by the compression method being used. */ /** * Caches a stored entry that uses the data descriptor.'], ['if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze); } return false; }', 'throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry); } if (!supportsCompressedSizeFor(current.entry)) { throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry); } int read; if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {', '* Whether the compressed size for the entry is either known or * not required by the compression method being used. */ private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) { return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED); } /** * Caches a stored entry that uses the data descriptor.'], ['&& supportsDataDescriptorFor(ze);', '', ''], ['&& supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze);', 'if (!supportsCompressedSizeFor(current.entry)) { throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry); }', 'private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) { return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED); }'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Gson-1', 2, 2, 2, 2, ['int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); return actualTypeArguments[indexOfActualTypeArgument]; } throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType', '} } // Evaluate type on this type private static Type[] extractRealTypes( Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {'], ['int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); return actualTypeArguments[indexOfActualTypeArgument]; } else if (typeToEvaluate instanceof TypeVariable<?>) { Type theSearchedType = null; do { theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); if (theSearchedType != null) { return theSearchedType; } } throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType', '} } private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { Class<?> rawParentType = null; if (parentType instanceof Class<?>) { rawParentType = (Class<?>) parentType; } else if (parentType instanceof ParameterizedType) { ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; rawParentType = (Class<?>) parentTypeAsPT.getRawType(); } else { return null; } Type superClass = rawParentType.getGenericSuperclass(); if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { // Evaluate type on this type TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); Type[] actualTypeArguments = null; if (parentType instanceof Class<?>) { actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); } else if (parentType instanceof ParameterizedType) { actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); } else { return null; } return actualTypeArguments[indexOfActualTypeArgument]; } Type searchedType = null; if (superClass != null) { searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); } return searchedType; } private static Type[] extractRealTypes( Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {'], ['', ''], ['} else if (typeToEvaluate instanceof TypeVariable<?>) { Type theSearchedType = null; do { theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); if (theSearchedType != null) { return theSearchedType; }', 'private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { Class<?> rawParentType = null; if (parentType instanceof Class<?>) { rawParentType = (Class<?>) parentType; } else if (parentType instanceof ParameterizedType) { ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; rawParentType = (Class<?>) parentTypeAsPT.getRawType(); } else { return null; } Type superClass = rawParentType.getGenericSuperclass(); if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); Type[] actualTypeArguments = null; if (parentType instanceof Class<?>) { actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); } else if (parentType instanceof ParameterizedType) { actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); } else { return null; } return actualTypeArguments[indexOfActualTypeArgument]; } Type searchedType = null; if (superClass != null) { searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); } return searchedType; }'], 'a/gson/src/main/java/com/google/gson/TypeInfoFactory.java', 'b/gson/src/main/java/com/google/gson/TypeInfoFactory.java']
['Gson-2', 1, 1, 1, 1, ['if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) typeAdapter; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";'], ['if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } }; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";'], ['return (TypeAdapter<T2>) typeAdapter;'], ['return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } };'], 'a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java']
['Gson-3', 2, 2, 2, 2, ['import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; import com.google.gson.InstanceCreator; import com.google.gson.JsonIOException;', '} if (Map.class.isAssignableFrom(rawType)) { if (SortedMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new TreeMap<Object, Object>();'], ['import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.ConcurrentNavigableMap; import java.util.concurrent.ConcurrentSkipListMap; import com.google.gson.InstanceCreator; import com.google.gson.JsonIOException;', '} if (Map.class.isAssignableFrom(rawType)) { if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentSkipListMap<Object, Object>(); } }; } else if (ConcurrentMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentHashMap<Object, Object>(); } }; } else if (SortedMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new TreeMap<Object, Object>();'], ['', 'if (SortedMap.class.isAssignableFrom(rawType)) {'], ['import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.ConcurrentNavigableMap; import java.util.concurrent.ConcurrentSkipListMap;', 'if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentSkipListMap<Object, Object>(); } }; } else if (ConcurrentMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentHashMap<Object, Object>(); } }; } else if (SortedMap.class.isAssignableFrom(rawType)) {'], 'a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java', 'b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java']
['Gson-4', 12, 12, 12, 12, ['checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case \'"\': if (stackSize == 1) { checkLenient(); } return peeked = PEEKED_DOUBLE_QUOTED; case \'[\': return peeked = PEEKED_BEGIN_ARRAY;', "default: pos--; // Don't consume the first character in a literal value. } if (stackSize == 1) { checkLenient(); } int result = peekKeyword(); if (result != PEEKED_NONE) {", '* bracket. */ private JsonWriter open(int empty, String openBracket) throws IOException { beforeValue(true); push(empty); out.write(openBracket); return this;', 'return nullValue(); } writeDeferredName(); beforeValue(false); string(value); return this; }', 'return nullValue(); } writeDeferredName(); beforeValue(false); out.append(value); return this; }', 'return this; // skip the name and the value } } beforeValue(false); out.write("null"); return this; }', '*/ public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(false); out.write(value ? "true" : "false"); return this; }', 'throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } writeDeferredName(); beforeValue(false); out.append(Double.toString(value)); return this; }', '*/ public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(false); out.write(Long.toString(value)); return this; }', '&& (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(false); out.append(string); return this; }', '* closing bracket or another element. */ @SuppressWarnings("fallthrough") private void beforeValue(boolean root) throws IOException { switch (peek()) { case NONEMPTY_DOCUMENT: if (!lenient) {', '} // fall-through case EMPTY_DOCUMENT: // first in document if (!lenient && !root) { throw new IllegalStateException( "JSON must start with an array or an object."); } replaceTop(NONEMPTY_DOCUMENT); break;'], ['checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case \'"\': return peeked = PEEKED_DOUBLE_QUOTED; case \'[\': return peeked = PEEKED_BEGIN_ARRAY;', "default: pos--; // Don't consume the first character in a literal value. } int result = peekKeyword(); if (result != PEEKED_NONE) {", '* bracket. */ private JsonWriter open(int empty, String openBracket) throws IOException { beforeValue(); push(empty); out.write(openBracket); return this;', 'return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; }', 'return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; }', 'return this; // skip the name and the value } } beforeValue(); out.write("null"); return this; }', '*/ public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; }', 'throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; }', '*/ public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; }', '&& (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(); out.append(string); return this; }', '* closing bracket or another element. */ @SuppressWarnings("fallthrough") private void beforeValue() throws IOException { switch (peek()) { case NONEMPTY_DOCUMENT: if (!lenient) {', '} // fall-through case EMPTY_DOCUMENT: // first in document replaceTop(NONEMPTY_DOCUMENT); break;'], ['if (stackSize == 1) { checkLenient(); }', 'if (stackSize == 1) { checkLenient(); }', 'beforeValue(true);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'private void beforeValue(boolean root) throws IOException {', 'if (!lenient && !root) { throw new IllegalStateException( "JSON must start with an array or an object."); }'], ['', '', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'private void beforeValue() throws IOException {', ''], 'a/gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'b/gson/src/main/java/com/google/gson/stream/JsonWriter.java']
['Gson-5', 1, 1, 1, 1, ['String timezoneOffset = date.substring(offset); // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00 offset += timezoneOffset.length(); // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"'], ['String timezoneOffset = date.substring(offset); // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00 timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00"; offset += timezoneOffset.length(); // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"'], [''], ['timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00";'], 'a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java', 'b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java']
['Gson-6', 1, 1, 1, 1, ['throw new IllegalArgumentException( "@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."); } typeAdapter = typeAdapter.nullSafe(); return typeAdapter; } }'], ['throw new IllegalArgumentException( "@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."); } if (typeAdapter != null) { typeAdapter = typeAdapter.nullSafe(); } return typeAdapter; } }'], [''], ['if (typeAdapter != null) { }'], 'a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java', 'b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java']
['Gson-7', 2, 2, 2, 2, ['if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE;', 'if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE;'], ['if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE;', 'if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE;'], ['} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {', '} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {'], ['} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { }', '} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { }'], 'a/gson/src/main/java/com/google/gson/stream/JsonReader.java', 'b/gson/src/main/java/com/google/gson/stream/JsonReader.java']
['Gson-8', 5, 5, 5, 5, ['import java.io.ObjectStreamClass; import java.lang.reflect.Field; import java.lang.reflect.Method; /** * Do sneaky things to allocate objects without invoking their constructors.', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { return (T) allocateInstance.invoke(unsafe, c); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { return (T) newInstance.invoke(null, c, constructorId); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { return (T) newInstance.invoke(null, c, Object.class); } };', '* throw an {@link java.lang.UnsupportedOperationException} * @param c instance of the class to be checked */ }'], ['import java.io.ObjectStreamClass; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; /** * Do sneaky things to allocate objects without invoking their constructors.', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } };', '* throw an {@link java.lang.UnsupportedOperationException} * @param c instance of the class to be checked */ private static void assertInstantiable(Class<?> c) { int modifiers = c.getModifiers(); if (Modifier.isInterface(modifiers)) { throw new UnsupportedOperationException("Interface can\'t be instantiated! Interface name: " + c.getName()); } if (Modifier.isAbstract(modifiers)) { throw new UnsupportedOperationException("Abstract class can\'t be instantiated! Class name: " + c.getName()); } } }'], ['', '', '', '', ''], ['import java.lang.reflect.Modifier;', 'assertInstantiable(c);', 'assertInstantiable(c);', 'assertInstantiable(c);', 'private static void assertInstantiable(Class<?> c) { int modifiers = c.getModifiers(); if (Modifier.isInterface(modifiers)) { throw new UnsupportedOperationException("Interface can\'t be instantiated! Interface name: " + c.getName()); } if (Modifier.isAbstract(modifiers)) { throw new UnsupportedOperationException("Abstract class can\'t be instantiated! Class name: " + c.getName()); } }'], 'a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java', 'b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java']
['Gson-9', 3, 3, 3, 3, ['return this; } @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {', '} @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } };', '* * @return this writer. */ /** * Encodes {@code value}.'], ['return this; } @Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {', '} @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } };', '* * @return this writer. */ public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } /** * Encodes {@code value}.'], ['', 'if (value == null) { out.nullValue(); return; }', ''], ['@Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; }', '', 'public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; }'], 'a/gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'b/gson/src/main/java/com/google/gson/stream/JsonWriter.java']
['Gson-10', 1, 1, 1, 1, ['@Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value)'], ['@Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value)'], ['TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());'], ['TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());'], 'a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java', 'b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java']
['Gson-11', 1, 1, 1, 1, ['in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException("Expecting number, got: " + jsonToken);'], ['in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException("Expecting number, got: " + jsonToken);'], [''], ['case STRING:'], 'a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java']
['Gson-12', 1, 1, 1, 1, ['pathNames[stackSize - 2] = "null"; } else { popStack(); pathNames[stackSize - 1] = "null"; } pathIndices[stackSize - 1]++; } @Override public String toString() {'], ['pathNames[stackSize - 2] = "null"; } else { popStack(); if (stackSize > 0) { pathNames[stackSize - 1] = "null"; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; } } @Override public String toString() {'], [''], ['if (stackSize > 0) { } if (stackSize > 0) { }'], 'a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java', 'b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java']
['Gson-13', 1, 1, 1, 1, ["} // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER. if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG;"], ["} // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER. if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG;"], ['if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {'], ['if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {'], 'a/gson/src/main/java/com/google/gson/stream/JsonReader.java', 'b/gson/src/main/java/com/google/gson/stream/JsonReader.java']
['Gson-14', 2, 2, 2, 2, ['*/ public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; upperBounds = new Type[] { bound }; return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }', '*/ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; lowerBounds = new Type[] { bound }; return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }'], ['*/ public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }', '*/ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }'], ['', ''], ['if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { }', 'if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { }'], 'a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java']
['Gson-15', 1, 1, 1, 1, ['*/ public JsonWriter value(double value) throws IOException { writeDeferredName(); if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue();'], ['*/ public JsonWriter value(double value) throws IOException { writeDeferredName(); if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue();'], ['if (Double.isNaN(value) || Double.isInfinite(value)) {'], ['if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {'], 'a/gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'b/gson/src/main/java/com/google/gson/stream/JsonWriter.java']
['Gson-16', 1, 1, 1, 1, ['while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve;'], ['while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; if (visitedTypeVariables.contains(typeVariable)) { // cannot reduce due to infinite recursion return toResolve; } else { visitedTypeVariables.add(typeVariable); } toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve;'], [''], ['if (visitedTypeVariables.contains(typeVariable)) { return toResolve; } else { visitedTypeVariables.add(typeVariable); }'], 'a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java']
['Gson-17', 1, 1, 1, 1, [' @Override public Date read(JsonReader in) throws IOException { if (in.peek() != JsonToken.STRING) { throw new JsonParseException("The date should be a string value"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) {'], [' @Override public Date read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) {'], ['if (in.peek() != JsonToken.STRING) { throw new JsonParseException("The date should be a string value");'], ['if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;'], 'a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java']
['Gson-18', 1, 1, 1, 1, ['* @param supertype a superclass of, or interface implemented by, this. */ static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead checkArgument(supertype.isAssignableFrom(contextRawType)); return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));'], ['* @param supertype a superclass of, or interface implemented by, this. */ static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) { if (context instanceof WildcardType) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead context = ((WildcardType)context).getUpperBounds()[0]; } checkArgument(supertype.isAssignableFrom(contextRawType)); return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));'], [''], ['if (context instanceof WildcardType) { context = ((WildcardType)context).getUpperBounds()[0]; }'], 'a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java']
['Mockito-1', 1, 1, 1, 1, ['public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; throw new UnsupportedOperationException(); } else { for (int position = 0; position < matchers.size(); position++) {'], ['public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } } } else { for (int position = 0; position < matchers.size(); position++) {'], ['throw new UnsupportedOperationException();'], ['for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } }'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-2', 3, 3, 3, 3, ['package org.mockito.internal.util; public class Timer {', 'private long startTime = -1; public Timer(long durationMillis) { this.durationMillis = durationMillis; }', 'startTime = System.currentTimeMillis(); } }'], ['package org.mockito.internal.util; import org.mockito.exceptions.Reporter; public class Timer {', 'private long startTime = -1; public Timer(long durationMillis) { validateInput(durationMillis); this.durationMillis = durationMillis; }', 'startTime = System.currentTimeMillis(); } private void validateInput(long durationMillis) { if (durationMillis < 0) { new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis); } } }'], ['', '', ''], ['import org.mockito.exceptions.Reporter;', 'validateInput(durationMillis);', 'private void validateInput(long durationMillis) { if (durationMillis < 0) { new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis); } }'], 'a/src/org/mockito/internal/util/Timer.java', 'b/src/org/mockito/internal/util/Timer.java']
['Mockito-3', 2, 2, 2, 2, ['((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } } } else {', '} } public static List<InvocationMatcher> createFrom(List<Invocation> invocations) { LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();'], ['((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (Matcher m : uniqueMatcherSet(indexOfVararg)) { if (m instanceof CapturesArguments) { Object rawArgument = invocation.getRawArguments()[indexOfVararg]; for (int i = 0; i < Array.getLength(rawArgument); i++) { ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i)); } } } } else {', '} } private Set<Matcher> uniqueMatcherSet(int indexOfVararg) { HashSet<Matcher> set = new HashSet<Matcher>(); for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher matcher = matchers.get(position); if(matcher instanceof MatcherDecorator) { set.add(((MatcherDecorator) matcher).getActualMatcher()); } else { set.add(matcher); } } return set; } public static List<InvocationMatcher> createFrom(List<Invocation> invocations) { LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();'], ['for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);', ''], ['for (Matcher m : uniqueMatcherSet(indexOfVararg)) { Object rawArgument = invocation.getRawArguments()[indexOfVararg]; for (int i = 0; i < Array.getLength(rawArgument); i++) { ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i)); }', 'private Set<Matcher> uniqueMatcherSet(int indexOfVararg) { HashSet<Matcher> set = new HashSet<Matcher>(); for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher matcher = matchers.get(position); if(matcher instanceof MatcherDecorator) { set.add(((MatcherDecorator) matcher).getActualMatcher()); } else { set.add(matcher); } } return set; }'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-4', 3, 3, 3, 3, ['throw new NoInteractionsWanted(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + undesired.getMock() + "\':", undesired.getLocation(), scenario ));', 'throw new VerificationInOrderFailure(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + undesired.getMock() + "\':", undesired.getLocation() )); }', '} private String exceptionCauseMessageIfAvailable(Exception details) { return details.getCause().getMessage(); }'], ['throw new NoInteractionsWanted(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':", undesired.getLocation(), scenario ));', 'throw new VerificationInOrderFailure(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':", undesired.getLocation() )); }', '} private String exceptionCauseMessageIfAvailable(Exception details) { if (details.getCause() == null) { return details.getMessage(); } return details.getCause().getMessage(); }'], ['"But found this interaction on mock \'" + undesired.getMock() + "\':",', '"But found this interaction on mock \'" + undesired.getMock() + "\':",', ''], ['"But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':",', '"But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':",', 'if (details.getCause() == null) { return details.getMessage(); }'], 'a/src/org/mockito/exceptions/Reporter.java', 'b/src/org/mockito/exceptions/Reporter.java']
['Mockito-5', 1, 1, 1, 1, ['} catch (MockitoAssertionError e) { error = handleVerifyException(e); } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { error = handleVerifyException(e); } }'], ['} catch (MockitoAssertionError e) { error = handleVerifyException(e); } catch (AssertionError e) { error = handleVerifyException(e); } }'], ['catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {'], ['catch (AssertionError e) {'], 'a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java', 'b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java']
['Mockito-6', 20, 20, 20, 20, ['* @return <code>false</code>. */ public static boolean anyBoolean() { return reportMatcher(Any.ANY).returnFalse(); } /**', '* @return <code>0</code>. */ public static byte anyByte() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static char anyChar() { return reportMatcher(Any.ANY).returnChar(); } /**', '* @return <code>0</code>. */ public static int anyInt() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static long anyLong() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static float anyFloat() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static double anyDouble() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static short anyShort() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>null</code>. */ public static <T> T anyObject() { return (T) reportMatcher(Any.ANY).returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T any(Class<T> clazz) { return (T) reportMatcher(Any.ANY).returnFor(clazz); } /**', '* @return <code>null</code>. */ public static <T> T any() { return (T) anyObject(); } /**', '* @return empty String ("") */ public static String anyString() { return reportMatcher(Any.ANY).returnString(); } /**', '* @return empty List. */ public static List anyList() { return reportMatcher(Any.ANY).returnList(); } /**', '* @return empty List. */ public static <T> List<T> anyListOf(Class<T> clazz) { return (List) reportMatcher(Any.ANY).returnList(); } /**', '* @return empty Set */ public static Set anySet() { return reportMatcher(Any.ANY).returnSet(); } /**', '* @return empty Set */ public static <T> Set<T> anySetOf(Class<T> clazz) { return (Set) reportMatcher(Any.ANY).returnSet(); } /**', '* @return empty Map. */ public static Map anyMap() { return reportMatcher(Any.ANY).returnMap(); } /**', '* @return empty Map. */ public static <K, V> Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) { return reportMatcher(Any.ANY).returnMap(); } /**', '* @return empty Collection. */ public static Collection anyCollection() { return reportMatcher(Any.ANY).returnList(); } /**', '* @return empty Collection. */ public static <T> Collection<T> anyCollectionOf(Class<T> clazz) { return (Collection) reportMatcher(Any.ANY).returnList(); } /**'], ['* @return <code>false</code>. */ public static boolean anyBoolean() { return reportMatcher(new InstanceOf(Boolean.class)).returnFalse(); } /**', '* @return <code>0</code>. */ public static byte anyByte() { return reportMatcher(new InstanceOf(Byte.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static char anyChar() { return reportMatcher(new InstanceOf(Character.class)).returnChar(); } /**', '* @return <code>0</code>. */ public static int anyInt() { return reportMatcher(new InstanceOf(Integer.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static long anyLong() { return reportMatcher(new InstanceOf(Long.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static float anyFloat() { return reportMatcher(new InstanceOf(Float.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static double anyDouble() { return reportMatcher(new InstanceOf(Double.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static short anyShort() { return reportMatcher(new InstanceOf(Short.class)).returnZero(); } /**', '* @return <code>null</code>. */ public static <T> T anyObject() { return (T) reportMatcher(new InstanceOf(Object.class)).returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T any(Class<T> clazz) { return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz); } /**', '* @return <code>null</code>. */ public static <T> T any() { return (T) reportMatcher(Any.ANY).returnNull(); } /**', '* @return empty String ("") */ public static String anyString() { return reportMatcher(new InstanceOf(String.class)).returnString(); } /**', '* @return empty List. */ public static List anyList() { return reportMatcher(new InstanceOf(List.class)).returnList(); } /**', '* @return empty List. */ public static <T> List<T> anyListOf(Class<T> clazz) { return anyList(); } /**', '* @return empty Set */ public static Set anySet() { return reportMatcher(new InstanceOf(Set.class)).returnSet(); } /**', '* @return empty Set */ public static <T> Set<T> anySetOf(Class<T> clazz) { return anySet(); } /**', '* @return empty Map. */ public static Map anyMap() { return reportMatcher(new InstanceOf(Map.class)).returnMap(); } /**', '* @return empty Map. */ public static <K, V> Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) { return anyMap(); } /**', '* @return empty Collection. */ public static Collection anyCollection() { return reportMatcher(new InstanceOf(Collection.class)).returnList(); } /**', '* @return empty Collection. */ public static <T> Collection<T> anyCollectionOf(Class<T> clazz) { return anyCollection(); } /**'], ['return reportMatcher(Any.ANY).returnFalse();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnChar();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return (T) reportMatcher(Any.ANY).returnNull();', 'return (T) reportMatcher(Any.ANY).returnFor(clazz);', 'return (T) anyObject();', 'return reportMatcher(Any.ANY).returnString();', 'return reportMatcher(Any.ANY).returnList();', 'return (List) reportMatcher(Any.ANY).returnList();', 'return reportMatcher(Any.ANY).returnSet();', 'return (Set) reportMatcher(Any.ANY).returnSet();', 'return reportMatcher(Any.ANY).returnMap();', 'return reportMatcher(Any.ANY).returnMap();', 'return reportMatcher(Any.ANY).returnList();', 'return (Collection) reportMatcher(Any.ANY).returnList();'], ['return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();', 'return reportMatcher(new InstanceOf(Byte.class)).returnZero();', 'return reportMatcher(new InstanceOf(Character.class)).returnChar();', 'return reportMatcher(new InstanceOf(Integer.class)).returnZero();', 'return reportMatcher(new InstanceOf(Long.class)).returnZero();', 'return reportMatcher(new InstanceOf(Float.class)).returnZero();', 'return reportMatcher(new InstanceOf(Double.class)).returnZero();', 'return reportMatcher(new InstanceOf(Short.class)).returnZero();', 'return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();', 'return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);', 'return (T) reportMatcher(Any.ANY).returnNull();', 'return reportMatcher(new InstanceOf(String.class)).returnString();', 'return reportMatcher(new InstanceOf(List.class)).returnList();', 'return anyList();', 'return reportMatcher(new InstanceOf(Set.class)).returnSet();', 'return anySet();', 'return reportMatcher(new InstanceOf(Map.class)).returnMap();', 'return anyMap();', 'return reportMatcher(new InstanceOf(Collection.class)).returnList();', 'return anyCollection();'], 'a/src/org/mockito/Matchers.java', 'b/src/org/mockito/Matchers.java']
['Mockito-7', 1, 1, 1, 1, ['for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); }'], ['for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeParametersOn(new TypeVariable[] { typeVariable }); registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); }'], [''], ['registerTypeParametersOn(new TypeVariable[] { typeVariable });'], 'a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java', 'b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java']
['Mockito-8', 1, 1, 1, 1, [' if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } // logger.log("For \'" + parameterizedType + "\' found type variable : { \'" + typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "\' : \'" + actualTypeArgument + "(" + System.identityHashCode(typeParameter) + ")" + "\' }");'], [' if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); } else if (typeParameter != actualTypeArgument) { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } // logger.log("For \'" + parameterizedType + "\' found type variable : { \'" + typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "\' : \'" + actualTypeArgument + "(" + System.identityHashCode(typeParameter) + ")" + "\' }");'], ['} else {'], ['} else if (typeParameter != actualTypeArgument) {'], 'a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java', 'b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java']
['Mockito-9', 2, 2, 2, 2, ['package org.mockito.internal.stubbing.answers; import java.io.Serializable; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;', 'private static final long serialVersionUID = 9057165148930624087L; public Object answer(InvocationOnMock invocation) throws Throwable { return invocation.callRealMethod(); } } No newline at end of file'], ['package org.mockito.internal.stubbing.answers; import java.io.Serializable; import java.lang.reflect.Modifier; import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;', 'private static final long serialVersionUID = 9057165148930624087L; public Object answer(InvocationOnMock invocation) throws Throwable { if (Modifier.isAbstract(invocation.getMethod().getModifiers())) { return new GloballyConfiguredAnswer().answer(invocation); } return invocation.callRealMethod(); } } No newline at end of file'], ['', ''], ['import java.lang.reflect.Modifier; import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;', 'if (Modifier.isAbstract(invocation.getMethod().getModifiers())) { return new GloballyConfiguredAnswer().answer(invocation); }'], 'a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java', 'b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java']
['Mockito-10', 3, 3, 3, 3, ['import org.mockito.internal.util.MockUtil; import org.mockito.internal.util.reflection.GenericMetadataSupport; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import java.io.IOException;', ' // record deep stub answer return recordDeepStubAnswer( newDeepStubMock(returnTypeGenericMetadata), container ); }', '* @param parentMock The parent of the current deep stub mock. * @return The mock */ private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { return mockitoCore().mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return mockSettings.serializable() .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);'], ['import org.mockito.internal.util.MockUtil; import org.mockito.internal.util.reflection.GenericMetadataSupport; import org.mockito.invocation.InvocationOnMock; import org.mockito.mock.MockCreationSettings; import org.mockito.stubbing.Answer; import java.io.IOException;', ' // record deep stub answer return recordDeepStubAnswer( newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()), container ); }', '* @param parentMock The parent of the current deep stub mock. * @return The mock */ private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) { MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock); return mockitoCore().mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata, parentMockSettings) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) { MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return propagateSerializationSettings(mockSettings, parentMockSettings) .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) { return mockSettings.serializable(parentMockSettings.getSerializableMode()); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);'], ['', 'newDeepStubMock(returnTypeGenericMetadata),', 'private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { withSettingsUsing(returnTypeGenericMetadata) private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { return mockSettings.serializable()'], ['import org.mockito.mock.MockCreationSettings;', 'newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),', 'private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) { MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock); withSettingsUsing(returnTypeGenericMetadata, parentMockSettings) private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) { return propagateSerializationSettings(mockSettings, parentMockSettings) private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) { return mockSettings.serializable(parentMockSettings.getSerializableMode()); }'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java']
['Mockito-11', 1, 1, 1, 1, ['*/ @Override public boolean equals(Object o) { return method.equals(o); } @Override public int hashCode() { return 1; } } No newline at end of file'], ['*/ @Override public boolean equals(Object o) { if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { return method.equals(o); } } @Override public int hashCode() { return method.hashCode(); } } No newline at end of file'], ['return 1;'], ['if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { } return method.hashCode();'], 'a/src/org/mockito/internal/creation/DelegatingMethod.java', 'b/src/org/mockito/internal/creation/DelegatingMethod.java']
['Mockito-12', 1, 1, 1, 1, ["Type generic = field.getGenericType(); if (generic != null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (Class) actual; //in case of nested generics we don't go deep } return Object.class;"], ["Type generic = field.getGenericType(); if (generic != null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actual instanceof Class) { return (Class) actual; } else if (actual instanceof ParameterizedType) { //in case of nested generics we don't go deep return (Class) ((ParameterizedType) actual).getRawType(); } } return Object.class;"], [''], ['if (actual instanceof Class) { } else if (actual instanceof ParameterizedType) { return (Class) ((ParameterizedType) actual).getRawType(); }'], 'a/src/org/mockito/internal/util/reflection/GenericMaster.java', 'b/src/org/mockito/internal/util/reflection/GenericMaster.java']
['Mockito-13', 1, 1, 1, 1, ['if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) } }'], ['if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; } else { // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) mockingProgress.verificationStarted(verificationMode); } }'], ['if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {'], ['if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { } else { mockingProgress.verificationStarted(verificationMode);'], 'a/src/org/mockito/internal/MockHandler.java', 'b/src/org/mockito/internal/MockHandler.java']
['Mockito-14', 4, 4, 4, 4, ['import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubbedInvocationMatcher; import org.mockito.internal.stubbing.VoidMethodStubbableImpl; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.stubbing.Answer; import org.mockito.stubbing.VoidMethodStubbable;', 'if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher); verificationMode.verify(data); return null; } invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);', 'import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubberImpl; import org.mockito.internal.util.MockUtil; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.internal.verification.VerificationModeFactory; import org.mockito.internal.verification.api.InOrderContext;', '} else if (!mockUtil.isMock(mock)) { reporter.notAMockPassedToVerify(); } mockingProgress.verificationStarted(mode); return mock; }'], ['import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubbedInvocationMatcher; import org.mockito.internal.stubbing.VoidMethodStubbableImpl; import org.mockito.internal.verification.MockAwareVerificationMode; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.stubbing.Answer; import org.mockito.stubbing.VoidMethodStubbable;', 'if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher); verificationMode.verify(data); return null; } } invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);', 'import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubberImpl; import org.mockito.internal.util.MockUtil; import org.mockito.internal.verification.MockAwareVerificationMode; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.internal.verification.VerificationModeFactory; import org.mockito.internal.verification.api.InOrderContext;', '} else if (!mockUtil.isMock(mock)) { reporter.notAMockPassedToVerify(); } mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode)); return mock; }'], ['', '', '', 'mockingProgress.verificationStarted(mode);'], ['import org.mockito.internal.verification.MockAwareVerificationMode;', 'if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { }', 'import org.mockito.internal.verification.MockAwareVerificationMode;', 'mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));'], 'a/src/org/mockito/internal/MockitoCore.java', 'b/src/org/mockito/internal/MockitoCore.java']
['Mockito-15', 2, 2, 2, 2, ['package org.mockito.internal.configuration.injection; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.reflection.FieldSetter; import java.lang.reflect.Field;', 'return new OngoingInjecter() { public boolean thenInject() { try { new FieldSetter(fieldInstance, field).set(matchingMock); } catch (Exception e) { throw new MockitoException("Problems injecting dependency in " + field.getName(), e); }'], ['package org.mockito.internal.configuration.injection; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.reflection.BeanPropertySetter; import org.mockito.internal.util.reflection.FieldSetter; import java.lang.reflect.Field;', 'return new OngoingInjecter() { public boolean thenInject() { try { if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) { new FieldSetter(fieldInstance, field).set(matchingMock); } } catch (Exception e) { throw new MockitoException("Problems injecting dependency in " + field.getName(), e); }'], ['', ''], ['import org.mockito.internal.util.reflection.BeanPropertySetter;', 'if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) { }'], 'a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java', 'b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java']
['Mockito-16', 3, 3, 3, 3, ['* @return mock object */ public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) { return MOCKITO_CORE.mock(classToMock, mockSettings); } /**', 'public static <T> T spy(T object) { return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings() .spiedInstance(object) .defaultAnswer(CALLS_REAL_METHODS)); } /**', 'private final MockUtil mockUtil = new MockUtil(); private final MockingProgress mockingProgress = new ThreadSafeMockingProgress(); public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); } public <T> T mock(Class<T> classToMock, MockSettings mockSettings) { mockingProgress.validateState(); mockingProgress.resetOngoingStubbing(); return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings); }'], ['* @return mock object */ public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) { return MOCKITO_CORE.mock(classToMock, mockSettings, true); } /**', 'public static <T> T spy(T object) { return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings() .spiedInstance(object) .defaultAnswer(CALLS_REAL_METHODS), true); } /**', 'private final MockUtil mockUtil = new MockUtil(); private final MockingProgress mockingProgress = new ThreadSafeMockingProgress(); public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { mockingProgress.validateState(); if (shouldResetOngoingStubbing) { mockingProgress.resetOngoingStubbing(); } return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings); }'], ['return MOCKITO_CORE.mock(classToMock, mockSettings);', '.defaultAnswer(CALLS_REAL_METHODS));', 'public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); } public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {'], ['return MOCKITO_CORE.mock(classToMock, mockSettings, true);', '.defaultAnswer(CALLS_REAL_METHODS), true);', 'public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { if (shouldResetOngoingStubbing) { }'], 'a/src/org/mockito/internal/MockitoCore.java', 'b/src/org/mockito/internal/MockitoCore.java']
['Mockito-17', 4, 4, 4, 4, ['private Object spiedInstance; private Answer<Object> defaultAnswer; private MockName mockName; public MockSettings serializable() { return this.extraInterfaces(java.io.Serializable.class); } public MockSettings extraInterfaces(Class<?>... extraInterfaces) {', '} public boolean isSerializable() { return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class); } public void initiateMockName(Class classToMock) {', 'import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; @SuppressWarnings("unchecked") public class MockUtil {', 'Class<?>[] interfaces = settings.getExtraInterfaces(); Class<?>[] ancillaryTypes; ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces; Object spiedInstance = settings.getSpiedInstance();'], ['private Object spiedInstance; private Answer<Object> defaultAnswer; private MockName mockName; private boolean serializable; public MockSettings serializable() { this.serializable = true; return this; } public MockSettings extraInterfaces(Class<?>... extraInterfaces) {', '} public boolean isSerializable() { return serializable; } public void initiateMockName(Class classToMock) {', 'import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; import java.io.Serializable; @SuppressWarnings("unchecked") public class MockUtil {', 'Class<?>[] interfaces = settings.getExtraInterfaces(); Class<?>[] ancillaryTypes; if (settings.isSerializable()) { ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class); } else { ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces; } Object spiedInstance = settings.getSpiedInstance();'], ['return this.extraInterfaces(java.io.Serializable.class);', 'return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);', '', ''], ['private boolean serializable; this.serializable = true; return this;', 'return serializable;', 'import java.io.Serializable;', 'if (settings.isSerializable()) { ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class); } else { }'], 'a/src/org/mockito/internal/util/MockUtil.java', 'b/src/org/mockito/internal/util/MockUtil.java']
['Mockito-18', 1, 1, 1, 1, ['return Primitives.defaultValueForPrimitiveOrWrapper(type); //new instances are used instead of Collections.emptyList(), etc. //to avoid UnsupportedOperationException if code under test modifies returned collection } else if (type == Collection.class) { return new LinkedList<Object>(); } else if (type == Set.class) {'], ['return Primitives.defaultValueForPrimitiveOrWrapper(type); //new instances are used instead of Collections.emptyList(), etc. //to avoid UnsupportedOperationException if code under test modifies returned collection } else if (type == Iterable.class) { return new ArrayList<Object>(0); } else if (type == Collection.class) { return new LinkedList<Object>(); } else if (type == Set.class) {'], [''], ['} else if (type == Iterable.class) { return new ArrayList<Object>(0);'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java']
['Mockito-19', 9, 9, 9, 9, ['private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) { for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) { Field field = it.next(); Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject(); if (injected != null) { injectionOccurred |= true; mocks.remove(injected);', ' import java.lang.reflect.Field; import java.util.Collection; /** * This node returns an actual injecter which will be either :', '* </ul> */ public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) { if(mocks.size() == 1) { final Object matchingMock = mocks.iterator().next();', ' import java.lang.reflect.Field; import java.util.Collection; public interface MockCandidateFilter { OngoingInjecter filterCandidate( Collection<Object> mocks, Field fieldToBeInjected, Object fieldInstance ); }', '} public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) { List<Object> mockNameMatches = new ArrayList<Object>(); if (mocks.size() > 1) { for (Object mock : mocks) {', 'mockNameMatches.add(mock); } } return next.filterCandidate(mockNameMatches, field, fieldInstance); /* * In this case we have to check whether we have conflicting naming', '* whenever we find a field that does match its name with the mock * name, we should take that field instead. */ } return next.filterCandidate(mocks, field, fieldInstance); } }', 'this.next = next; } public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) { List<Object> mockTypeMatches = new ArrayList<Object>(); for (Object mock : mocks) { if (field.getType().isAssignableFrom(mock.getClass())) {', '} } return next.filterCandidate(mockTypeMatches, field, fieldInstance); } }'], ['private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) { for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) { Field field = it.next(); Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject(); if (injected != null) { injectionOccurred |= true; mocks.remove(injected);', ' import java.lang.reflect.Field; import java.util.Collection; import java.util.List; /** * This node returns an actual injecter which will be either :', '* </ul> */ public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) { if(mocks.size() == 1) { final Object matchingMock = mocks.iterator().next();', ' import java.lang.reflect.Field; import java.util.Collection; import java.util.List; public interface MockCandidateFilter { OngoingInjecter filterCandidate( Collection<Object> mocks, Field fieldToBeInjected, List<Field> fields, Object instance ); }', '} public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) { List<Object> mockNameMatches = new ArrayList<Object>(); if (mocks.size() > 1) { for (Object mock : mocks) {', 'mockNameMatches.add(mock); } } return next.filterCandidate(mockNameMatches, field, fields, fieldInstance); /* * In this case we have to check whether we have conflicting naming', '* whenever we find a field that does match its name with the mock * name, we should take that field instead. */ } else if (mocks.size() == 1) { String mockName = mockUtil.getMockName(mocks.iterator().next()) .toString(); for (Field otherField : fields) { if (!otherField.equals(field) && otherField.getType().equals(field.getType()) && otherField.getName().equals(mockName)) { return new OngoingInjecter() { public Object thenInject() { return null; } }; } } } return next.filterCandidate(mocks, field, fields, fieldInstance); } }', 'this.next = next; } public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) { List<Object> mockTypeMatches = new ArrayList<Object>(); for (Object mock : mocks) { if (field.getType().isAssignableFrom(mock.getClass())) {', '} } return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance); } }'], ['Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();', '', 'public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {', 'Object fieldInstance', 'Field field, Object fieldInstance) {', 'return next.filterCandidate(mockNameMatches, field,', 'return next.filterCandidate(mocks, field, fieldInstance);', 'public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {', 'return next.filterCandidate(mockTypeMatches, field, fieldInstance);'], ['Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();', 'import java.util.List;', 'public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {', 'import java.util.List; List<Field> fields, Object instance', 'Field field, List<Field> fields, Object fieldInstance) {', 'return next.filterCandidate(mockNameMatches, field, fields,', '} else if (mocks.size() == 1) { String mockName = mockUtil.getMockName(mocks.iterator().next()) .toString(); for (Field otherField : fields) { if (!otherField.equals(field) && otherField.getType().equals(field.getType()) && otherField.getName().equals(mockName)) { return new OngoingInjecter() { public Object thenInject() { return null; } }; } } return next.filterCandidate(mocks, field, fields, fieldInstance);', 'public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {', 'return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);'], 'a/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java', 'b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java']
['Mockito-20', 2, 2, 2, 2, ['settings.getTypeToMock(), settings.getExtraInterfaces() ); T mockInstance = null; try { mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));', '" class to mock : " + describeClass(mockedProxyType), " created class : " + describeClass(settings.getTypeToMock()), " proxy instance class : " + describeClass(mockInstance), " instance creation by : " + classInstantiator.getClass().getSimpleName(), "", "You might experience classloading issues, please ask the mockito mailing-list.", ""'], ['settings.getTypeToMock(), settings.getExtraInterfaces() ); Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); T mockInstance = null; try { mockInstance = instantiator.newInstance(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));', '" class to mock : " + describeClass(mockedProxyType), " created class : " + describeClass(settings.getTypeToMock()), " proxy instance class : " + describeClass(mockInstance), " instance creation by : " + instantiator.getClass().getSimpleName(), "", "You might experience classloading issues, please ask the mockito mailing-list.", ""'], ['mockInstance = classInstantiator.instantiate(mockedProxyType);', '" instance creation by : " + classInstantiator.getClass().getSimpleName(),'], ['Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); mockInstance = instantiator.newInstance(mockedProxyType);', '" instance creation by : " + instantiator.getClass().getSimpleName(),'], 'a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java', 'b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java']
['Mockito-21', 2, 2, 2, 2, ["if (outerClassInstance == null) { return noArgConstructor(cls); } return withOuterClass(cls); } private <T> T withOuterClass(Class<T> cls) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance); } catch (Exception e) { throw paramsException(cls, e); } } private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", '+ cls.getSimpleName() + "\'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.", e); } private static <T> T noArgConstructor(Class<T> cls) { try {'], ["if (outerClassInstance == null) { return noArgConstructor(cls); } return withParams(cls, outerClassInstance); } private static <T> T withParams(Class<T> cls, Object... params) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } } catch (Exception e) { throw paramsException(cls, e); } throw paramsException(cls, null); } private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", '+ cls.getSimpleName() + "\'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.", e); } private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; } private static <T> T noArgConstructor(Class<T> cls) { try {'], ['return withOuterClass(cls); private <T> T withOuterClass(Class<T> cls) { Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);', ''], ['return withParams(cls, outerClassInstance); private static <T> T withParams(Class<T> cls, Object... params) { for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } throw paramsException(cls, null);', 'private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; }'], 'a/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java', 'b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java']
['Mockito-22', 1, 1, 1, 1, ['public class Equality { public static boolean areEqual(Object o1, Object o2) { if (o1 == null || o2 == null) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2);'], ['public class Equality { public static boolean areEqual(Object o1, Object o2) { if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2);'], ['if (o1 == null || o2 == null) {'], ['if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) {'], 'a/src/org/mockito/internal/matchers/Equality.java', 'b/src/org/mockito/internal/matchers/Equality.java']
['Mockito-23', 5, 5, 5, 5, [' private static final long serialVersionUID = -7105341425736035847L; private MockitoCore mockitoCore = new MockitoCore(); private ReturnsEmptyValues delegate = new ReturnsEmptyValues(); public Object answer(InvocationOnMock invocation) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod()); Class<?> rawType = returnTypeGenericMetadata.rawType(); if (!mockitoCore.isTypeMockable(rawType)) { return delegate.returnValueFor(rawType); }', 'return getMock(invocation, returnTypeGenericMetadata); } private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());', ': withSettings(); return mockSettings .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); }', ' private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable { container.addAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable { return mock; }', 'return mock; } protected GenericMetadataSupport actualParameterizedType(Object mock) {'], [' private static final long serialVersionUID = -7105341425736035847L; private transient MockitoCore mockitoCore; private transient ReturnsEmptyValues delegate; public Object answer(InvocationOnMock invocation) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod()); Class<?> rawType = returnTypeGenericMetadata.rawType(); instantiateMockitoCoreIfNeeded(); instantiateDelegateIfNeeded(); if (!mockitoCore.isTypeMockable(rawType)) { return delegate.returnValueFor(rawType); }', 'return getMock(invocation, returnTypeGenericMetadata); } private synchronized void instantiateMockitoCoreIfNeeded() { if (mockitoCore == null) { mockitoCore = new MockitoCore(); } } private synchronized void instantiateDelegateIfNeeded() { if (delegate == null) { delegate = new ReturnsEmptyValues(); } } private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());', ': withSettings(); return mockSettings .serializable() .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); }', ' private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable { container.addAnswer(new SerializableAnswer() { public Object answer(InvocationOnMock invocation) throws Throwable { return mock; }', 'return mock; } abstract class SerializableAnswer implements Answer<Object>, Serializable { } protected GenericMetadataSupport actualParameterizedType(Object mock) {'], ['private MockitoCore mockitoCore = new MockitoCore(); private ReturnsEmptyValues delegate = new ReturnsEmptyValues();', '', '', 'container.addAnswer(new Answer<Object>() {', ''], ['private transient MockitoCore mockitoCore; private transient ReturnsEmptyValues delegate; instantiateMockitoCoreIfNeeded(); instantiateDelegateIfNeeded();', 'private synchronized void instantiateMockitoCoreIfNeeded() { if (mockitoCore == null) { mockitoCore = new MockitoCore(); } } private synchronized void instantiateDelegateIfNeeded() { if (delegate == null) { delegate = new ReturnsEmptyValues(); } }', '.serializable()', 'container.addAnswer(new SerializableAnswer() {', 'abstract class SerializableAnswer implements Answer<Object>, Serializable { }'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java']
['Mockito-24', 1, 1, 1, 1, ['//see issue 184. //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good). //Only for compareTo() method by the Comparable interface return 1; } Class<?> returnType = invocation.getMethod().getReturnType();'], ['//see issue 184. //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good). //Only for compareTo() method by the Comparable interface return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1; } Class<?> returnType = invocation.getMethod().getReturnType();'], ['return 1;'], ['return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java']
['Mockito-25', 5, 5, 5, 5, ['*/ package org.mockito.internal.stubbing.defaultanswers; import org.mockito.internal.InternalMockHandler; import org.mockito.internal.creation.settings.CreationSettings; import org.mockito.internal.stubbing.InvocationContainerImpl;', ' import java.io.Serializable; /** * Returning deep stub implementation.', 'return delegate.returnValueFor(rawType); } return getMock(invocation); } private Object getMock(InvocationOnMock invocation) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock()); InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();', '} // deep stub return recordDeepStubMock(invocation, container); } /**', '* @param returnTypeGenericMetadata The metadata to use to create the new mock. * @return The mock */ private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) { Class<?> clz = invocation.getMethod().getReturnType(); final Object mock = org.mockito.Mockito.mock(clz, this); container.addAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable {'], ['*/ package org.mockito.internal.stubbing.defaultanswers; import org.mockito.MockSettings; import org.mockito.internal.InternalMockHandler; import org.mockito.internal.creation.settings.CreationSettings; import org.mockito.internal.stubbing.InvocationContainerImpl;', ' import java.io.Serializable; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings; /** * Returning deep stub implementation.', 'return delegate.returnValueFor(rawType); } return getMock(invocation, returnTypeGenericMetadata); } private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock()); InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();', '} // deep stub return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container); } /**', '* @param returnTypeGenericMetadata The metadata to use to create the new mock. * @return The mock */ private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { return mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { MockSettings mockSettings = returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return mockSettings .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubs() { @Override protected GenericMetadataSupport actualParameterizedType(Object mock) { return returnTypeGenericMetadata; } }; } private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable { container.addAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable {'], ['', '', 'return getMock(invocation); private Object getMock(InvocationOnMock invocation) throws Throwable {', 'return recordDeepStubMock(invocation, container);', 'private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) { Class<?> clz = invocation.getMethod().getReturnType(); final Object mock = org.mockito.Mockito.mock(clz, this);'], ['import org.mockito.MockSettings;', 'import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings;', 'return getMock(invocation, returnTypeGenericMetadata); private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {', 'return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);', 'private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { return mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { MockSettings mockSettings = returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return mockSettings .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubs() { @Override protected GenericMetadataSupport actualParameterizedType(Object mock) { return returnTypeGenericMetadata; } }; } private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java']
['Mockito-26', 1, 1, 1, 1, ['primitiveValues.put(int.class, 0); primitiveValues.put(long.class, 0L); primitiveValues.put(float.class, 0F); primitiveValues.put(double.class, 0); } } No newline at end of file'], ['primitiveValues.put(int.class, 0); primitiveValues.put(long.class, 0L); primitiveValues.put(float.class, 0F); primitiveValues.put(double.class, 0D); } } No newline at end of file'], ['primitiveValues.put(double.class, 0);'], ['primitiveValues.put(double.class, 0D);'], 'a/src/org/mockito/internal/util/Primitives.java', 'b/src/org/mockito/internal/util/Primitives.java']
['Mockito-27', 1, 1, 1, 1, [' public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); ((Factory) mock).setCallback(0, newFilter); }'], [' public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings()); ((Factory) mock).setCallback(0, newFilter); }'], ['MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));'], ['MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());'], 'a/src/org/mockito/internal/util/MockUtil.java', 'b/src/org/mockito/internal/util/MockUtil.java']
['Mockito-28', 1, 1, 1, 1, [' private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); } }'], [' private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected); } }'], ['mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();'], ['Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected);'], 'a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java', 'b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java']
['Mockito-29', 1, 1, 1, 1, ['public void describeTo(Description description) { description.appendText("same("); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(")"); }'], ['public void describeTo(Description description) { description.appendText("same("); appendQuoting(description); description.appendText(wanted == null ? "null" : wanted.toString()); appendQuoting(description); description.appendText(")"); }'], ['description.appendText(wanted.toString());'], ['description.appendText(wanted == null ? "null" : wanted.toString());'], 'a/src/org/mockito/internal/matchers/Same.java', 'b/src/org/mockito/internal/matchers/Same.java']
['Mockito-30', 2, 2, 2, 2, [')); } public void smartNullPointerException(Location location) { throw new SmartNullPointerException(join( "You have a NullPointerException here:", new Location(), "Because this method was *not* stubbed correctly:", location, ""', 'return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock"; } new Reporter().smartNullPointerException(location); return null; }'], [')); } public void smartNullPointerException(Object obj, Location location) { throw new SmartNullPointerException(join( "You have a NullPointerException here:", new Location(), obj, "Because this method was *not* stubbed correctly:", location, ""', 'return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock"; } new Reporter().smartNullPointerException(obj, location); return null; }'], ['public void smartNullPointerException(Location location) {', 'new Reporter().smartNullPointerException(location);'], ['public void smartNullPointerException(Object obj, Location location) { obj,', 'new Reporter().smartNullPointerException(obj, location);'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java']
['Mockito-31', 2, 2, 2, 2, [' import java.io.Serializable; import java.lang.reflect.Method; import org.mockito.Mockito; import org.mockito.cglib.proxy.MethodInterceptor;', '} private String formatMethodCall() { return invocation.getMethod().getName() + "()"; } }'], [' import java.io.Serializable; import java.lang.reflect.Method; import java.util.Arrays; import org.mockito.Mockito; import org.mockito.cglib.proxy.MethodInterceptor;', '} private String formatMethodCall() { String args = Arrays.toString(invocation.getArguments()); return invocation.getMethod().getName() + "(" + args.substring(1, args.length() - 1) +\t")"; } }'], ['', 'return invocation.getMethod().getName() + "()";'], ['import java.util.Arrays;', 'String args = Arrays.toString(invocation.getArguments()); return invocation.getMethod().getName() + "(" + args.substring(1, args.length() - 1) +\t")";'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java']
['Mockito-32', 2, 2, 2, 2, ['import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.MockUtil; @SuppressWarnings({"unchecked"}) public class SpyAnnotationEngine implements AnnotationEngine {', '// instance has been spied earlier Mockito.reset(instance); } else { field.set(testClass, Mockito.spy(instance)); } } catch (IllegalAccessException e) { throw new MockitoException("Problems initiating spied field " + field.getName(), e);'], ['import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.MockUtil; import static org.mockito.Mockito.withSettings; @SuppressWarnings({"unchecked"}) public class SpyAnnotationEngine implements AnnotationEngine {', '// instance has been spied earlier Mockito.reset(instance); } else { field.set(testClass, Mockito.mock(instance.getClass(), withSettings() .spiedInstance(instance) .defaultAnswer(Mockito.CALLS_REAL_METHODS) .name(field.getName()))); } } catch (IllegalAccessException e) { throw new MockitoException("Problems initiating spied field " + field.getName(), e);'], ['', 'field.set(testClass, Mockito.spy(instance));'], ['import static org.mockito.Mockito.withSettings;', 'field.set(testClass, Mockito.mock(instance.getClass(), withSettings() .spiedInstance(instance) .defaultAnswer(Mockito.CALLS_REAL_METHODS) .name(field.getName())));'], 'a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java', 'b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java']
['Mockito-33', 1, 1, 1, 1, ['Method m1 = invocation.getMethod(); Method m2 = candidate.getMethod(); /* Avoid unnecessary cloning */ return m1.equals(m2); } public Location getLocation() {'], ['Method m1 = invocation.getMethod(); Method m2 = candidate.getMethod(); if (m1.getName() != null && m1.getName().equals(m2.getName())) { /* Avoid unnecessary cloning */ Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false; } public Location getLocation() {'], ['return m1.equals(m2);'], ['if (m1.getName() != null && m1.getName().equals(m2.getName())) { Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false;'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-34', 1, 1, 1, 1, ['public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++;'], ['public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { if (m instanceof CapturesArguments && i.getArguments().length > k) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++;'], ['if (m instanceof CapturesArguments) {'], ['if (m instanceof CapturesArguments && i.getArguments().length > k) {'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-35', 3, 3, 3, 3, ['* @return <code>null</code>. */ public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T eq(T value) { return reportMatcher(new Equals(value)).<T>returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T same(T value) { return reportMatcher(new Same(value)).<T>returnNull(); } /**'], ['* @return <code>null</code>. */ public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz); } /**', '* @return <code>null</code>. */ public static <T> T eq(T value) { return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass()); } /**', '* @return <code>null</code>. */ public static <T> T same(T value) { return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass()); } /**'], ['return reportMatcher(new InstanceOf(clazz)).<T>returnNull();', 'return reportMatcher(new Equals(value)).<T>returnNull();', 'return reportMatcher(new Same(value)).<T>returnNull();'], ['return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);', 'return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());', 'return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());'], 'a/src/org/mockito/Matchers.java', 'b/src/org/mockito/Matchers.java']
['Mockito-36', 2, 2, 2, 2, [' import org.hamcrest.Matcher; import org.mockito.exceptions.PrintableInvocation; import org.mockito.internal.debugging.Location; import org.mockito.internal.invocation.realmethod.RealMethod; import org.mockito.internal.matchers.*;', '} public Object callRealMethod() throws Throwable { return realMethod.invoke(mock, rawArguments); }'], [' import org.hamcrest.Matcher; import org.mockito.exceptions.PrintableInvocation; import org.mockito.exceptions.Reporter; import org.mockito.internal.debugging.Location; import org.mockito.internal.invocation.realmethod.RealMethod; import org.mockito.internal.matchers.*;', '} public Object callRealMethod() throws Throwable { if (this.getMethod().getDeclaringClass().isInterface()) { new Reporter().cannotCallRealMethodOnInterface(); } return realMethod.invoke(mock, rawArguments); }'], ['', ''], ['import org.mockito.exceptions.Reporter;', 'if (this.getMethod().getDeclaringClass().isInterface()) { new Reporter().cannotCallRealMethodOnInterface(); }'], 'a/src/org/mockito/internal/invocation/Invocation.java', 'b/src/org/mockito/internal/invocation/Invocation.java']
['Mockito-37', 1, 1, 1, 1, ['validateDoNothing((DoesNothing) answer, invocation); } } private void validateDoNothing(DoesNothing answer, Invocation invocation) { if (!invocation.isVoid()) {'], ['validateDoNothing((DoesNothing) answer, invocation); } if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } } private void validateDoNothing(DoesNothing answer, Invocation invocation) { if (!invocation.isVoid()) {'], [''], ['if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } }'], 'a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java', 'b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java']
['Mockito-38', 1, 1, 1, 1, ['} private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg.toString()); } }'], ['} private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg == null? "null" : arg.toString()); } }'], ['return StringDescription.toString(m).equals(arg.toString());'], ['return StringDescription.toString(m).equals(arg == null? "null" : arg.toString());'], 'a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java', 'b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java']
['Collections-1', 2, 2, 2, 2, ['switch (nextIndex) { case 3: parent.value3 = value; case 2: parent.value2 = value; case 1: parent.value1 = value; } return old; }', 'switch (nextIndex) { case 3: parent.value3 = value; case 2: parent.value2 = value; case 1: parent.value1 = value; } return old; }'], ['switch (nextIndex) { case 3: parent.value3 = value; break; case 2: parent.value2 = value; break; case 1: parent.value1 = value; break; } return old; }', 'switch (nextIndex) { case 3: parent.value3 = value; break; case 2: parent.value2 = value; break; case 1: parent.value1 = value; break; } return old; }'], ['', ''], ['break; break; break;', 'break; break; break;'], 'a/src/java/org/apache/commons/collections/map/Flat3Map.java', 'b/src/java/org/apache/commons/collections/map/Flat3Map.java']
['Collections-2', 5, 5, 5, 5, ['* This is the name of the property that can point to other * properties file for including other properties files. */ /** * This is the default name of the property that can point to other', '* @return the property name which includes another property */ public String getInclude() { return include; // backwards compatability } /**', '* @param inc the property name which includes another property, empty converted to null */ public void setInclude(String inc) { include = inc; } /**', '} try { while (true) { String line = reader.readProperty(); if (line == null) {', 'continue; } if (getInclude() != null && key.equalsIgnoreCase(getInclude())) { // Recursively load properties files. File file = null;'], ['* This is the name of the property that can point to other * properties file for including other properties files. */ private String includePropertyName = null; /** * This is the default name of the property that can point to other', '* @return the property name which includes another property */ public String getInclude() { if (includePropertyName == null) { return include; // backwards compatability } if ("".equals(includePropertyName)) { return null; // hack to allow backwards compatability } return includePropertyName; } /**', '* @param inc the property name which includes another property, empty converted to null */ public void setInclude(String inc) { if (inc == null) { inc = ""; // hack to allow backwards compatability } includePropertyName = inc; } /**', '} try { String includeProperty = getInclude(); while (true) { String line = reader.readProperty(); if (line == null) {', 'continue; } if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) { // Recursively load properties files. File file = null;'], ['', '', 'include = inc;', '', 'if (getInclude() != null && key.equalsIgnoreCase(getInclude())) {'], ['private String includePropertyName = null;', 'if (includePropertyName == null) { } if ("".equals(includePropertyName)) { return null; // hack to allow backwards compatability } return includePropertyName;', 'if (inc == null) { inc = ""; // hack to allow backwards compatability } includePropertyName = inc;', 'String includeProperty = getInclude();', 'if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-3', 1, 1, 1, 1, ['* @since Commons Collections 3.3 (method existed in 3.2 but was completely broken) */ public static Collection removeAll(Collection collection, Collection remove) { return ListUtils.retainAll(collection, remove); } //-----------------------------------------------------------------------'], ['* @since Commons Collections 3.3 (method existed in 3.2 but was completely broken) */ public static Collection removeAll(Collection collection, Collection remove) { return ListUtils.removeAll(collection, remove); } //-----------------------------------------------------------------------'], ['return ListUtils.retainAll(collection, remove);'], ['return ListUtils.removeAll(collection, remove);'], 'a/src/java/org/apache/commons/collections/CollectionUtils.java', 'b/src/java/org/apache/commons/collections/CollectionUtils.java']
['Collections-4', 2, 2, 2, 2, ['Collection coll = getCollection(key); if (coll == null) { coll = createCollection(1); // might produce a non-empty collection result = coll.add(value); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = false; } } else { result = coll.add(value);', 'if (values == null || values.size() == 0) { return false; } Collection coll = getCollection(key); if (coll == null) { coll = createCollection(values.size()); // might produce a non-empty collection boolean result = coll.addAll(values); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = false; } return result; } else { return coll.addAll(values); } } /**'], ['Collection coll = getCollection(key); if (coll == null) { coll = createCollection(1); // might produce a non-empty collection coll.add(value); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = true; // map definitely changed } } else { result = coll.add(value);', 'if (values == null || values.size() == 0) { return false; } boolean result = false; Collection coll = getCollection(key); if (coll == null) { coll = createCollection(values.size()); // might produce a non-empty collection coll.addAll(values); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = true; // map definitely changed } } else { result = coll.addAll(values); } return result; } /**'], ['result = coll.add(value); result = false;', 'boolean result = coll.addAll(values); result = false; return result; return coll.addAll(values);'], ['coll.add(value); result = true; // map definitely changed', 'boolean result = false; coll.addAll(values); result = true; // map definitely changed result = coll.addAll(values); return result;'], 'a/src/java/org/apache/commons/collections/map/MultiValueMap.java', 'b/src/java/org/apache/commons/collections/map/MultiValueMap.java']
['Collections-5', 1, 1, 1, 1, [' // adds all elements for (final Iterator it = coll.iterator(); it.hasNext();) { add(it.next()); // if it was inserted, then increase the target index } // compares sizes to detect if collection changed'], [' // adds all elements for (final Iterator it = coll.iterator(); it.hasNext();) { int sizeBeforeAddNext = size(); add(index, it.next()); // if it was inserted, then increase the target index if (sizeBeforeAddNext != size()) { index++; } } // compares sizes to detect if collection changed'], ['add(it.next());'], ['int sizeBeforeAddNext = size(); add(index, it.next()); if (sizeBeforeAddNext != size()) { index++; }'], 'a/src/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-6', 6, 6, 6, 6, ['return old; } if (key2 == null) { Object old = value3; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (key1 == null) { Object old = value3; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (key1 == null) { Object old = value2; hash1 = hash2; key1 = key2; value1 = value2;', 'return old; } if (hash2 == hashCode && key.equals(key2)) { Object old = value3; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value3; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value2; hash1 = hash2; key1 = key2; value1 = value2;'], ['return old; } if (key2 == null) { Object old = value2; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (key1 == null) { Object old = value1; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (key1 == null) { Object old = value1; hash1 = hash2; key1 = key2; value1 = value2;', 'return old; } if (hash2 == hashCode && key.equals(key2)) { Object old = value2; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value1; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value1; hash1 = hash2; key1 = key2; value1 = value2;'], ['Object old = value3;', 'Object old = value3;', 'Object old = value2;', 'Object old = value3;', 'Object old = value3;', 'Object old = value2;'], ['Object old = value2;', 'Object old = value1;', 'Object old = value1;', 'Object old = value2;', 'Object old = value1;', 'Object old = value1;'], 'a/src/java/org/apache/commons/collections/map/Flat3Map.java', 'b/src/java/org/apache/commons/collections/map/Flat3Map.java']
['Collections-7', 16, 16, 16, 16, ["*/ public Object getProperty(String key) { // first, try to get from the 'user value' store Object obj = this.get(key); if (obj == null) { // if there isn't a value there, get it from the", 'if (!containsKey(key)) { keysAsListed.add(key); } put(key, value); } /**', 'List values = new Vector(2); values.add(current); values.add(value); put(key, values); } else if (current instanceof List) { // already a list - just add the new token', 'if (!containsKey(key)) { keysAsListed.add(key); } put(key, value); } }', 'break; } } remove(key); } }', '} else if (value instanceof String) { Vector values = new Vector(1); values.add(value); put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { List values = new ArrayList(1); values.add(value); put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { String s = testBoolean((String) value); Boolean b = new Boolean(s); put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Byte b = new Byte((String) value); put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Short s = new Short((String) value); put(key, s); return s; } else if (value == null) {', ' } else if (value instanceof String) { Integer i = new Integer((String) value); put(key, i); return i; } else if (value == null) {', ' } else if (value instanceof String) { Long l = new Long((String) value); put(key, l); return l; } else if (value == null) {', ' } else if (value instanceof String) { Float f = new Float((String) value); put(key, f); return f; } else if (value == null) {', ' } else if (value instanceof String) { Double d = new Double((String) value); put(key, d); return d; } else if (value == null) {', '* @param value for the property * @return old value of the property */ /** * Add a map full of key/value pairs to the ExtendedProperties.', '* @param key specifying the property * @return old value of the property */ }'], ["*/ public Object getProperty(String key) { // first, try to get from the 'user value' store Object obj = super.get(key); if (obj == null) { // if there isn't a value there, get it from the", 'if (!containsKey(key)) { keysAsListed.add(key); } super.put(key, value); } /**', 'List values = new Vector(2); values.add(current); values.add(value); super.put(key, values); } else if (current instanceof List) { // already a list - just add the new token', 'if (!containsKey(key)) { keysAsListed.add(key); } super.put(key, value); } }', 'break; } } super.remove(key); } }', '} else if (value instanceof String) { Vector values = new Vector(1); values.add(value); super.put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { List values = new ArrayList(1); values.add(value); super.put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { String s = testBoolean((String) value); Boolean b = new Boolean(s); super.put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Byte b = new Byte((String) value); super.put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Short s = new Short((String) value); super.put(key, s); return s; } else if (value == null) {', ' } else if (value instanceof String) { Integer i = new Integer((String) value); super.put(key, i); return i; } else if (value == null) {', ' } else if (value instanceof String) { Long l = new Long((String) value); super.put(key, l); return l; } else if (value == null) {', ' } else if (value instanceof String) { Float f = new Float((String) value); super.put(key, f); return f; } else if (value == null) {', ' } else if (value instanceof String) { Double d = new Double((String) value); super.put(key, d); return d; } else if (value == null) {', '* @param value for the property * @return old value of the property */ public Object put(Object key, Object value) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); addProperty(strKey, value); return ret; } /** * Add a map full of key/value pairs to the ExtendedProperties.', '* @param key specifying the property * @return old value of the property */ public Object remove(Object key) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); clearProperty(strKey); return ret; } }'], ['Object obj = this.get(key);', 'put(key, value);', 'put(key, values);', 'put(key, value);', 'remove(key);', 'put(key, values);', 'put(key, values);', 'put(key, b);', 'put(key, b);', 'put(key, s);', 'put(key, i);', 'put(key, l);', 'put(key, f);', 'put(key, d);', '', ''], ['Object obj = super.get(key);', 'super.put(key, value);', 'super.put(key, values);', 'super.put(key, value);', 'super.remove(key);', 'super.put(key, values);', 'super.put(key, values);', 'super.put(key, b);', 'super.put(key, b);', 'super.put(key, s);', 'super.put(key, i);', 'super.put(key, l);', 'super.put(key, f);', 'super.put(key, d);', 'public Object put(Object key, Object value) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); addProperty(strKey, value); return ret; }', 'public Object remove(Object key) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); clearProperty(strKey); return ret; }'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-8', 2, 2, 2, 2, ['private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(size()); for (Iterator it = iterator(); it.hasNext();) { out.writeObject(it.next()); }', 'private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); int size = in.readInt(); buffer = new Object[size + 1]; for (int i = 0; i < size; i++) { buffer[i] = in.readObject(); }'], ['private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(size()); out.writeInt(buffer.length); for (Iterator it = iterator(); it.hasNext();) { out.writeObject(it.next()); }', 'private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); int size = in.readInt(); int length = in.readInt(); buffer = new Object[length]; for (int i = 0; i < size; i++) { buffer[i] = in.readObject(); }'], ['', 'buffer = new Object[size + 1];'], ['out.writeInt(buffer.length);', 'int length = in.readInt(); buffer = new Object[length];'], 'a/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java', 'b/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java']
['Collections-9', 1, 1, 1, 1, ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); setProperty(key, props.get(key)); } }'], ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); super.put(key, props.get(key)); } }'], ['setProperty(key, props.get(key));'], ['super.put(key, props.get(key));'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-10', 2, 2, 2, 2, ['* @version $Revision$ $Date$ * @since Commons Collections 3.2 */ public class MultiValueMap extends AbstractMapDecorator implements MultiMap { /** Serialization version */ /** The factory for creating value collections. */ private final Factory collectionFactory;', '/** * Inner class that provides a simple reflection factory. */ private static class ReflectionFactory implements Factory { private final Class clazz; public ReflectionFactory(Class clazz) {'], ['* @version $Revision$ $Date$ * @since Commons Collections 3.2 */ public class MultiValueMap extends AbstractMapDecorator implements MultiMap, Serializable { /** Serialization version */ private static final long serialVersionUID = -2214159910087182007L; /** The factory for creating value collections. */ private final Factory collectionFactory;', '/** * Inner class that provides a simple reflection factory. */ private static class ReflectionFactory implements Factory, Serializable { private final Class clazz; public ReflectionFactory(Class clazz) {'], ['public class MultiValueMap extends AbstractMapDecorator implements MultiMap {', 'private static class ReflectionFactory implements Factory {'], ['public class MultiValueMap extends AbstractMapDecorator implements MultiMap, Serializable { private static final long serialVersionUID = -2214159910087182007L;', 'private static class ReflectionFactory implements Factory, Serializable {'], 'a/src/java/org/apache/commons/collections/map/MultiValueMap.java', 'b/src/java/org/apache/commons/collections/map/MultiValueMap.java']
['Collections-11', 1, 1, 1, 1, ['* only stable for the same process). * @return the instance with recalculated hash code */ }'], ['* only stable for the same process). * @return the instance with recalculated hash code */ private Object readResolve() { calculateHashCode(keys); return this; } }'], [''], ['private Object readResolve() { calculateHashCode(keys); return this; }'], 'a/src/java/org/apache/commons/collections/keyvalue/MultiKey.java', 'b/src/java/org/apache/commons/collections/keyvalue/MultiKey.java']
['Collections-12', 1, 1, 1, 1, ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); super.put(key, props.get(key)); } }'], ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); clearProperty(key); addPropertyDirect(key, props.get(key)); } }'], ['super.put(key, props.get(key));'], ['clearProperty(key); addPropertyDirect(key, props.get(key));'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-13', 1, 1, 1, 1, [' for (Enumeration e = props.propertyNames(); e.hasMoreElements();) { String s = (String) e.nextElement(); c.setProperty(s, props.getProperty(s)); } return c;'], [' for (Enumeration e = props.propertyNames(); e.hasMoreElements();) { String s = (String) e.nextElement(); String value = props.getProperty(s); if(value != null) { c.setProperty(s, value); } } return c;'], ['c.setProperty(s, props.getProperty(s));'], ['String value = props.getProperty(s); if(value != null) { c.setProperty(s, value); }'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-14', 1, 1, 1, 1, ['*/ protected Object convertKey(Object key) { if (key != null) { return key.toString().toLowerCase(); } else { return AbstractHashedMap.NULL; }'], ['*/ protected Object convertKey(Object key) { if (key != null) { char[] chars = key.toString().toCharArray(); for (int i = chars.length - 1; i >= 0; i--) { chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i])); } return new String(chars); } else { return AbstractHashedMap.NULL; }'], ['return key.toString().toLowerCase();'], ['char[] chars = key.toString().toCharArray(); for (int i = chars.length - 1; i >= 0; i--) { chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i])); } return new String(chars);'], 'a/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java', 'b/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java']
['Collections-15', 1, 1, 1, 1, ["int pos = indexOf(object); Object removed = super.set(index, object); if (pos == -1 || pos == index) { // the object is already in the uniq list // (and it hasn't been swapped with itself) return removed; } super.remove(pos); set.remove(removed); // remove the item deleted by the set return removed; // return the item deleted by the set"], ["int pos = indexOf(object); Object removed = super.set(index, object); if (pos != -1 && pos != index) { // the object is already in the uniq list // (and it hasn't been swapped with itself) super.remove(pos); // remove the duplicate by index } set.add(object); // add the new item to the unique set set.remove(removed); // remove the item deleted by the set return removed; // return the item deleted by the set"], ['if (pos == -1 || pos == index) { return removed; super.remove(pos);'], ['if (pos != -1 && pos != index) { super.remove(pos); // remove the duplicate by index set.add(object); // add the new item to the unique set'], 'a/src/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-16', 1, 1, 1, 1, ['} public List subList(int fromIndex, int toIndex) { return new SetUniqueList(super.subList(fromIndex, toIndex), set); } //-----------------------------------------------------------------------'], ['} public List subList(int fromIndex, int toIndex) { List superSubList = super.subList(fromIndex, toIndex); Set subSet = createSetBasedOnList(set, superSubList); return new SetUniqueList(superSubList, subSet); } protected Set createSetBasedOnList(Set set, List list) { Set subSet = null; if(set.getClass().equals(HashSet.class)) { subSet = new HashSet(); } else { try { subSet = (Set) set.getClass().newInstance(); } catch(InstantiationException ie) { subSet = new HashSet(); } catch(IllegalAccessException iae) { subSet = new HashSet(); } } subSet.addAll(list); return subSet; } //-----------------------------------------------------------------------'], ['return new SetUniqueList(super.subList(fromIndex, toIndex), set);'], ['List superSubList = super.subList(fromIndex, toIndex); Set subSet = createSetBasedOnList(set, superSubList); return new SetUniqueList(superSubList, subSet); } protected Set createSetBasedOnList(Set set, List list) { Set subSet = null; if(set.getClass().equals(HashSet.class)) { subSet = new HashSet(); } else { try { subSet = (Set) set.getClass().newInstance(); } catch(InstantiationException ie) { subSet = new HashSet(); } catch(IllegalAccessException iae) { subSet = new HashSet(); } } subSet.addAll(list); return subSet;'], 'a/src/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-17', 2, 2, 2, 2, ['public EqualPredicate(T object) { // do not use the DefaultEquator to keep backwards compatibility // the DefaultEquator returns also true if the two object references are equal this(object, new DefaultEquator<T>()); } /**', '* @return true if input object equals stored value */ public boolean evaluate(T object) { return equator.equate(iValue, object); } /**'], ['public EqualPredicate(T object) { // do not use the DefaultEquator to keep backwards compatibility // the DefaultEquator returns also true if the two object references are equal this(object, null); } /**', '* @return true if input object equals stored value */ public boolean evaluate(T object) { if (equator != null) { return equator.equate(iValue, object); } else { return iValue.equals(object); } } /**'], ['this(object, new DefaultEquator<T>());', ''], ['this(object, null);', 'if (equator != null) { } else { return iValue.equals(object); }'], 'a/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java', 'b/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java']
['Collections-18', 1, 1, 1, 1, [' @Override public boolean retainAll(Collection<?> coll) { boolean result = collection.retainAll(coll); if (result == false) { return false; } if (collection.size() == 0) { setOrder.clear(); } else { for (Iterator<E> it = setOrder.iterator(); it.hasNext();) { if (!collection.contains(it.next())) { it.remove(); } } } return result; } @Override'], [' @Override public boolean retainAll(Collection<?> coll) { Set<Object> collectionRetainAll = new HashSet<Object>(); for (Iterator<?> it = coll.iterator(); it.hasNext();) { Object next = it.next(); if (collection.contains(next)) { collectionRetainAll.add(next); } } if (collectionRetainAll.size() == collection.size()) { return false; } if (collectionRetainAll.size() == 0) { clear(); } else { for (Iterator<E> it = iterator(); it.hasNext();) { if (!collectionRetainAll.contains(it.next())) { it.remove(); } } } return true; } @Override'], ['boolean result = collection.retainAll(coll); if (result == false) { if (collection.size() == 0) { setOrder.clear(); for (Iterator<E> it = setOrder.iterator(); it.hasNext();) { if (!collection.contains(it.next())) { return result;'], ['Set<Object> collectionRetainAll = new HashSet<Object>(); for (Iterator<?> it = coll.iterator(); it.hasNext();) { Object next = it.next(); if (collection.contains(next)) { collectionRetainAll.add(next); } } if (collectionRetainAll.size() == collection.size()) { if (collectionRetainAll.size() == 0) { clear(); for (Iterator<E> it = iterator(); it.hasNext();) { if (!collectionRetainAll.contains(it.next())) { return true;'], 'a/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java', 'b/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java']
['Collections-19', 1, 1, 1, 1, ["// the object is already in the uniq list // (and it hasn't been swapped with itself) super.remove(pos); // remove the duplicate by index } set.add(object); set.remove(removed); return removed; // return the item deleted by the set }"], ["// the object is already in the uniq list // (and it hasn't been swapped with itself) super.remove(pos); // remove the duplicate by index set.remove(removed); // remove the item deleted by the set } else if (pos == -1) { set.add(object); // add the new item to the unique set set.remove(removed); // remove the item deleted by the set } return removed; // return the item deleted by the set }"], ['set.add(object); set.remove(removed);'], ['set.remove(removed); // remove the item deleted by the set } else if (pos == -1) { set.add(object); // add the new item to the unique set set.remove(removed); // remove the item deleted by the set'], 'a/src/main/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/main/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-20', 1, 1, 1, 1, ['if (currentIndex == -1) { throw new IllegalStateException(); } if (nextIndex == currentIndex) { next = next.next(); parent.remove(currentIndex); } else { // remove() following next() parent.remove(currentIndex); nextIndex--; } // the AVL node referenced by next may have become stale after a remove // reset it now: will be retrieved by next call to next()/previous() via nextIndex current = null; currentIndex = -1; expectedModCount++;'], ['if (currentIndex == -1) { throw new IllegalStateException(); } parent.remove(currentIndex); if (nextIndex != currentIndex) { // remove() following next() nextIndex--; } // the AVL node referenced by next may have become stale after a remove // reset it now: will be retrieved by next call to next()/previous() via nextIndex next = null; current = null; currentIndex = -1; expectedModCount++;'], ['if (nextIndex == currentIndex) { next = next.next(); parent.remove(currentIndex); } else { parent.remove(currentIndex);'], ['parent.remove(currentIndex); if (nextIndex != currentIndex) { next = null;'], 'a/src/main/java/org/apache/commons/collections/list/TreeList.java', 'b/src/main/java/org/apache/commons/collections/list/TreeList.java']
['Collections-21', 2, 2, 2, 2, ['import java.util.ListIterator; import java.util.Set; import org.apache.commons.collections4.set.UnmodifiableSet; import org.apache.commons.collections4.iterators.AbstractIteratorDecorator; import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;', 'public List<E> subList(final int fromIndex, final int toIndex) { final List<E> superSubList = super.subList(fromIndex, toIndex); final Set<E> subSet = createSetBasedOnList(set, superSubList); return new SetUniqueList<E>(superSubList, subSet); } /**'], ['import java.util.ListIterator; import java.util.Set; import org.apache.commons.collections4.ListUtils; import org.apache.commons.collections4.set.UnmodifiableSet; import org.apache.commons.collections4.iterators.AbstractIteratorDecorator; import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;', 'public List<E> subList(final int fromIndex, final int toIndex) { final List<E> superSubList = super.subList(fromIndex, toIndex); final Set<E> subSet = createSetBasedOnList(set, superSubList); return ListUtils.unmodifiableList(new SetUniqueList<E>(superSubList, subSet)); } /**'], ['', 'return new SetUniqueList<E>(superSubList, subSet);'], ['import org.apache.commons.collections4.ListUtils;', 'return ListUtils.unmodifiableList(new SetUniqueList<E>(superSubList, subSet));'], 'a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java', 'b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java']
['Collections-22', 1, 1, 1, 1, ['*/ public void putAll(int index, final Map<? extends K, ? extends V> map) { for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) { final V old = put(index, entry.getKey(), entry.getValue()); if (old == null) { // The return value of put is null if the key did not exist OR the value was null // so it cannot be used to determine whether the key was added // if no key was replaced, increment the index index++; } else {'], ['*/ public void putAll(int index, final Map<? extends K, ? extends V> map) { for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) { final K key = entry.getKey(); final boolean contains = containsKey(key); // The return value of put is null if the key did not exist OR the value was null // so it cannot be used to determine whether the key was added put(index, entry.getKey(), entry.getValue()); if (!contains) { // if no key was replaced, increment the index index++; } else {'], ['final V old = put(index, entry.getKey(), entry.getValue()); if (old == null) {'], ['final K key = entry.getKey(); final boolean contains = containsKey(key); put(index, entry.getKey(), entry.getValue()); if (!contains) {'], 'a/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java', 'b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java']
['Collections-23', 1, 1, 1, 1, ['* @return a new unmodifiable trie * @throws IllegalArgumentException if trie is null */ public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) { return new UnmodifiableTrie<K, V>(trie); }'], ['* @return a new unmodifiable trie * @throws IllegalArgumentException if trie is null */ public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) { if (trie instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final Trie<K, V> tmpTrie = (Trie<K, V>) trie; return tmpTrie; } return new UnmodifiableTrie<K, V>(trie); }'], ['public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {'], ['public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) { if (trie instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final Trie<K, V> tmpTrie = (Trie<K, V>) trie; return tmpTrie; }'], 'a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java', 'b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java']
['Collections-24', 3, 3, 3, 3, ['import java.util.Iterator; import org.apache.commons.collections4.BoundedCollection; import org.apache.commons.collections4.iterators.UnmodifiableIterator; /**', '* @version $Id$ */ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E> implements BoundedCollection<E> { /** Serialization version */ private static final long serialVersionUID = -7112672385450340330L;', '* @since 4.0 */ public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) { return new UnmodifiableBoundedCollection<E>(coll); }'], ['import java.util.Iterator; import org.apache.commons.collections4.BoundedCollection; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.iterators.UnmodifiableIterator; /**', '* @version $Id$ */ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E> implements BoundedCollection<E>, Unmodifiable { /** Serialization version */ private static final long serialVersionUID = -7112672385450340330L;', '* @since 4.0 */ public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) { if (coll instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll; return tmpColl; } return new UnmodifiableBoundedCollection<E>(coll); }'], ['', 'implements BoundedCollection<E> {', ''], ['import org.apache.commons.collections4.Unmodifiable;', 'implements BoundedCollection<E>, Unmodifiable {', 'if (coll instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll; return tmpColl; }'], 'a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java', 'b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java']
['Collections-25', 3, 3, 3, 3, ['public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) { return new CollatingIterator<E>(comparator, iterator1, iterator2); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) { return new CollatingIterator<E>(comparator, iterators); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) { return new CollatingIterator<E>(comparator, iterators); } // Object Graph'], ['public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) { @SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterator1, iterator2); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) { @SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) { @SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators); } // Object Graph'], ['return new CollatingIterator<E>(comparator, iterator1, iterator2);', 'return new CollatingIterator<E>(comparator, iterators);', 'return new CollatingIterator<E>(comparator, iterators);'], ['@SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterator1, iterator2);', '@SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators);', '@SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators);'], 'a/src/main/java/org/apache/commons/collections4/IteratorUtils.java', 'b/src/main/java/org/apache/commons/collections4/IteratorUtils.java']
['Collections-26', 1, 1, 1, 1, ['* only stable for the same process). * @return the instance with recalculated hash code */ private Object readResolve() { calculateHashCode(keys); return this; }'], ['* only stable for the same process). * @return the instance with recalculated hash code */ protected Object readResolve() { calculateHashCode(keys); return this; }'], ['private Object readResolve() {'], ['protected Object readResolve() {'], 'a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java', 'b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java']
['Collections-27', 0, 1, 1, 1, [], ['} } private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } } } }'], [''], ['private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } }'], 'a/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java', 'b/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java']
['Collections-28', 1, 1, 1, 1, ['return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } } /**'], ['return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } @Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } } } /**'], [''], ['@Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } }'], 'a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java', 'b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java']
['JacksonDatabind-1', 1, 1, 1, 1, ['} else { // can NOT suppress entries in tabular output jgen.writeNull(); } } // otherwise find serializer to use JsonSerializer<Object> ser = _serializer;'], ['} else { // can NOT suppress entries in tabular output jgen.writeNull(); } return; } // otherwise find serializer to use JsonSerializer<Object> ser = _serializer;'], [''], ['return;'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java']
['JacksonDatabind-2', 1, 1, 1, 1, ['@Override public void writeObject(Object value) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); } @Override public void writeTree(TreeNode node) throws IOException { // as with \'writeObject()\', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } /*'], ['@Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } else if (_objectCodec == null) { /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { // as with \'writeObject()\', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } /*'], [''], ['if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { return; } else if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } if (node == null) { writeNull(); return; } if (_objectCodec == null) { } else { _objectCodec.writeTree(this, node); }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-3', 2, 2, 2, 2, ['if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); }', ' while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt); if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;'], ["if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = null; // since we have established that '_elementDeserializer == null' earlier } else { value = _parseString(jp, ctxt); }", ' while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt); if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;'], ['value = _elementDeserializer.getNullValue();', 'String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);'], ["value = null; // since we have established that '_elementDeserializer == null' earlier", 'String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java']
['JacksonDatabind-4', 4, 4, 4, 4, ['int ix = 0; JsonToken t; while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value;', '} chunk[ix++] = value; } // note: pass String.class, not String[].class, as we need element type for error info String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;', 'int ix = 0; JsonToken t; while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);', '} chunk[ix++] = value; } // note: pass String.class, not String[].class, as we need element type for error info String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;'], ['int ix = 0; JsonToken t; try { while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value;', '} chunk[ix++] = value; } } catch (Exception e) { // note: pass String.class, not String[].class, as we need element type for error info throw JsonMappingException.wrapWithPath(e, String.class, ix); } String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;', 'int ix = 0; JsonToken t; try { while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);', '} chunk[ix++] = value; } } catch (Exception e) { // note: pass String.class, not String[].class, as we need element type for error info throw JsonMappingException.wrapWithPath(e, String.class, ix); } String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;'], ['', '', '', ''], ['try {', '} catch (Exception e) { throw JsonMappingException.wrapWithPath(e, String.class, ix); }', 'try {', '} catch (Exception e) { throw JsonMappingException.wrapWithPath(e, String.class, ix); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java']
['JacksonDatabind-5', 1, 1, 1, 1, ['*/ } else { // Well, or, as per [Issue#515], multi-level merge within mixins... mixIns.add(_constructMethod(m)); } } }'], ['*/ } else { // Well, or, as per [Issue#515], multi-level merge within mixins... am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { mixIns.add(_constructMethod(m)); } } } }'], [''], ['am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java']
['JacksonDatabind-6', 2, 2, 2, 2, ['// Milliseconds partial or missing; and even seconds are optional len = dateStr.length(); // remove \'T\', \'+\'/\'-\' and 4-digit timezone-offset c = dateStr.charAt(len-9); if (Character.isDigit(c)) { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-5, ".000"); dateStr = sb.toString(); } df = _formatISO8601;', 'StringBuilder sb = new StringBuilder(dateStr); // And possible also millisecond part if missing int timeLen = len - dateStr.lastIndexOf(\'T\') - 1; if (timeLen <= 8) { sb.append(".000"); } sb.append(\'Z\'); dateStr = sb.toString();'], ['// Milliseconds partial or missing; and even seconds are optional len = dateStr.length(); // remove \'T\', \'+\'/\'-\' and 4-digit timezone-offset int timeLen = len - dateStr.lastIndexOf(\'T\') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, \'0\'); break; case 10: sb.insert(offset, "00"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, "000"); break; case 8: sb.insert(offset, ".000"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let\'s allow sb.insert(offset, "00.000"); case 5: // is legal to omit seconds sb.insert(offset, ":00.000"); } dateStr = sb.toString(); } df = _formatISO8601;', 'StringBuilder sb = new StringBuilder(dateStr); // And possible also millisecond part if missing int timeLen = len - dateStr.lastIndexOf(\'T\') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append(\'0\'); case 10: sb.append(\'0\'); case 9: sb.append(\'0\'); break; default: sb.append(".000"); } } sb.append(\'Z\'); dateStr = sb.toString();'], ['c = dateStr.charAt(len-9); if (Character.isDigit(c)) { sb.insert(len-5, ".000");', 'if (timeLen <= 8) {'], ['int timeLen = len - dateStr.lastIndexOf(\'T\') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset switch (timeLen) { case 11: sb.insert(offset, \'0\'); break; case 10: sb.insert(offset, "00"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, "000"); break; case 8: sb.insert(offset, ".000"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let\'s allow sb.insert(offset, "00.000"); case 5: // is legal to omit seconds sb.insert(offset, ":00.000"); }', "if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: }"], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-7', 1, 1, 1, 1, ['*/ public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { copyCurrentStructure(jp); /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ return this; }'], ['*/ public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(jp); return this; } /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException("Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got "+t); } writeEndObject(); return this; }'], [''], ['if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException("Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got "+t); } writeEndObject();'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-8', 2, 2, 2, 2, ['AnnotatedWithParams oldOne = _creators[typeIndex]; // already had an explicitly marked one? if (oldOne != null) { if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated', 'return; } // both explicit: verify // otherwise only verify if neither explicitly annotated. } // one more thing: ok to override in sub-class if (oldOne.getClass() == newOne.getClass()) { // [databind#667]: avoid one particular class of bogus problems throw new IllegalArgumentException("Conflicting "+TYPE_DESCS[typeIndex] +" creators: already had explicitly marked "+oldOne+", encountered "+newOne); // otherwise, which one to choose? // new type more generic, use old // new type more specific, use it } }'], ['AnnotatedWithParams oldOne = _creators[typeIndex]; // already had an explicitly marked one? if (oldOne != null) { boolean verify; if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated', 'return; } // both explicit: verify verify = true; } else { // otherwise only verify if neither explicitly annotated. verify = !explicit; } // one more thing: ok to override in sub-class if (verify && (oldOne.getClass() == newOne.getClass())) { // [databind#667]: avoid one particular class of bogus problems Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { throw new IllegalArgumentException("Conflicting "+TYPE_DESCS[typeIndex] +" creators: already had explicitly marked "+oldOne+", encountered "+newOne); } // otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; } // new type more specific, use it } }'], ['', 'if (oldOne.getClass() == newOne.getClass()) {'], ['boolean verify;', 'verify = true; } else { verify = !explicit; if (verify && (oldOne.getClass() == newOne.getClass())) { Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { } if (newType.isAssignableFrom(oldType)) { return; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java']
['JacksonDatabind-9', 1, 1, 1, 1, ['@Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { String str; if (value instanceof Date) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else { str = value.toString(); }'], ['@Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { String str; Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else if (cls == Class.class) { str = ((Class<?>) value).getName(); } else { str = value.toString(); }'], ['if (value instanceof Date) {'], ['Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { } else if (cls == Class.class) { str = ((Class<?>) value).getName();'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java']
['JacksonDatabind-10', 5, 5, 5, 5, ['*/ protected final AnnotatedMember _accessor; protected MapSerializer _mapSerializer; @SuppressWarnings("unchecked") public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) { _accessor = accessor; _property = property; _mapSerializer = (MapSerializer) serializer; } public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)', '_mapSerializer.serializeFields((Map<?,?>) value, gen, provider); return; } } /**', 'return; } // ... not sure how custom handler would do it } // Note: NOT part of ResolvableSerializer...', 'public void resolve(SerializerProvider provider) throws JsonMappingException { // 05-Sep-2013, tatu: I _think_ this can be considered a primary property... _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property); } }', "TypeSerializer typeSer = createTypeSerializer(config, valueType); // last 2 nulls; don't know key, value serializers (yet) // 23-Feb-2015, tatu: As per [#705], need to support custom serializers MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null); // TODO: support '@JsonIgnoreProperties' with any setter? // TODO: can we find full PropertyName? PropertyName name = new PropertyName(anyGetter.getName()); BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,"], ['*/ protected final AnnotatedMember _accessor; protected JsonSerializer<Object> _serializer; protected MapSerializer _mapSerializer; @SuppressWarnings("unchecked") public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, JsonSerializer<?> serializer) { _accessor = accessor; _property = property; _serializer = (JsonSerializer<Object>) serializer; if (serializer instanceof MapSerializer) { _mapSerializer = (MapSerializer) serializer; } } public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)', '_mapSerializer.serializeFields((Map<?,?>) value, gen, provider); return; } _serializer.serialize(value, gen, provider); } /**', 'return; } // ... not sure how custom handler would do it _serializer.serialize(value, gen, provider); } // Note: NOT part of ResolvableSerializer...', 'public void resolve(SerializerProvider provider) throws JsonMappingException { // 05-Sep-2013, tatu: I _think_ this can be considered a primary property... if (_serializer instanceof ContextualSerializer) { JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property); _serializer = (JsonSerializer<Object>) ser; if (ser instanceof MapSerializer) { _mapSerializer = (MapSerializer) ser; } } } }', "TypeSerializer typeSer = createTypeSerializer(config, valueType); // last 2 nulls; don't know key, value serializers (yet) // 23-Feb-2015, tatu: As per [#705], need to support custom serializers JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter); if (anySer == null) { // TODO: support '@JsonIgnoreProperties' with any setter? anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping, typeSer, null, null, /*filterId*/ null); } // TODO: can we find full PropertyName? PropertyName name = new PropertyName(anyGetter.getName()); BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,"], ['AnnotatedMember accessor, MapSerializer serializer)', '', '', '_mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);', 'MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);'], ['protected JsonSerializer<Object> _serializer; AnnotatedMember accessor, JsonSerializer<?> serializer) _serializer = (JsonSerializer<Object>) serializer; if (serializer instanceof MapSerializer) { }', '_serializer.serialize(value, gen, provider);', '_serializer.serialize(value, gen, provider);', 'if (_serializer instanceof ContextualSerializer) { JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property); _serializer = (JsonSerializer<Object>) ser; if (ser instanceof MapSerializer) { _mapSerializer = (MapSerializer) ser; } }', 'JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter); if (anySer == null) { anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping, typeSer, null, null, /*filterId*/ null); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java']
['JacksonDatabind-11', 1, 1, 1, 1, ["// 19-Mar-2015: Without context, all we can check are bounds. if (context == null) { // And to prevent infinite loops, now need this: return _unknownType(); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name); if (actualType != null) { return actualType; }"], ["// 19-Mar-2015: Without context, all we can check are bounds. if (context == null) { // And to prevent infinite loops, now need this: context = new TypeBindings(this, (Class<?>) null); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name, false); if (actualType != null) { return actualType; }"], ['return _unknownType(); JavaType actualType = context.findType(name);'], ['context = new TypeBindings(this, (Class<?>) null); JavaType actualType = context.findType(name, false);'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-12', 1, 1, 1, 1, ['/* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }'], ['/* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null) && (_ignorableProperties == null); }'], ['return (_valueTypeDeserializer == null)'], ['return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null)'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java']
['JacksonDatabind-13', 2, 2, 2, 2, ["/* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how * missing id already works. */ final ObjectIdGenerator.IdKey key = gen.key(id);", '* will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance);'], ["/* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how * missing id already works. */ if (id == null) { return null; } final ObjectIdGenerator.IdKey key = gen.key(id);", '* will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ if (id == null) { return null; } ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance);'], ['', ''], ['if (id == null) { return null; }', 'if (id == null) { return null; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java']
['JacksonDatabind-14', 2, 2, 2, 2, ['result = NullNode.instance; } else { DeserializationContext ctxt = createDeserializationContext(jp, _config); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); if (_unwrapRoot) { result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); } else {', '/** * @since 2.6 */ // Nope: need to ask provider to resolve it /** * Method called to locate deserializer ahead of time, if permitted'], ['result = NullNode.instance; } else { DeserializationContext ctxt = createDeserializationContext(jp, _config); JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt); if (_unwrapRoot) { result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); } else {', '/** * @since 2.6 */ protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE); if (deser == null) { // Nope: need to ask provider to resolve it deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE); if (deser == null) { // can this happen? throw new JsonMappingException("Can not find a deserializer for type "+JSON_NODE_TYPE); } _rootDeserializers.put(JSON_NODE_TYPE, deser); } return deser; } /** * Method called to locate deserializer ahead of time, if permitted'], ['JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);', ''], ['JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);', 'protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE); if (deser == null) { deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE); if (deser == null) { // can this happen? throw new JsonMappingException("Can not find a deserializer for type "+JSON_NODE_TYPE); } _rootDeserializers.put(JSON_NODE_TYPE, deser); } return deser; }'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java']
['JacksonDatabind-15', 11, 11, 11, 11, ['* * @since 2.5 */ /** * Accessor for checking whether handlers for dealing with values of', 'ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); } // [databind#731]: Should skip if nominally java.lang.Object if (ser == null) { ser = _createSerializer2(prov, delegateType, beanDesc, true); } return new StdDelegatingSerializer(conv, delegateType, ser);', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); return new StdDelegatingSerializer(conv, delegateType, ser); } }', '/* 02-Apr-2015, tatu: For "dynamic case", where type is only specified as * java.lang.Object (or missing generic), [databind#731] */ delSer = provider.findValueSerializer(delegateType); } if (delSer instanceof ContextualSerializer) { delSer = provider.handleSecondaryContextualization(delSer, property); } return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer); } /*', 'return; } // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup _delegateSerializer.serialize(delegateValue, gen, provider); } @Override', "* let's give it a chance? */ Object delegateValue = convertValue(value); _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer); } @Override", 'public boolean isEmpty(Object value) { Object delegateValue = convertValue(value); return _delegateSerializer.isEmpty(delegateValue); }', 'public boolean isEmpty(SerializerProvider prov, Object value) { Object delegateValue = convertValue(value); return _delegateSerializer.isEmpty(prov, delegateValue); }', '* properly... but for now, try this: */ // 02-Apr-2015, tatu: For dynamic case, very little we can do _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint); } /*', '* * @since 2.6 */ // NOTE: will NOT call contextualization }', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object if (existingSerializer == null) { existingSerializer = provider.findValueSerializer(delegateType); } return new StdDelegatingSerializer(conv, delegateType, existingSerializer);'], ['* * @since 2.5 */ public final boolean isJavaLangObject() { return _class == Object.class; } /** * Accessor for checking whether handlers for dealing with values of', 'ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); } // [databind#731]: Should skip if nominally java.lang.Object if (ser == null && !delegateType.isJavaLangObject()) { ser = _createSerializer2(prov, delegateType, beanDesc, true); } return new StdDelegatingSerializer(conv, delegateType, ser);', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null : provider.findValueSerializer(delegateType, prop); return new StdDelegatingSerializer(conv, delegateType, ser); } }', '/* 02-Apr-2015, tatu: For "dynamic case", where type is only specified as * java.lang.Object (or missing generic), [databind#731] */ if (!delegateType.isJavaLangObject()) { delSer = provider.findValueSerializer(delegateType); } } if (delSer instanceof ContextualSerializer) { delSer = provider.handleSecondaryContextualization(delSer, property); } if (delSer == _delegateSerializer && delegateType == _delegateType) { return this; } return withDelegate(_converter, delegateType, delSer); } /*', 'return; } // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(delegateValue, provider); } ser.serialize(delegateValue, gen, provider); } @Override', "* let's give it a chance? */ Object delegateValue = convertValue(value); JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(value, provider); } ser.serializeWithType(delegateValue, gen, provider, typeSer); } @Override", 'public boolean isEmpty(Object value) { Object delegateValue = convertValue(value); if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); } return _delegateSerializer.isEmpty(delegateValue); }', 'public boolean isEmpty(SerializerProvider prov, Object value) { Object delegateValue = convertValue(value); if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); } return _delegateSerializer.isEmpty(prov, delegateValue); }', '* properly... but for now, try this: */ // 02-Apr-2015, tatu: For dynamic case, very little we can do if (_delegateSerializer != null) { _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint); } } /*', '* * @since 2.6 */ protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers) throws JsonMappingException { // NOTE: will NOT call contextualization return serializers.findValueSerializer(value.getClass()); } }', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) { existingSerializer = provider.findValueSerializer(delegateType); } return new StdDelegatingSerializer(conv, delegateType, existingSerializer);'], ['', 'if (ser == null) {', 'JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);', 'return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);', '_delegateSerializer.serialize(delegateValue, gen, provider);', '_delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);', '', '', '_delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);', '', 'if (existingSerializer == null) {'], ['public final boolean isJavaLangObject() { return _class == Object.class; }', 'if (ser == null && !delegateType.isJavaLangObject()) {', 'JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null : provider.findValueSerializer(delegateType, prop);', 'if (!delegateType.isJavaLangObject()) { } if (delSer == _delegateSerializer && delegateType == _delegateType) { return this; } return withDelegate(_converter, delegateType, delSer);', 'JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(delegateValue, provider); } ser.serialize(delegateValue, gen, provider);', 'JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(value, provider); } ser.serializeWithType(delegateValue, gen, provider, typeSer);', 'if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); }', 'if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); }', 'if (_delegateSerializer != null) { _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint); }', 'protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers) throws JsonMappingException { return serializers.findValueSerializer(value.getClass()); }', 'if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java']
['JacksonDatabind-16', 1, 1, 1, 1, ['_annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); return (previous != null) && previous.equals(ann); } }'], ['_annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); return (previous == null) || !previous.equals(ann); } }'], ['return (previous != null) && previous.equals(ann);'], ['return (previous == null) || !previous.equals(ann);'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java']
['JacksonDatabind-17', 1, 1, 1, 1, ['return (t.getRawClass() == Object.class) || (!t.isConcrete() // [databind#88] Should not apply to JSON tree models: || TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) {'], ['return (t.getRawClass() == Object.class) || (!t.isConcrete() // [databind#88] Should not apply to JSON tree models: && !TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) {'], ['|| TreeNode.class.isAssignableFrom(t.getRawClass()));'], ['&& !TreeNode.class.isAssignableFrom(t.getRawClass()));'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java']
['JacksonDatabind-18', 9, 9, 9, 9, ['/** * State in which iterator is closed */ /** * State in which value read failed */ /** * State in which no recovery is needed, but "hasNextValue()" needs * to be called first */ /** * State in which "hasNextValue()" has been succesfully called * and deserializer can be called to fetch value */ /* /**********************************************************', '* as not <code>null</code> but set as <code>null</null> when * iterator is closed, to denote closing. */ protected JsonParser _parser; /** * Context to resynchronize to, in case an exception is encountered * but caller wants to try to read more elements. */ /** * If not null, "value to update" instead of creating a new instance', '/** * State of the iterator */ protected boolean _hasNextChecked; /* /**********************************************************', "* and if not, caller needs to hand us JsonParser instead, pointing to * the first token of the first element. */ if (managedParser && (p != null) && p.isExpectedStartArrayToken()) { // If pointing to START_ARRAY, context should be that ARRAY p.clearCurrentToken(); // regardless, recovery context should be whatever context we have now, // with sole exception of pointing to a start marker, in which case it's // the parent } }", ' @Override public void close() throws IOException { if (_parser != null) { _parser.close(); } } /*', "*/ public boolean hasNextValue() throws IOException { if (_parser == null) { return false; // fall-through } if (!_hasNextChecked) { JsonToken t = _parser.getCurrentToken(); _hasNextChecked = true; if (t == null) { // un-initialized or cleared; find next t = _parser.nextToken(); // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token). if (t == null || t == JsonToken.END_ARRAY) { JsonParser jp = _parser; _parser = null; if (_closeParser) { jp.close(); } return false; } } // fall through } return true;", ' public T nextValue() throws IOException { if (!_hasNextChecked) { if (!hasNextValue()) { return _throwNoSuchElement(); } } if (_parser == null) { return _throwNoSuchElement(); } _hasNextChecked = false; try { T value; if (_updatedValue == null) {', '_deserializer.deserialize(_parser, _context, _updatedValue); value = _updatedValue; } return value; } finally { /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no * matter what, to avoid infinite loop for certain failure cases. * For 2.6 need to improve further.', '/********************************************************** */ // First, a quick check to see if we might have been lucky and no re-sync needed protected <R> R _throwNoSuchElement() { throw new NoSuchElementException();'], ['/** * State in which iterator is closed */ protected final static int STATE_CLOSED = 0; /** * State in which value read failed */ protected final static int STATE_NEED_RESYNC = 1; /** * State in which no recovery is needed, but "hasNextValue()" needs * to be called first */ protected final static int STATE_MAY_HAVE_VALUE = 2; /** * State in which "hasNextValue()" has been succesfully called * and deserializer can be called to fetch value */ protected final static int STATE_HAS_VALUE = 3; /* /**********************************************************', '* as not <code>null</code> but set as <code>null</null> when * iterator is closed, to denote closing. */ protected final JsonParser _parser; /** * Context to resynchronize to, in case an exception is encountered * but caller wants to try to read more elements. */ protected final JsonStreamContext _seqContext; /** * If not null, "value to update" instead of creating a new instance', '/** * State of the iterator */ protected int _state; /* /**********************************************************', "* and if not, caller needs to hand us JsonParser instead, pointing to * the first token of the first element. */ if (p == null) { // can this occur? _seqContext = null; _state = STATE_CLOSED; } else { JsonStreamContext sctxt = p.getParsingContext(); if (managedParser && p.isExpectedStartArrayToken()) { // If pointing to START_ARRAY, context should be that ARRAY p.clearCurrentToken(); } else { // regardless, recovery context should be whatever context we have now, // with sole exception of pointing to a start marker, in which case it's // the parent JsonToken t = p.getCurrentToken(); if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) { sctxt = sctxt.getParent(); } } _seqContext = sctxt; _state = STATE_MAY_HAVE_VALUE; } }", ' @Override public void close() throws IOException { if (_state != STATE_CLOSED) { _state = STATE_CLOSED; if (_parser != null) { _parser.close(); } } } /*', "*/ public boolean hasNextValue() throws IOException { switch (_state) { case STATE_CLOSED: return false; case STATE_NEED_RESYNC: _resync(); // fall-through case STATE_MAY_HAVE_VALUE: JsonToken t = _parser.getCurrentToken(); if (t == null) { // un-initialized or cleared; find next t = _parser.nextToken(); // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token). if (t == null || t == JsonToken.END_ARRAY) { _state = STATE_CLOSED; if (_closeParser && (_parser != null)) { _parser.close(); } return false; } } _state = STATE_HAS_VALUE; return true; case STATE_HAS_VALUE: // fall through } return true;", ' public T nextValue() throws IOException { switch (_state) { case STATE_CLOSED: return _throwNoSuchElement(); case STATE_NEED_RESYNC: // fall-through, will do re-sync case STATE_MAY_HAVE_VALUE: if (!hasNextValue()) { return _throwNoSuchElement(); } break; case STATE_HAS_VALUE: break; } int nextState = STATE_NEED_RESYNC; try { T value; if (_updatedValue == null) {', '_deserializer.deserialize(_parser, _context, _updatedValue); value = _updatedValue; } nextState = STATE_MAY_HAVE_VALUE; return value; } finally { _state = nextState; /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no * matter what, to avoid infinite loop for certain failure cases. * For 2.6 need to improve further.', '/********************************************************** */ protected void _resync() throws IOException { final JsonParser p = _parser; // First, a quick check to see if we might have been lucky and no re-sync needed if (p.getParsingContext() == _seqContext) { return; } while (true) { JsonToken t = p.nextToken(); if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) { if (p.getParsingContext() == _seqContext) { p.clearCurrentToken(); return; } } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) { p.skipChildren(); } else if (t == null) { return; } } } protected <R> R _throwNoSuchElement() { throw new NoSuchElementException();'], ['', 'protected JsonParser _parser;', 'protected boolean _hasNextChecked;', 'if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {', '', 'if (_parser == null) { } if (!_hasNextChecked) { _hasNextChecked = true; JsonParser jp = _parser; _parser = null; if (_closeParser) { jp.close();', 'if (!_hasNextChecked) { if (_parser == null) { return _throwNoSuchElement(); } _hasNextChecked = false;', '', ''], ['protected final static int STATE_CLOSED = 0; protected final static int STATE_NEED_RESYNC = 1; protected final static int STATE_MAY_HAVE_VALUE = 2; protected final static int STATE_HAS_VALUE = 3;', 'protected final JsonParser _parser; protected final JsonStreamContext _seqContext;', 'protected int _state;', 'if (p == null) { // can this occur? _seqContext = null; _state = STATE_CLOSED; } else { JsonStreamContext sctxt = p.getParsingContext(); if (managedParser && p.isExpectedStartArrayToken()) { } else { JsonToken t = p.getCurrentToken(); if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) { sctxt = sctxt.getParent(); } } _seqContext = sctxt; _state = STATE_MAY_HAVE_VALUE;', 'if (_state != STATE_CLOSED) { _state = STATE_CLOSED; }', 'switch (_state) { case STATE_CLOSED: case STATE_NEED_RESYNC: _resync(); case STATE_MAY_HAVE_VALUE: _state = STATE_CLOSED; if (_closeParser && (_parser != null)) { _parser.close(); _state = STATE_HAS_VALUE; return true; case STATE_HAS_VALUE:', 'switch (_state) { case STATE_CLOSED: return _throwNoSuchElement(); case STATE_NEED_RESYNC: // fall-through, will do re-sync case STATE_MAY_HAVE_VALUE: break; case STATE_HAS_VALUE: break; int nextState = STATE_NEED_RESYNC;', 'nextState = STATE_MAY_HAVE_VALUE; _state = nextState;', 'protected void _resync() throws IOException { final JsonParser p = _parser; if (p.getParsingContext() == _seqContext) { return; } while (true) { JsonToken t = p.nextToken(); if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) { if (p.getParsingContext() == _seqContext) { p.clearCurrentToken(); return; } } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) { p.skipChildren(); } else if (t == null) { return; } } }'], 'a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java', 'b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java']
['JacksonDatabind-19', 1, 1, 1, 1, ['private JavaType _mapType(Class<?> rawClass) { // 28-May-2015, tatu: Properties are special, as per [databind#810] JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types ("raw") if (typeParams == null) {'], ['private JavaType _mapType(Class<?> rawClass) { // 28-May-2015, tatu: Properties are special, as per [databind#810] if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); } JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types ("raw") if (typeParams == null) {'], [''], ['if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-20', 2, 2, 2, 2, ['package com.fasterxml.jackson.databind.node; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.SerializerProvider;', '* * @since 2.1 */ public JsonNode setAll(Map<String,? extends JsonNode> properties) { for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {'], ['package com.fasterxml.jackson.databind.node; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.SerializerProvider;', '* * @since 2.1 */ @JsonIgnore // work-around for [databind#815] public JsonNode setAll(Map<String,? extends JsonNode> properties) { for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {'], ['', ''], ['import com.fasterxml.jackson.annotation.JsonIgnore;', '@JsonIgnore // work-around for [databind#815]'], 'a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java']
['JacksonDatabind-21', 2, 2, 2, 2, ['package com.fasterxml.jackson.databind.introspect; import java.lang.annotation.Annotation; import java.util.*; import com.fasterxml.jackson.annotation.*;', '* Since 2.6, we have supported use of {@link JsonProperty} for specifying * explicit serialized name */ // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming. // Unfortunately can not quite use standard AnnotatedClass here (due to various // reasons, including odd representation JVM uses); has to do for now // We know that values are actually static fields with matching name so: // no such field, or access; neither which we can do much about /* /**********************************************************'], ['package com.fasterxml.jackson.databind.introspect; import java.lang.annotation.Annotation; import java.lang.reflect.Field; import java.util.*; import com.fasterxml.jackson.annotation.*;', '* Since 2.6, we have supported use of {@link JsonProperty} for specifying * explicit serialized name */ @Override public String findEnumValue(Enum<?> value) { // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming. // Unfortunately can not quite use standard AnnotatedClass here (due to various // reasons, including odd representation JVM uses); has to do for now try { // We know that values are actually static fields with matching name so: Field f = value.getClass().getField(value.name()); if (f != null) { JsonProperty prop = f.getAnnotation(JsonProperty.class); String n = prop.value(); if (n != null && !n.isEmpty()) { return n; } } } catch (Exception e) { // no such field, or access; neither which we can do much about } return value.name(); } /* /**********************************************************'], ['', ''], ['import java.lang.reflect.Field;', '@Override public String findEnumValue(Enum<?> value) { try { Field f = value.getClass().getField(value.name()); if (f != null) { JsonProperty prop = f.getAnnotation(JsonProperty.class); String n = prop.value(); if (n != null && !n.isEmpty()) { return n; } } } catch (Exception e) { } return value.name(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java']
['JacksonDatabind-22', 12, 12, 12, 12, ['*/ JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations', 'for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;', '* * @since 2.1 */ protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; // Order of lookups: // 1. Custom serializers', '} if (ser == null) { // We may also want to use serialize Collections "as beans", if (and only if) // this is specified with `@JsonFormat(shape=Object)` JsonFormat.Value format = beanDesc.findExpectedFormat(null);', 'if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } }', '* Helper method that handles configuration details when constructing serializers for * {@link java.util.Map} types. */ protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; // Order of lookups:', 'if (ser != null) { break; } } if (ser == null) { // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer /* if (EnumMap.class.isAssignableFrom(type.getRawClass())', '} ser = mapSer; } // [databind#120]: Allow post-processing if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {', '* Helper method that handles configuration details when constructing serializers for * <code>Object[]</code> (and subtypes, except for String). */ protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)', '// types can not be annotated (in theory I guess we could have mix-ins but... ?) // so we need not do primary annotation lookup here. // So all we need is (1) Custom, (2) Default array serializers JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom', 'JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); if (ser != null) { return ser; } final SerializationConfig config = prov.getConfig(); // Container types differ from non-container types', '} // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6, // this call was BEFORE custom serializer lookup, which was wrong. } if (ser == null) {'], ['*/ JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations JsonSerializer<?> ser = null; MapLikeType mlType = (MapLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } } return ser; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(prov, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations', 'for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } } return ser; } if (type.isArrayType()) { return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;', '* * @since 2.1 */ protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { SerializationConfig config = prov.getConfig(); JsonSerializer<?> ser = null; // Order of lookups: // 1. Custom serializers', '} if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) { // We may also want to use serialize Collections "as beans", if (and only if) // this is specified with `@JsonFormat(shape=Object)` JsonFormat.Value format = beanDesc.findExpectedFormat(null);', 'if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } }', '* Helper method that handles configuration details when constructing serializers for * {@link java.util.Map} types. */ protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); JsonSerializer<?> ser = null; // Order of lookups:', 'if (ser != null) { break; } } if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) { // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer /* if (EnumMap.class.isAssignableFrom(type.getRawClass())', '} ser = mapSer; } } // [databind#120]: Allow post-processing if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {', '* Helper method that handles configuration details when constructing serializers for * <code>Object[]</code> (and subtypes, except for String). */ protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)', '// types can not be annotated (in theory I guess we could have mix-ins but... ?) // so we need not do primary annotation lookup here. // So all we need is (1) Custom, (2) Default array serializers SerializationConfig config = prov.getConfig(); JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom', 'JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JsonSerializer<?> ser = null; final SerializationConfig config = prov.getConfig(); // Container types differ from non-container types', '} // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6, // this call was BEFORE custom serializer lookup, which was wrong. if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); } } if (ser == null) {'], ['return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, MapLikeType mlType = (MapLikeType) type; } return ser; return null; return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping,', '} return ser; return null; return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,', 'protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,', '', '', 'protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,', '', '', 'protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,', '', 'JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); if (ser != null) { return ser; }', ''], ['return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping, MapLikeType mlType = (MapLikeType) type; if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } return ser; return buildCollectionSerializer(prov, (CollectionType) clt, beanDesc, staticTyping,', 'if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } return ser; return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,', 'protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, SerializationConfig config = prov.getConfig();', 'ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) {', '}', 'protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, final SerializationConfig config = prov.getConfig();', 'ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) {', '}', 'protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,', 'SerializationConfig config = prov.getConfig();', 'JsonSerializer<?> ser = null;', 'if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java']
['JacksonDatabind-23', 7, 7, 7, 7, ['protected abstract static class Base<T> extends StdScalarSerializer<T> implements ContextualSerializer { protected final JsonParser.NumberType _numberType; protected final String _schemaType;', '@JacksonStdImpl public final static class ShortSerializer extends Base<Short> { final static ShortSerializer instance = new ShortSerializer(); public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, "number"); } @Override public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {', 'serialize(value, gen, provider); } } /**', 'super(Number.class, JsonParser.NumberType.INT, "integer"); } @Override public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class LongSerializer extends Base<Object> { final static LongSerializer instance = new LongSerializer(); public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, "number"); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class FloatSerializer extends Base<Object> { final static FloatSerializer instance = new FloatSerializer(); public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, "number"); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class DoubleSerializer extends Base<Object> { final static DoubleSerializer instance = new DoubleSerializer(); public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, "number"); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {'], ['protected abstract static class Base<T> extends StdScalarSerializer<T> implements ContextualSerializer { protected final static Integer EMPTY_INTEGER = Integer.valueOf(0); protected final JsonParser.NumberType _numberType; protected final String _schemaType;', '@JacksonStdImpl public final static class ShortSerializer extends Base<Short> { private final static Short EMPTY = (short) 0; final static ShortSerializer instance = new ShortSerializer(); public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Short value) { return EMPTY.equals(value); } @Override public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {', 'serialize(value, gen, provider); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY_INTEGER.equals(value); } } /**', 'super(Number.class, JsonParser.NumberType.INT, "integer"); } @Override public boolean isEmpty(SerializerProvider prov, Number value) { return value.intValue() == 0; } @Override public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class LongSerializer extends Base<Object> { private final static Long EMPTY = 0L; final static LongSerializer instance = new LongSerializer(); public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class FloatSerializer extends Base<Object> { private final static Float EMPTY = 0f; final static FloatSerializer instance = new FloatSerializer(); public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class DoubleSerializer extends Base<Object> { private final static Double EMPTY = 0d; final static DoubleSerializer instance = new DoubleSerializer(); public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {'], ['', '', '', '', '', '', ''], ['protected final static Integer EMPTY_INTEGER = Integer.valueOf(0);', 'private final static Short EMPTY = (short) 0; @Override public boolean isEmpty(SerializerProvider prov, Short value) { return EMPTY.equals(value); }', '@Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY_INTEGER.equals(value); }', '@Override public boolean isEmpty(SerializerProvider prov, Number value) { return value.intValue() == 0; }', 'private final static Long EMPTY = 0L; @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); }', 'private final static Float EMPTY = 0f; @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); }', 'private final static Double EMPTY = 0d; @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java']
['JacksonDatabind-24', 1, 1, 1, 1, ['if (_dateFormat == df) { return this; } TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); } public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {'], ['if (_dateFormat == df) { return this; } return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64); } public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {'], ['TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); tz, _defaultBase64);'], ['_timeZone, _defaultBase64);'], 'a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java', 'b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java']
['JacksonDatabind-25', 4, 4, 4, 4, ['Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = (T) type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', 'Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', '* important for some reason? * Disabling the check will break 2 Enum-related tests. */ type = _baseType.narrowBy(type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); }', 'return null; } // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory return type.narrowBy(dst); }'], ['Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', 'Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = ctxt.getTypeFactory().constructSpecializedType(type, subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', '* important for some reason? * Disabling the check will break 2 Enum-related tests. */ type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); }', 'return null; } // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory return config.getTypeFactory().constructSpecializedType(type, dst); }'], ['type = (T) type.narrowBy(subclass);', 'type = type.narrowBy(subclass);', 'type = _baseType.narrowBy(type.getRawClass());', 'return type.narrowBy(dst);'], ['type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);', 'type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);', 'type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());', 'return config.getTypeFactory().constructSpecializedType(type, dst);'], 'a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java', 'b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java']
['JacksonDatabind-26', 1, 1, 1, 1, ['*/ @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not public class BeanPropertyWriter extends PropertyWriter implements BeanProperty { // as of 2.6.2 /** * Marker object used to indicate "do not serialize if empty"'], ['*/ @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not public class BeanPropertyWriter extends PropertyWriter implements BeanProperty, java.io.Serializable // since 2.6.2 { // as of 2.6.2 private static final long serialVersionUID = 4603296144163950020L; /** * Marker object used to indicate "do not serialize if empty"'], ['implements BeanProperty'], ['implements BeanProperty, java.io.Serializable // since 2.6.2 private static final long serialVersionUID = 4603296144163950020L;'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java']
['JacksonDatabind-27', 1, 1, 1, 1, ["// first: let's check to see if this might be part of value with external type id: // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null, // since it is not the bean if (ext.handlePropertyValue(p, ctxt, propName, buffer)) { ; } else { // Last creator property to set?"], ["// first: let's check to see if this might be part of value with external type id: // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null, // since it is not the bean if (ext.handlePropertyValue(p, ctxt, propName, null)) { ; } else { // Last creator property to set?"], ['if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {'], ['if (ext.handlePropertyValue(p, ctxt, propName, null)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java']
['JacksonDatabind-28', 1, 1, 1, 1, ['@Override public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } throw ctxt.mappingException(ObjectNode.class); }'], ['@Override public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode(); } throw ctxt.mappingException(ObjectNode.class); }'], ['if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory());'], ['if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode();'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java']
['JacksonDatabind-29', 2, 2, 2, 2, ['JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray();', 'JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray(); merged.writeString(typeId);'], ['JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support if (t == JsonToken.VALUE_NULL) { return null; } TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray();', 'JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support if (t == JsonToken.VALUE_NULL) { _properties[index].getProperty().set(bean, null); return; } TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray(); merged.writeString(typeId);'], ['', ''], ['if (t == JsonToken.VALUE_NULL) { return null; }', 'if (t == JsonToken.VALUE_NULL) { _properties[index].getProperty().set(bean, null); return; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java']
['JacksonDatabind-30', 6, 6, 6, 6, ['{ if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); JsonNode result; try { writeValue(buf, fromValue);', " // Then use TokenBuffer, which is a JsonGenerator: TokenBuffer buf = new TokenBuffer(this, false); try { // inlined 'writeValue' with minor changes: // first: disable wrapping when writing", '* * @since 2.7 */ /* /**********************************************************', '_hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } /** * @since 2.7 */ @Override public Version version() {', '} break; case VALUE_NUMBER_FLOAT: /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying * number is already decoded into a number (in which case might as well * access as number); or is still retained as text (in which case we * should further defer decoding that may not need BigDecimal): */ switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());', 'break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE:'], ['{ if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); } JsonNode result; try { writeValue(buf, fromValue);', " // Then use TokenBuffer, which is a JsonGenerator: TokenBuffer buf = new TokenBuffer(this, false); if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); } try { // inlined 'writeValue' with minor changes: // first: disable wrapping when writing", '* * @since 2.7 */ protected boolean _forceBigDecimal; /* /**********************************************************', '_hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } /** * @since 2.7 */ public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() {', '} break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying * number is already decoded into a number (in which case might as well * access as number); or is still retained as text (in which case we * should further defer decoding that may not need BigDecimal): */ writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());', 'break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE:'], ['', '', '', '', '', ''], ['if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); }', 'if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); }', 'protected boolean _forceBigDecimal;', '_forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; }', 'if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else {', '}'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-31', 13, 13, 13, 13, ['if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }', 'if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }', ' @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override', 'if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } /*', ' @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override', 'if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } }', 'if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } }', '/* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric * identity as long as possible */ _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } /*', '} Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) {', '* err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }', " if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }", '* * @since 2.6.4 */ /** * Similar to {@link #_append(JsonToken,Object)} but also updates context with', '* * @since 2.6.4 */ protected final void _appendRaw(int rawType, Object value) {'], ['if (text == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_STRING, text); } }', 'if (text == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_STRING, text); } }', ' @Override public void writeRawValue(String text) throws IOException { _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override', 'if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } /*', ' @Override public void writeNumber(short i) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override', 'if (dec == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec); } }', 'if (v == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_NUMBER_INT, v); } }', '/* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric * identity as long as possible */ _appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _appendValue(JsonToken.VALUE_NULL); } /*', '} Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) {', '* err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }', " if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }", '* * @since 2.6.4 */ protected final void _appendValue(JsonToken type) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } /** * Similar to {@link #_append(JsonToken,Object)} but also updates context with', '* * @since 2.6.4 */ protected final void _appendValue(JsonToken type, Object value) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) {'], ['_append(JsonToken.VALUE_STRING, text);', '_append(JsonToken.VALUE_STRING, text);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));', '_append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));', '_append(JsonToken.VALUE_NUMBER_FLOAT, dec);', '_append(JsonToken.VALUE_NUMBER_INT, v);', '_append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); _append(JsonToken.VALUE_NULL);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, node);', '', ''], ['_appendValue(JsonToken.VALUE_STRING, text);', '_appendValue(JsonToken.VALUE_STRING, text);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));', '_appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); _appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); _appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));', '_appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec);', '_appendValue(JsonToken.VALUE_NUMBER_INT, v);', '_appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); _appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); _appendValue(JsonToken.VALUE_NULL);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node);', 'protected final void _appendValue(JsonToken type) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } }', 'protected final void _appendValue(JsonToken type, Object value) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-32', 2, 2, 2, 2, ['case JsonTokenId.ID_FIELD_NAME: // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (_mapDeserializer != null) { return _mapDeserializer.deserialize(p, ctxt); }', 'case JsonTokenId.ID_NULL: // should not get this but... return null; // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object //case JsonTokenId.ID_END_ARRAY: // invalid default:'], ['case JsonTokenId.ID_FIELD_NAME: // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object case JsonTokenId.ID_END_OBJECT: if (_mapDeserializer != null) { return _mapDeserializer.deserialize(p, ctxt); }', 'case JsonTokenId.ID_NULL: // should not get this but... return null; case JsonTokenId.ID_END_OBJECT: // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object return new LinkedHashMap<String,Object>(2); //case JsonTokenId.ID_END_ARRAY: // invalid default:'], ['', ''], ['case JsonTokenId.ID_END_OBJECT:', 'case JsonTokenId.ID_END_OBJECT: return new LinkedHashMap<String,Object>(2);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java']
['JacksonDatabind-33', 1, 1, 1, 1, ['*/ } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) || _hasAnnotation(a, JsonRawValue.class)) { name = ""; } else { return null;'], ['*/ } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) || _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) { name = ""; } else { return null;'], ['|| _hasAnnotation(a, JsonRawValue.class)) {'], ['|| _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java']
['JacksonDatabind-34', 1, 1, 1, 1, ["} else { Class<?> h = handledType(); if (h == BigDecimal.class) { visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { // otherwise bit unclear what to call... but let's try: /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);"], ["} else { Class<?> h = handledType(); if (h == BigDecimal.class) { visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL); } else { // otherwise bit unclear what to call... but let's try: /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);"], ['visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);'], ['visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java']
['JacksonDatabind-35', 1, 1, 1, 1, ['} } // first, sanity checks if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); } // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); } final String typeId = p.getText(); JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); p.nextToken();'], ['} } // first, sanity checks JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); } } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); } final String typeId = p.getText(); JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); p.nextToken();'], ['if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); }'], ['JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java']
['JacksonDatabind-36', 2, 2, 2, 2, ['* and not via underlying {@link Calendar} instance like base class * does. */ // and since leniency settings may have been used: @Override // since 2.7 public boolean isLenient() {', 'df.setTimeZone(tz); } } return df; }'], ['* and not via underlying {@link Calendar} instance like base class * does. */ @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; // and since leniency settings may have been used: _clearFormats(); } } @Override // since 2.7 public boolean isLenient() {', 'df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; }'], ['', ''], ['@Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } }', 'if (lenient != null) { df.setLenient(lenient.booleanValue()); }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-37', 1, 1, 1, 1, ['} */ // 15-Jan-2015, tatu: Not correct; should really re-resolve... return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic); }'], ['} */ // 15-Jan-2015, tatu: Not correct; should really re-resolve... return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); }'], ['return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,'], ['return new SimpleType(subclass, _bindings, this, _superInterfaces,'], 'a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java']
['JacksonDatabind-38', 6, 6, 6, 6, ['package com.fasterxml.jackson.databind.type; import com.fasterxml.jackson.databind.JavaType;', 'public static CollectionType construct(Class<?> rawType, JavaType elemT) { // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) return new CollectionType(rawType, null, // !!! TODO: Wrong, does have supertypes, but: _bogusSuperClass(rawType), null, elemT, null, null, false);', 'package com.fasterxml.jackson.databind.type; import com.fasterxml.jackson.databind.JavaType;', '{ // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) // !!! TODO: Wrong, does have supertypes return new MapType(rawType, null, _bogusSuperClass(rawType), null, keyT, valueT, null, null, false); }', 'if (cls.isArray()) { throw new IllegalArgumentException("Can not construct SimpleType for an array (class: "+cls.getName()+")"); } return new SimpleType(cls, TypeBindings.emptyBindings(), _bogusSuperClass(cls), null, null, null, false); } @Override', '* * @since 2.7 -- remove when not needed (2.8?) */ /* /**********************************************************'], ['package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import com.fasterxml.jackson.databind.JavaType;', 'public static CollectionType construct(Class<?> rawType, JavaType elemT) { // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 1)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, elemT); } return new CollectionType(rawType, bindings, // !!! TODO: Wrong, does have supertypes, but: _bogusSuperClass(rawType), null, elemT, null, null, false);', 'package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import com.fasterxml.jackson.databind.JavaType;', '{ // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 2)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, keyT, valueT); } // !!! TODO: Wrong, does have supertypes return new MapType(rawType, bindings, _bogusSuperClass(rawType), null, keyT, valueT, null, null, false); }', 'if (cls.isArray()) { throw new IllegalArgumentException("Can not construct SimpleType for an array (class: "+cls.getName()+")"); } TypeBindings b = TypeBindings.emptyBindings(); return new SimpleType(cls, b, _buildSuperClass(cls.getSuperclass(), b), null, null, null, false); } @Override', '* * @since 2.7 -- remove when not needed (2.8?) */ private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b) { if (superClass == null) { return null; } if (superClass == Object.class) { return TypeFactory.unknownType(); } JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b); return new SimpleType(superClass, b, superSuper, null, null, null, false); } /* /**********************************************************'], ['', 'return new CollectionType(rawType, null,', '', 'return new MapType(rawType, null, _bogusSuperClass(rawType), null,', 'return new SimpleType(cls, TypeBindings.emptyBindings(), _bogusSuperClass(cls), null, null, null, false);', ''], ['import java.lang.reflect.TypeVariable;', 'TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 1)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, elemT); } return new CollectionType(rawType, bindings,', 'import java.lang.reflect.TypeVariable;', 'TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 2)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, keyT, valueT); } return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,', 'TypeBindings b = TypeBindings.emptyBindings(); return new SimpleType(cls, b, _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);', 'private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b) { if (superClass == null) { return null; } if (superClass == Object.class) { return TypeFactory.unknownType(); } JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b); return new SimpleType(superClass, b, superSuper, null, null, null, false); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java']
['JacksonDatabind-39', 1, 1, 1, 1, ['{ // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit // special unfortunately p.skipChildren(); return null; }'], ['{ // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit // special unfortunately if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { p.skipChildren(); } return null; }'], [''], ['if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java']
['JacksonDatabind-40', 1, 1, 1, 1, ['return _nullValue; } // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed } /*'], ['return _nullValue; } @Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( "Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to \'false\' to allow)", handledType().toString()); } return _nullValue; } } /*'], [''], ['@Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( "Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to \'false\' to allow)", handledType().toString()); } return _nullValue; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java']
['JacksonDatabind-41', 2, 2, 2, 2, ['*/ @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { return constructType(type, constructType(contextClass)); } /**', '*/ @Deprecated public JavaType constructType(Type type, JavaType contextType) { return _fromAny(null, type, contextType.getBindings()); } /*'], ['*/ @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } /**', '*/ @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } /*'], ['return constructType(type, constructType(contextClass));', 'return _fromAny(null, type, contextType.getBindings());'], ['TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings);', 'TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-42', 1, 1, 1, 1, ['return URI.create(""); } // As per [databind#1123], Locale too return super._deserializeFromEmptyString(); } }'], ['return URI.create(""); } // As per [databind#1123], Locale too if (_kind == STD_LOCALE) { return Locale.ROOT; } return super._deserializeFromEmptyString(); } }'], [''], ['if (_kind == STD_LOCALE) { return Locale.ROOT; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java']
['JacksonDatabind-43', 2, 2, 2, 2, ['import java.lang.annotation.Annotation; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.introspect.AnnotatedMember;', 'public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException { Object id = _valueDeserializer.deserialize(p, ctxt); /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be; * missing or null id is needed for some cases, such as cases where id * will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ // note: no null checks (unlike usually); deserializer should fail if one found if (id == null) { return null; } ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance); // also: may need to set a property value as well'], ['import java.lang.annotation.Annotation; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonToken; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.introspect.AnnotatedMember;', 'public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException { /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be; * missing or null id is needed for some cases, such as cases where id * will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ // note: no null checks (unlike usually); deserializer should fail if one found if (p.hasToken(JsonToken.VALUE_NULL)) { return null; } Object id = _valueDeserializer.deserialize(p, ctxt); ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance); // also: may need to set a property value as well'], ['', 'Object id = _valueDeserializer.deserialize(p, ctxt); if (id == null) {'], ['import com.fasterxml.jackson.core.JsonToken;', 'if (p.hasToken(JsonToken.VALUE_NULL)) { Object id = _valueDeserializer.deserialize(p, ctxt);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java']
['JacksonDatabind-44', 1, 1, 1, 1, ['// 15-Jan-2016, tatu: Almost yes, but there are some complications with // placeholder values (`Void`, `NoClass`), so can not quite do yet. // TODO: fix in 2.8 /* throw new IllegalArgumentException("Class "+subclass.getName()+" not sub-type of " +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); // Otherwise, stitch together the hierarchy. First, super-class // if not found, try a super-interface // should not get here but... } @Override'], ['// 15-Jan-2016, tatu: Almost yes, but there are some complications with // placeholder values (`Void`, `NoClass`), so can not quite do yet. // TODO: fix in 2.8 if (!_class.isAssignableFrom(subclass)) { /* throw new IllegalArgumentException("Class "+subclass.getName()+" not sub-type of " +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } // Otherwise, stitch together the hierarchy. First, super-class Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } // if not found, try a super-interface Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } // should not get here but... throw new IllegalArgumentException("Internal error: Can not resolve sub-type for Class "+subclass.getName()+" to " +_class.getName()); } @Override'], [''], ['if (!_class.isAssignableFrom(subclass)) { } Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } throw new IllegalArgumentException("Internal error: Can not resolve sub-type for Class "+subclass.getName()+" to " +_class.getName());'], 'a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java']
['JacksonDatabind-45', 1, 1, 1, 1, ['return withFormat(Boolean.TRUE, null); } if (format.getShape() == JsonFormat.Shape.STRING) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern()'], ['return withFormat(Boolean.TRUE, null); } if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern()'], ['if (format.getShape() == JsonFormat.Shape.STRING) {'], ['if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java']
['JacksonDatabind-46', 1, 1, 1, 1, ["_classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); sb.append(';'); return sb; }"], ['_classSignature(_class, sb, false); sb.append(\'<\'); sb = _referencedType.getGenericSignature(sb); sb.append(">;"); return sb; }'], ["sb.append(';');"], ['sb.append(">;");'], 'a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java']
['JacksonDatabind-47', 1, 1, 1, 1, ['// static typing this way type = type.withStaticTyping(); } else { try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? type = tf.constructGeneralizedType(type, serClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format("Failed to widen type %s with annotation (value %s), from \'%s\': %s",'], ['// static typing this way type = type.withStaticTyping(); } else { Class<?> currRaw = type.getRawClass(); try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? if (serClass.isAssignableFrom(currRaw)) { // common case type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related", type, serClass.getName())); } } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format("Failed to widen type %s with annotation (value %s), from \'%s\': %s",'], [''], ['Class<?> currRaw = type.getRawClass(); if (serClass.isAssignableFrom(currRaw)) { // common case } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related", type, serClass.getName())); }'], 'a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java']
['JacksonDatabind-48', 2, 2, 2, 2, ['if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { vchecker = vchecker.withFieldVisibility(Visibility.NONE); }', '{ VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); // then global overrides (disabling) if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); }'], ['if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { vchecker = vchecker.withFieldVisibility(Visibility.NONE); }', '{ VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); // then global overrides (disabling) if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { vchecker = vchecker.withSetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); }'], ['', ''], ['if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); }', 'if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { vchecker = vchecker.withSetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); }'], 'a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java', 'b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java']
['JacksonDatabind-49', 1, 1, 1, 1, ['// 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of // id being generated for "alwaysAsId", but not being written as POJO; regardless, // need to use existing id if there is one: id = generator.generateId(forPojo); return id; }'], ['// 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of // id being generated for "alwaysAsId", but not being written as POJO; regardless, // need to use existing id if there is one: if (id == null) { id = generator.generateId(forPojo); } return id; }'], [''], ['if (id == null) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java']
['JacksonDatabind-50', 6, 6, 6, 6, ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.impl.*; import com.fasterxml.jackson.databind.util.NameTransformer; import com.fasterxml.jackson.databind.util.TokenBuffer;', 'TokenBuffer unknown = null; JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); // to point to value', '// regular property? needs buffering SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop)); // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional // handling of forward references here. Not exactly sure why existing // facilities did not cover, but this does appear to solve the problem continue; } // Things marked as ignorable should not be passed to any setter', 'wrapInstantiationProblem(e, ctxt); bean = null; // never gets here } if (unknown != null) { // polymorphic? if (bean.getClass() != _beanType.getRawClass()) {', '/** * @since 2.8 */ protected final Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt, SettableBeanProperty prop)', '/** * @since 2.8 */ }'], ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.impl.*; import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring; import com.fasterxml.jackson.databind.util.NameTransformer; import com.fasterxml.jackson.databind.util.TokenBuffer;', 'TokenBuffer unknown = null; JsonToken t = p.getCurrentToken(); List<BeanReferring> referrings = null; for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); // to point to value', '// regular property? needs buffering SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { try { buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop)); } catch (UnresolvedForwardReference reference) { // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional // handling of forward references here. Not exactly sure why existing // facilities did not cover, but this does appear to solve the problem BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference); if (referrings == null) { referrings = new ArrayList<BeanReferring>(); } referrings.add(referring); } continue; } // Things marked as ignorable should not be passed to any setter', 'wrapInstantiationProblem(e, ctxt); bean = null; // never gets here } if (referrings != null) { for (BeanReferring referring : referrings) { referring.setBean(bean); } } if (unknown != null) { // polymorphic? if (bean.getClass() != _beanType.getRawClass()) {', '/** * @since 2.8 */ private BeanReferring handleUnresolvedReference(JsonParser p, SettableBeanProperty prop, PropertyValueBuffer buffer, UnresolvedForwardReference reference) throws JsonMappingException { BeanReferring referring = new BeanReferring(reference, prop.getType().getRawClass(), buffer, prop); reference.getRoid().appendReferring(referring); return referring; } protected final Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt, SettableBeanProperty prop)', '/** * @since 2.8 */ static class BeanReferring extends Referring { private final SettableBeanProperty _prop; private Object _bean; public void setBean(Object bean) { _bean = bean; } BeanReferring(UnresolvedForwardReference ref, Class<?> valueType, PropertyValueBuffer buffer, SettableBeanProperty prop) { super(ref, valueType); _prop = prop; } @Override public void handleResolvedForwardReference(Object id, Object value) throws IOException { _prop.set(_bean, value); } } }'], ['', '', '', '', '', ''], ['import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;', 'List<BeanReferring> referrings = null;', 'try { } catch (UnresolvedForwardReference reference) { BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference); if (referrings == null) { referrings = new ArrayList<BeanReferring>(); } referrings.add(referring); }', 'if (referrings != null) { for (BeanReferring referring : referrings) { referring.setBean(bean); } }', 'private BeanReferring handleUnresolvedReference(JsonParser p, SettableBeanProperty prop, PropertyValueBuffer buffer, UnresolvedForwardReference reference) throws JsonMappingException { BeanReferring referring = new BeanReferring(reference, prop.getType().getRawClass(), buffer, prop); reference.getRoid().appendReferring(referring); return referring; }', 'static class BeanReferring extends Referring { private final SettableBeanProperty _prop; private Object _bean; public void setBean(Object bean) { _bean = bean; } BeanReferring(UnresolvedForwardReference ref, Class<?> valueType, PropertyValueBuffer buffer, SettableBeanProperty prop) { super(ref, valueType); _prop = prop; } @Override public void handleResolvedForwardReference(Object id, Object value) throws IOException { _prop.set(_bean, value); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java']
['JacksonDatabind-51', 1, 1, 1, 1, ['// generic type with custom type resolvers. If so, should try to retain them. // Whether this is sufficient to avoid problems remains to be seen, but for // now it should improve things. type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); }'], ['// generic type with custom type resolvers. If so, should try to retain them. // Whether this is sufficient to avoid problems remains to be seen, but for // now it should improve things. if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); }'], [''], ['if (!type.hasGenericTypes()) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java']
['JacksonDatabind-52', 2, 2, 2, 2, ['if (extTypes != null) { // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too, // so need to pass collected properties _externalTypeIdHandler = extTypes.build(); // we consider this non-standard, to offline handling _nonStandardCreation = true; }', '* * @since 2.8 */ // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also @Deprecated // since 2.8; may be removed as early as 2.9 public ExternalTypeHandler build() {'], ['if (extTypes != null) { // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too, // so need to pass collected properties _externalTypeIdHandler = extTypes.build(_beanProperties); // we consider this non-standard, to offline handling _nonStandardCreation = true; }', '* * @since 2.8 */ public ExternalTypeHandler build(BeanPropertyMap otherProps) { // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also final int len = _properties.size(); ExtTypedProperty[] extProps = new ExtTypedProperty[len]; for (int i = 0; i < len; ++i) { ExtTypedProperty extProp = _properties.get(i); String typePropId = extProp.getTypePropertyName(); SettableBeanProperty typeProp = otherProps.find(typePropId); if (typeProp != null) { extProp.linkTypeProperty(typeProp); } extProps[i] = extProp; } return new ExternalTypeHandler(extProps, _nameToPropertyIndex, null, null); } @Deprecated // since 2.8; may be removed as early as 2.9 public ExternalTypeHandler build() {'], ['_externalTypeIdHandler = extTypes.build();', ''], ['_externalTypeIdHandler = extTypes.build(_beanProperties);', 'public ExternalTypeHandler build(BeanPropertyMap otherProps) { final int len = _properties.size(); ExtTypedProperty[] extProps = new ExtTypedProperty[len]; for (int i = 0; i < len; ++i) { ExtTypedProperty extProp = _properties.get(i); String typePropId = extProp.getTypePropertyName(); SettableBeanProperty typeProp = otherProps.find(typePropId); if (typeProp != null) { extProp.linkTypeProperty(typeProp); } extProps[i] = extProp; } return new ExternalTypeHandler(extProps, _nameToPropertyIndex, null, null); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java']
['JacksonDatabind-53', 7, 7, 7, 7, ['* * @since 2.8 */ // safe to pass _types array without copy since it is not exposed via // any access, nor modified by this class /* /**********************************************************************', '* * @since 2.8 */ }', '* actual generic types), we will use small cache to avoid repetitive * resolution of core types */ protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); /* /**********************************************************', "// for a case where this code does get invoked: not ideal // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but // not certain it would reliably work... but let's hope for best for now if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } // Only SimpleType returns null, but if so just resolve regularly if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false);", '*/ } // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy // (hopefully passing null Class for root is ok) // Otherwise, two choices: match N first, or empty. Do latter, for now /** * Method similar to {@link #constructSpecializedType}, but that creates a', 'return result; } // Barring that, we may have recently constructed an instance boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } // 15-Oct-2015, tatu: recursive reference?', '} } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); } return result; }'], ['* * @since 2.8 */ public Object asKey(Class<?> rawBase) { // safe to pass _types array without copy since it is not exposed via // any access, nor modified by this class return new AsKey(rawBase, _types, _hashCode); } /* /**********************************************************************', '* * @since 2.8 */ final static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash; public AsKey(Class<?> raw, JavaType[] params, int hash) { _raw = raw ; _params = params; _hash = hash; } @Override public int hashCode() { return _hash; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; AsKey other = (AsKey) o; if ((_hash == other._hash) && (_raw == other._raw)) { final JavaType[] otherParams = other._params; final int len = _params.length; if (len == otherParams.length) { for (int i = 0; i < len; ++i) { if (!_params[i].equals(otherParams[i])) { return false; } } return true; } } return false; } @Override public String toString() { return _raw.getName()+"<>"; } } }', '* actual generic types), we will use small cache to avoid repetitive * resolution of core types */ protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100); /* /**********************************************************', "// for a case where this code does get invoked: not ideal // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but // not certain it would reliably work... but let's hope for best for now TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass); if (baseType.isInterface()) { newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, tb, baseType, NO_TYPES); } // Only SimpleType returns null, but if so just resolve regularly if (newType == null) { newType = _fromClass(null, subclass, tb); } } while (false);", '*/ } private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) { // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy // (hopefully passing null Class for root is ok) int baseCount = baseType.containedTypeCount(); if (baseCount == typeParamCount) { if (typeParamCount == 1) { return TypeBindings.create(subclass, baseType.containedType(0)); } if (typeParamCount == 2) { return TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } List<JavaType> types = new ArrayList<JavaType>(baseCount); for (int i = 0; i < baseCount; ++i) { types.add(baseType.containedType(i)); } return TypeBindings.create(subclass, types); } // Otherwise, two choices: match N first, or empty. Do latter, for now return TypeBindings.emptyBindings(); } /** * Method similar to {@link #constructSpecializedType}, but that creates a', 'return result; } // Barring that, we may have recently constructed an instance final Object key; if ((bindings == null) || bindings.isEmpty()) { key = rawType; result = _typeCache.get(key); // ok, cache object is synced } else { key = bindings.asKey(rawType); } result = _typeCache.get(key); // ok, cache object is synced if (result != null) { return result; } // 15-Oct-2015, tatu: recursive reference?', '} } context.resolveSelfReferences(result); _typeCache.putIfAbsent(key, result); // cache object syncs return result; }'], ['', '', 'protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);', 'newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);', '', 'boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); }', 'if (cachable) { _typeCache.putIfAbsent(rawType, result); }'], ['public Object asKey(Class<?> rawBase) { return new AsKey(rawBase, _types, _hashCode); }', 'final static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash; public AsKey(Class<?> raw, JavaType[] params, int hash) { _raw = raw ; _params = params; _hash = hash; } @Override public int hashCode() { return _hash; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; AsKey other = (AsKey) o; if ((_hash == other._hash) && (_raw == other._raw)) { final JavaType[] otherParams = other._params; final int len = _params.length; if (len == otherParams.length) { for (int i = 0; i < len; ++i) { if (!_params[i].equals(otherParams[i])) { return false; } } return true; } } return false; } @Override public String toString() { return _raw.getName()+"<>"; } }', 'protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100);', 'TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass); newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType }); newType = baseType.refine(subclass, tb, baseType, NO_TYPES); newType = _fromClass(null, subclass, tb);', 'private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) { int baseCount = baseType.containedTypeCount(); if (baseCount == typeParamCount) { if (typeParamCount == 1) { return TypeBindings.create(subclass, baseType.containedType(0)); } if (typeParamCount == 2) { return TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } List<JavaType> types = new ArrayList<JavaType>(baseCount); for (int i = 0; i < baseCount; ++i) { types.add(baseType.containedType(i)); } return TypeBindings.create(subclass, types); } return TypeBindings.emptyBindings(); }', 'final Object key; if ((bindings == null) || bindings.isEmpty()) { key = rawType; result = _typeCache.get(key); // ok, cache object is synced } else { key = bindings.asKey(rawType); } result = _typeCache.get(key); // ok, cache object is synced', '_typeCache.putIfAbsent(key, result); // cache object syncs'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-54', 2, 2, 2, 2, ['// always suppress nulls suppressNulls = true; // and for referential types, also "empty", which in their case means "absent" if (declaredType.isReferenceType()) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; } break;', 'case ALWAYS: // default default: // we may still want to suppress empty collections, as per [JACKSON-254]: if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; }'], ['// always suppress nulls suppressNulls = true; // and for referential types, also "empty", which in their case means "absent" if (actualType.isReferenceType()) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; } break;', 'case ALWAYS: // default default: // we may still want to suppress empty collections, as per [JACKSON-254]: if (actualType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; }'], ['if (declaredType.isReferenceType()) {', 'if (declaredType.isContainerType()'], ['if (actualType.isReferenceType()) {', 'if (actualType.isContainerType()'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java']
['JacksonDatabind-55', 3, 3, 3, 3, ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap; @SuppressWarnings("serial") public class StdKeySerializers', 'return new Dynamic(); } if (rawKeyType.isEnum()) { return new Default(Default.TYPE_ENUM, rawKeyType); } } return DEFAULT_KEY_SERIALIZER;', '* * @since 2.8 */ }'], ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap; import com.fasterxml.jackson.databind.util.EnumValues; @SuppressWarnings("serial") public class StdKeySerializers', 'return new Dynamic(); } if (rawKeyType.isEnum()) { return EnumKeySerializer.construct(rawKeyType, EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType)); } } return DEFAULT_KEY_SERIALIZER;', '* * @since 2.8 */ public static class EnumKeySerializer extends StdSerializer<Object> { protected final EnumValues _values; protected EnumKeySerializer(Class<?> enumType, EnumValues values) { super(enumType, false); _values = values; } public static EnumKeySerializer construct(Class<?> enumType, EnumValues enumValues) { return new EnumKeySerializer(enumType, enumValues); } @Override public void serialize(Object value, JsonGenerator g, SerializerProvider serializers) throws IOException { if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) { g.writeFieldName(value.toString()); return; } Enum<?> en = (Enum<?>) value; g.writeFieldName(_values.serializedValueFor(en)); } } }'], ['', 'return new Default(Default.TYPE_ENUM, rawKeyType);', ''], ['import com.fasterxml.jackson.databind.util.EnumValues;', 'return EnumKeySerializer.construct(rawKeyType, EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType));', 'public static class EnumKeySerializer extends StdSerializer<Object> { protected final EnumValues _values; protected EnumKeySerializer(Class<?> enumType, EnumValues values) { super(enumType, false); _values = values; } public static EnumKeySerializer construct(Class<?> enumType, EnumValues enumValues) { return new EnumKeySerializer(enumType, enumValues); } @Override public void serialize(Object value, JsonGenerator g, SerializerProvider serializers) throws IOException { if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) { g.writeFieldName(value.toString()); return; } Enum<?> en = (Enum<?>) value; g.writeFieldName(_values.serializedValueFor(en)); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java']
['JacksonDatabind-56', 1, 2, 2, 2, ["return Pattern.compile(value); case STD_LOCALE: { int ix = value.indexOf('_'); if (ix < 0) { // single argument return new Locale(value); } String first = value.substring(0, ix); value = value.substring(ix+1); ix = value.indexOf('_'); if (ix < 0) { // two pieces return new Locale(first, value); }"], ['return Pattern.compile(value); case STD_LOCALE: { int ix = _firstHyphenOrUnderscore(value); if (ix < 0) { // single argument return new Locale(value); } String first = value.substring(0, ix); value = value.substring(ix+1); ix = _firstHyphenOrUnderscore(value); if (ix < 0) { // two pieces return new Locale(first, value); }', "} protected int _firstHyphenOrUnderscore(String str) { for (int i = 0, end = str.length(); i < end; ++i) { char c = str.charAt(i); if (c == '_' || c == '-') { return i; } } return -1; } } }"], ["int ix = value.indexOf('_'); ix = value.indexOf('_');", ''], ['int ix = _firstHyphenOrUnderscore(value); ix = _firstHyphenOrUnderscore(value);', "protected int _firstHyphenOrUnderscore(String str) { for (int i = 0, end = str.length(); i < end; ++i) { char c = str.charAt(i); if (c == '_' || c == '-') { return i; } } return -1; }"], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java']
['JacksonDatabind-57', 1, 1, 1, 1, ['if (_dataFormatReaders != null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true)); }'], ['if (_dataFormatReaders != null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), true)); }'], ['return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),'], ['return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java']
['JacksonDatabind-58', 1, 1, 1, 1, ["// [databind#877]: explicitly prevent forced access to `cause` of `Throwable`; // never needed and attempts may cause problems on some platforms. // !!! NOTE: should be handled better for 2.8 and later mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } // note: this works since we know there's exactly one argument for methods BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),"], ['// [databind#877]: explicitly prevent forced access to `cause` of `Throwable`; // never needed and attempts may cause problems on some platforms. // !!! NOTE: should be handled better for 2.8 and later if ((mutator instanceof AnnotatedField) && "cause".equals(mutator.getName())) { ; } else { mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } } // note: this works since we know there\'s exactly one argument for methods BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),'], [''], ['if ((mutator instanceof AnnotatedField) && "cause".equals(mutator.getName())) { ; } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-59', 4, 4, 4, 4, ['* * @since 2.8.4 */ /** * Mutant factory method that may be called on structured types', '_valueHandler, _typeHandler, _asStatic); } @Override public CollectionLikeType withStaticTyping() {', '_valueHandler, _typeHandler, _asStatic); } // "withKeyType()" not part of JavaType, hence must verify: @Override public MapLikeType withStaticTyping() {', ' // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get // copied as well return newType; // 20-Oct-2015, tatu: Old simplistic approach'], ['* * @since 2.8.4 */ public JavaType withHandlersFrom(JavaType src) { JavaType type = this; Object h = src.getTypeHandler(); if (h != _typeHandler) { type = type.withTypeHandler(h); } h = src.getValueHandler(); if (h != _valueHandler) { type = type.withValueHandler(h); } return type; } /** * Mutant factory method that may be called on structured types', '_valueHandler, _typeHandler, _asStatic); } @Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _elementType.withHandlersFrom(srcCt); if (ct != _elementType) { type = type.withContentType(ct); } } return type; } @Override public CollectionLikeType withStaticTyping() {', '_valueHandler, _typeHandler, _asStatic); } @Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcKeyType = src.getKeyType(); // "withKeyType()" not part of JavaType, hence must verify: if (type instanceof MapLikeType) { if (srcKeyType != null) { JavaType ct = _keyType.withHandlersFrom(srcKeyType); if (ct != _keyType) { type = ((MapLikeType) type).withKeyType(ct); } } } JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _valueType.withHandlersFrom(srcCt); if (ct != _valueType) { type = type.withContentType(ct); } } return type; } @Override public MapLikeType withStaticTyping() {', ' // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get // copied as well newType = newType.withHandlersFrom(baseType); return newType; // 20-Oct-2015, tatu: Old simplistic approach'], ['', '', '', ''], ['public JavaType withHandlersFrom(JavaType src) { JavaType type = this; Object h = src.getTypeHandler(); if (h != _typeHandler) { type = type.withTypeHandler(h); } h = src.getValueHandler(); if (h != _valueHandler) { type = type.withValueHandler(h); } return type; }', '@Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _elementType.withHandlersFrom(srcCt); if (ct != _elementType) { type = type.withContentType(ct); } } return type; }', '@Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcKeyType = src.getKeyType(); if (type instanceof MapLikeType) { if (srcKeyType != null) { JavaType ct = _keyType.withHandlersFrom(srcKeyType); if (ct != _keyType) { type = ((MapLikeType) type).withKeyType(ct); } } } JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _valueType.withHandlersFrom(srcCt); if (ct != _valueType) { type = type.withContentType(ct); } } return type; }', 'newType = newType.withHandlersFrom(baseType);'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-60', 4, 4, 4, 4, ['import java.util.LinkedHashSet; import java.util.Set; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;', 'import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor; import com.fasterxml.jackson.databind.jsonschema.SchemaAware; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.BeanSerializer; import com.fasterxml.jackson.databind.ser.ContextualSerializer;', '// 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling // to use different Object for type id (logical type) and actual serialization // (delegat type). ser.serializeWithType(value, gen, provider, typeSer0); } catch (IOException ioe) { throw ioe; } catch (Exception e) {', '* override Object to use for type id (logical type) even when asking serialization * of something else (delegate type) */ }'], ['import java.util.LinkedHashSet; import java.util.Set; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;', 'import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor; import com.fasterxml.jackson.databind.jsonschema.SchemaAware; import com.fasterxml.jackson.databind.jsontype.TypeIdResolver; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.BeanSerializer; import com.fasterxml.jackson.databind.ser.ContextualSerializer;', '// 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling // to use different Object for type id (logical type) and actual serialization // (delegat type). TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean); ser.serializeWithType(value, gen, provider, rr); } catch (IOException ioe) { throw ioe; } catch (Exception e) {', '* override Object to use for type id (logical type) even when asking serialization * of something else (delegate type) */ static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer; protected final Object _forObject; public TypeSerializerRerouter(TypeSerializer ts, Object ob) { _typeSerializer = ts; _forObject = ob; } @Override public TypeSerializer forProperty(BeanProperty prop) { // should never get called throw new UnsupportedOperationException(); } @Override public As getTypeInclusion() { return _typeSerializer.getTypeInclusion(); } @Override public String getPropertyName() { return _typeSerializer.getPropertyName(); } @Override public TypeIdResolver getTypeIdResolver() { return _typeSerializer.getTypeIdResolver(); } @Override public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen); } @Override public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen); } @Override public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen); } @Override public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForScalar(_forObject, gen); } @Override public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForObject(_forObject, gen); } @Override public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForArray(_forObject, gen); } public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type); } public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen, type); } public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen, type); } @Override public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId); } } }'], ['', '', 'ser.serializeWithType(value, gen, provider, typeSer0);', ''], ['import com.fasterxml.jackson.annotation.JsonTypeInfo.As;', 'import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;', 'TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean); ser.serializeWithType(value, gen, provider, rr);', 'static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer; protected final Object _forObject; public TypeSerializerRerouter(TypeSerializer ts, Object ob) { _typeSerializer = ts; _forObject = ob; } @Override public TypeSerializer forProperty(BeanProperty prop) { // should never get called throw new UnsupportedOperationException(); } @Override public As getTypeInclusion() { return _typeSerializer.getTypeInclusion(); } @Override public String getPropertyName() { return _typeSerializer.getPropertyName(); } @Override public TypeIdResolver getTypeIdResolver() { return _typeSerializer.getTypeIdResolver(); } @Override public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen); } @Override public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen); } @Override public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen); } @Override public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForScalar(_forObject, gen); } @Override public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForObject(_forObject, gen); } @Override public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForArray(_forObject, gen); } public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type); } public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen, type); } public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen, type); } @Override public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java']
['JacksonDatabind-61', 3, 3, 3, 3, ['{ // 03-Oct-2016, tatu: As per [databind#1395], need to skip // primitive types too, regardless switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); switch (_includeAs) { case WRAPPER_ARRAY:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);'], ['{ // 03-Oct-2016, tatu: As per [databind#1395], need to skip // primitive types too, regardless if (t.isPrimitive()) { return false; } switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting if (baseType.isPrimitive()) { return null; } TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); switch (_includeAs) { case WRAPPER_ARRAY:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting if (baseType.isPrimitive()) { return null; } TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);'], ['', '', ''], ['if (t.isPrimitive()) { return false; }', 'if (baseType.isPrimitive()) { return null; }', 'if (baseType.isPrimitive()) { return null; }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java']
['JacksonDatabind-62', 1, 1, 1, 1, ['+") returned true for \'canCreateUsingDelegate()\', but null for \'getDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property); } } // [databind#1043]: allow per-property allow-wrapping of single overrides:'], ['+") returned true for \'canCreateUsingDelegate()\', but null for \'getDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property); } else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException("Invalid array-delegate-creator definition for "+_collectionType +": value instantiator ("+_valueInstantiator.getClass().getName() +") returned true for \'canCreateUsingArrayDelegate()\', but null for \'getArrayDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property); } } // [databind#1043]: allow per-property allow-wrapping of single overrides:'], [''], ['} else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException("Invalid array-delegate-creator definition for "+_collectionType +": value instantiator ("+_valueInstantiator.getClass().getName() +") returned true for \'canCreateUsingArrayDelegate()\', but null for \'getArrayDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java']
['JacksonDatabind-63', 2, 2, 2, 2, [' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.util.ClassUtil; /** * Checked exception used to signal fatal problems with mapping of', "// butt-ugly for arrays. // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good // as it drops enclosing class. So let's try bit different approach String pkgName = ClassUtil.getPackageName(cls); if (pkgName != null) { sb.append(pkgName); sb.append('.'); } sb.append(cls.getSimpleName()); } sb.append('['); if (_fieldName != null) {"], [' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; /** * Checked exception used to signal fatal problems with mapping of', '// butt-ugly for arrays. // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good // as it drops enclosing class. So let\'s try bit different approach int arrays = 0; while (cls.isArray()) { cls = cls.getComponentType(); ++arrays; } sb.append(cls.getName()); while (--arrays >= 0) { sb.append("[]"); } /* was: String pkgName = ClassUtil.getPackageName(cls); if (pkgName != null) { sb.append(pkgName); sb.append(\'.\'); } */ } sb.append(\'[\'); if (_fieldName != null) {'], ['import com.fasterxml.jackson.databind.util.ClassUtil;', 'sb.append(cls.getSimpleName());'], ['', 'int arrays = 0; while (cls.isArray()) { cls = cls.getComponentType(); ++arrays; } sb.append(cls.getName()); while (--arrays >= 0) { sb.append("[]"); } /* was: */'], 'a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java', 'b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java']
['JacksonDatabind-64', 1, 1, 1, 1, ['// whereas for global defaults OR per-property overrides, we have more // static definition. Sigh. // First: case of class/type specifying it; try to find POJO property defaults // 16-Oct-2016, tatu: Note: if we can not for some reason create "default instance", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType); } else { valueToSuppress = getDefaultValue(actualType); suppressNulls = true;'], ['// whereas for global defaults OR per-property overrides, we have more // static definition. Sigh. // First: case of class/type specifying it; try to find POJO property defaults Object defaultBean; // 16-Oct-2016, tatu: Note: if we can not for some reason create "default instance", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); } } else { valueToSuppress = getDefaultValue(actualType); suppressNulls = true;'], ['if (_useRealPropertyDefaults) { valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);'], ['Object defaultBean; if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java']
['JacksonDatabind-65', 3, 3, 3, 3, ['return result; } } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: %s", re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// So, of all single-arg static methods: for (AnnotatedMethod am : _classInfo.getStaticMethods()) { // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what if (isFactoryMethod(am)) { // And must take one of expected arg types (or supertype) Class<?> actualArgType = am.getRawParameterType(0); for (Class<?> expArgType : expArgTypes) {', 'final String name = am.getName(); // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg if ("valueOf".equals(name)) { return true; } // [databind#208] Also accept "fromString()", if takes String or CharSequence if ("fromString".equals(name)) {'], ['return result; } } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// So, of all single-arg static methods: for (AnnotatedMethod am : _classInfo.getStaticMethods()) { // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what if (isFactoryMethod(am) && am.getParameterCount() == 1) { // And must take one of expected arg types (or supertype) Class<?> actualArgType = am.getRawParameterType(0); for (Class<?> expArgType : expArgTypes) {', 'final String name = am.getName(); // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg if ("valueOf".equals(name)) { if (am.getParameterCount() == 1) { return true; } } // [databind#208] Also accept "fromString()", if takes String or CharSequence if ("fromString".equals(name)) {'], ['return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: %s", re.getMessage());', 'if (isFactoryMethod(am)) {', ''], ['return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), re.getMessage());', 'if (isFactoryMethod(am) && am.getParameterCount() == 1) {', 'if (am.getParameterCount() == 1) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java']
['JacksonDatabind-66', 3, 3, 3, 3, ['import java.net.URL; import java.util.*; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*;', 'import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; /** * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}', 'if (key == null) { // is this even legal call? return null; } try { // Ugh... should not have to give parser which may or may not be correct one... Object result = _delegate.deserialize(ctxt.getParser(), ctxt); if (result != null) { return result; }'], ['import java.net.URL; import java.util.*; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*;', 'import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; import com.fasterxml.jackson.databind.util.TokenBuffer; /** * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}', 'if (key == null) { // is this even legal call? return null; } TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt); tb.writeString(key); try { // Ugh... should not have to give parser which may or may not be correct one... JsonParser p = tb.asParser(); p.nextToken(); Object result = _delegate.deserialize(p, ctxt); if (result != null) { return result; }'], ['', '', 'Object result = _delegate.deserialize(ctxt.getParser(), ctxt);'], ['import com.fasterxml.jackson.core.JsonParser;', 'import com.fasterxml.jackson.databind.util.TokenBuffer;', 'TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt); tb.writeString(key); JsonParser p = tb.asParser(); p.nextToken(); Object result = _delegate.deserialize(p, ctxt);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java']
['JacksonDatabind-67', 1, 1, 1, 1, ['// the only non-standard thing is this: if (deser == null) { if (type.isEnumType()) { return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); } // and then post-processing if (deser != null) {'], ['// the only non-standard thing is this: if (deser == null) { if (type.isEnumType()) { deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); } } // and then post-processing if (deser != null) {'], ['return _createEnumKeyDeserializer(ctxt, type); deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);'], ['deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java']
['JacksonDatabind-68', 10, 10, 10, 10, ['protected Object deserializeFromObjectUsingNonDefault(JsonParser p, DeserializationContext ctxt) throws IOException { if (_delegateDeserializer != null) { return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); } if (_propertyBasedCreator != null) { return _deserializeUsingPropertyBased(p, ctxt);', 'if (_objectIdReader != null) { return deserializeFromObjectId(p, ctxt); } switch (p.getNumberType()) { case INT: if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '} return _valueInstantiator.createFromInt(ctxt, p.getIntValue()); case LONG: if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromLong(ctxt, p.getLongValue()); } // actually, could also be BigInteger, so: if (_delegateDeserializer != null) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '/* Bit complicated if we have delegating creator; may need to use it, * or might not... */ if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromString()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'NumberType t = p.getNumberType(); // no separate methods for taking float... if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) { if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromDouble()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue()); } // actually, could also be BigDecimal, so: if (_delegateDeserializer != null) { return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); } return ctxt.handleMissingInstantiator(handledType(), p, "no suitable creator method found to deserialize from Number value (%s)",', '*/ public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException { if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromBoolean()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException { // note: can not call `_delegateDeserializer()` since order reversed here: if (_arrayDelegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } } // fallback to non-array delegate if (_delegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { wrapInstantiationProblem(e, ctxt); return null; } } if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { JsonToken t = p.nextToken();', '/** * @since 2.9 */ /* /**********************************************************'], ['protected Object deserializeFromObjectUsingNonDefault(JsonParser p, DeserializationContext ctxt) throws IOException { final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { return _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); } if (_propertyBasedCreator != null) { return _deserializeUsingPropertyBased(p, ctxt);', 'if (_objectIdReader != null) { return deserializeFromObjectId(p, ctxt); } final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); switch (p.getNumberType()) { case INT: if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '} return _valueInstantiator.createFromInt(ctxt, p.getIntValue()); case LONG: if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromLong(ctxt, p.getLongValue()); } // actually, could also be BigInteger, so: if (delegateDeser != null) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '/* Bit complicated if we have delegating creator; may need to use it, * or might not... */ JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromString()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'NumberType t = p.getNumberType(); // no separate methods for taking float... if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) { JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromDouble()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue()); } // actually, could also be BigDecimal, so: JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { return _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); } return ctxt.handleMissingInstantiator(handledType(), p, "no suitable creator method found to deserialize from Number value (%s)",', '*/ public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException { JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromBoolean()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException { // note: can not call `_delegateDeserializer()` since order reversed here: JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer; // fallback to non-array delegate if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { JsonToken t = p.nextToken();', '/** * @since 2.9 */ private final JsonDeserializer<Object> _delegateDeserializer() { JsonDeserializer<Object> deser = _delegateDeserializer; if (deser == null) { deser = _arrayDelegateDeserializer; } return deser; } /* /**********************************************************'], ['if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_arrayDelegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } } if (_delegateDeserializer != null) { try { _delegateDeserializer.deserialize(p, ctxt)); } catch (Exception e) { wrapInstantiationProblem(e, ctxt); return null; }', ''], ['final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer; if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) { delegateDeser.deserialize(p, ctxt));', 'private final JsonDeserializer<Object> _delegateDeserializer() { JsonDeserializer<Object> deser = _delegateDeserializer; if (deser == null) { deser = _arrayDelegateDeserializer; } return deser; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java']
['JacksonDatabind-69', 6, 6, 6, 6, ['SettableBeanProperty[] injectables) { if (creator.getParameterType(0).isCollectionLikeType()) { verifyNonDup(creator, C_ARRAY_DELEGATE, explicit); _arrayDelegateArgs = injectables; } else { verifyNonDup(creator, C_DELEGATE, explicit); _delegateArgs = injectables; } } public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) { verifyNonDup(creator, C_PROPS, explicit); // Better ensure we have no duplicate names either... if (properties.length > 1) { HashMap<String,Integer> names = new HashMap<String,Integer>();', '} } _propertyBasedArgs = properties; } public void addIncompeteParameter(AnnotatedParameter parameter) {', '/** * @return True if specified Creator is to be used */ protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) { final int mask = (1 << typeIndex); _hasNonDefaultCreator = true;', 'if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return; } // both explicit: verify verify = true;', '// otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; } // new type more specific, use it }', '_explicitCreators |= mask; } _creators[typeIndex] = _fixAccess(newOne); } /*'], ['SettableBeanProperty[] injectables) { if (creator.getParameterType(0).isCollectionLikeType()) { if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) { _arrayDelegateArgs = injectables; } } else { if (verifyNonDup(creator, C_DELEGATE, explicit)) { _delegateArgs = injectables; } } } public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) { if (verifyNonDup(creator, C_PROPS, explicit)) { // Better ensure we have no duplicate names either... if (properties.length > 1) { HashMap<String,Integer> names = new HashMap<String,Integer>();', '} } _propertyBasedArgs = properties; } } public void addIncompeteParameter(AnnotatedParameter parameter) {', '/** * @return True if specified Creator is to be used */ protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) { final int mask = (1 << typeIndex); _hasNonDefaultCreator = true;', 'if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return false; } // both explicit: verify verify = true;', '// otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return false; } // new type more specific, use it }', '_explicitCreators |= mask; } _creators[typeIndex] = _fixAccess(newOne); return true; } /*'], ['verifyNonDup(creator, C_ARRAY_DELEGATE, explicit); verifyNonDup(creator, C_DELEGATE, explicit); verifyNonDup(creator, C_PROPS, explicit);', '', 'protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)', 'return;', 'return;', ''], ['if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) { } if (verifyNonDup(creator, C_DELEGATE, explicit)) { } if (verifyNonDup(creator, C_PROPS, explicit)) {', '}', 'protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)', 'return false;', 'return false;', 'return true;'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java']
['JacksonDatabind-70', 1, 1, 1, 1, ['if (!found) { // 09-Jan-2017, tatu: Important: must check name slot and NOT property name, // as only former is lower-case in case-insensitive case found = key.equals(prop.getName()); if (found) { // need to leave a hole here _propsInOrder[_findFromOrdered(prop)] = null;'], ['if (!found) { // 09-Jan-2017, tatu: Important: must check name slot and NOT property name, // as only former is lower-case in case-insensitive case found = key.equals(_hashArea[i-1]); if (found) { // need to leave a hole here _propsInOrder[_findFromOrdered(prop)] = null;'], ['found = key.equals(prop.getName());'], ['found = key.equals(_hashArea[i-1]);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java']
['JacksonDatabind-71', 1, 1, 1, 1, ['int kind; // first common types: if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID;'], ['int kind; // first common types: if (raw == String.class || raw == Object.class || raw == CharSequence.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID;'], ['if (raw == String.class || raw == Object.class) {'], ['if (raw == String.class || raw == Object.class || raw == CharSequence.class) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java']
['JacksonDatabind-72', 2, 2, 2, 2, ['@Override public int getPropertyIndex() { return _delegate.getPropertyIndex(); } // // // BeanProperty impl', '} return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null)); } No newline at end of file }'], ['@Override public int getPropertyIndex() { return _delegate.getPropertyIndex(); } @Override public int getCreatorIndex() { return _delegate.getCreatorIndex(); } // // // BeanProperty impl', '} return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null)); } } No newline at end of file'], ['', '}'], ['@Override public int getCreatorIndex() { return _delegate.getCreatorIndex(); }', '}'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java']
['JacksonDatabind-73', 4, 4, 4, 4, ['import java.util.*; import com.fasterxml.jackson.annotation.JsonAnySetter; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig;', 'while (it.hasNext()) { POJOPropertyBuilder prop = it.next(); // 26-Jan-2017, tatu: [databind#935]: need to denote removal of prop.removeNonVisible(inferMutators); } }', '* @param inferMutators Whether mutators can be "pulled in" by visible * accessors or not. */ public void removeNonVisible(boolean inferMutators) { /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition * of explicit access type for property; if not "AUTO", it will', '_setters = _removeNonVisible(_setters); } } } /**'], ['import java.util.*; import com.fasterxml.jackson.annotation.JsonAnySetter; import com.fasterxml.jackson.annotation.JsonProperty.Access; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig;', 'while (it.hasNext()) { POJOPropertyBuilder prop = it.next(); // 26-Jan-2017, tatu: [databind#935]: need to denote removal of Access acc = prop.removeNonVisible(inferMutators); if (!_forSerialization && (acc == Access.READ_ONLY)) { _collectIgnorals(prop.getName()); } } }', '* @param inferMutators Whether mutators can be "pulled in" by visible * accessors or not. */ public JsonProperty.Access removeNonVisible(boolean inferMutators) { /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition * of explicit access type for property; if not "AUTO", it will', '_setters = _removeNonVisible(_setters); } } return acc; } /**'], ['', 'prop.removeNonVisible(inferMutators);', 'public void removeNonVisible(boolean inferMutators)', ''], ['import com.fasterxml.jackson.annotation.JsonProperty.Access;', 'Access acc = prop.removeNonVisible(inferMutators); if (!_forSerialization && (acc == Access.READ_ONLY)) { _collectIgnorals(prop.getName()); }', 'public JsonProperty.Access removeNonVisible(boolean inferMutators)', 'return acc;'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java']
['JacksonDatabind-74', 1, 1, 1, 1, ['// or, something for which "as-property" won\'t work, changed into "wrapper-array" type: if (p.getCurrentToken() == JsonToken.START_ARRAY) { return super.deserializeTypedFromAny(p, ctxt); } ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, "missing property \'"+_typePropertyName+"\' that is to contain type id (for class "+baseTypeName()+")");'], ['// or, something for which "as-property" won\'t work, changed into "wrapper-array" type: if (p.getCurrentToken() == JsonToken.START_ARRAY) { return super.deserializeTypedFromAny(p, ctxt); } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } } } ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, "missing property \'"+_typePropertyName+"\' that is to contain type id (for class "+baseTypeName()+")");'], [''], ['} else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java']
['JacksonDatabind-75', 3, 3, 3, 3, ['* handle toString() case dynamically (for example) */ EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass); Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true); return new EnumSerializer(v, serializeAsIndex); }', 'property, handledType()); if (format != null) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); if (serializeAsIndex != _serializeAsIndex) { return new EnumSerializer(_values, serializeAsIndex); }', '* index (number) or not. */ protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { JsonFormat.Shape shape = (format == null) ? null : format.getShape(); if (shape == null) { return null; } // i.e. "default", check dynamically if (shape == Shape.ANY || shape == Shape.SCALAR) { return null; } // 19-May-2016, tatu: also consider "natural" shape if (shape == Shape.STRING || shape == Shape.NATURAL) {'], ['* handle toString() case dynamically (for example) */ EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass); Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true, null); return new EnumSerializer(v, serializeAsIndex); }', 'property, handledType()); if (format != null) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false, _serializeAsIndex); if (serializeAsIndex != _serializeAsIndex) { return new EnumSerializer(_values, serializeAsIndex); }', '* index (number) or not. */ protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass, Boolean defaultValue) { JsonFormat.Shape shape = (format == null) ? null : format.getShape(); if (shape == null) { return defaultValue; } // i.e. "default", check dynamically if (shape == Shape.ANY || shape == Shape.SCALAR) { return defaultValue; } // 19-May-2016, tatu: also consider "natural" shape if (shape == Shape.STRING || shape == Shape.NATURAL) {'], ['Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);', 'format, false);', 'JsonFormat.Value format, boolean fromClass) return null; return null;'], ['Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true, null);', 'format, false, _serializeAsIndex);', 'JsonFormat.Value format, boolean fromClass, Boolean defaultValue) return defaultValue; return defaultValue;'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java']
['JacksonDatabind-76', 1, 1, 1, 1, ['// creator property? SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException("Can not create polymorphic instances with unwrapped values"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } continue; } // Object Id property?'], ['// creator property? SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt)); continue; } // Object Id property?'], ['if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException("Can not create polymorphic instances with unwrapped values"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); }'], ['buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java']
['JacksonDatabind-77', 2, 2, 2, 2, ['return null; } // For checks like [databind#1599] // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. }'], ['return null; } // For checks like [databind#1599] checkIllegalTypes(ctxt, type, beanDesc); // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. Class<?> raw = type.getRawClass(); String name = raw.getSimpleName(); if ("TemplatesImpl".equals(name)) { // [databind#1599] if (raw.getName().startsWith("com.sun.org.apache.xalan")) { throw JsonMappingException.from(ctxt, String.format("Illegal type (%s) to deserialize: prevented for security reasons", name)); } } } }'], ['', ''], ['checkIllegalTypes(ctxt, type, beanDesc);', 'protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); String name = raw.getSimpleName(); if ("TemplatesImpl".equals(name)) { // [databind#1599] if (raw.getName().startsWith("com.sun.org.apache.xalan")) { throw JsonMappingException.from(ctxt, String.format("Illegal type (%s) to deserialize: prevented for security reasons", name)); } } }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-78', 3, 3, 3, 3, ['* * @since 2.8.9 */ // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599] /** * Set of class names of types that are never to be deserialized. * * @since 2.8.9 */ /* /**********************************************************', 'return null; } // For checks like [databind#1599] // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. }'], ['* * @since 2.8.9 */ protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<>(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599] s.add("org.apache.commons.collections.functors.InvokerTransformer"); s.add("org.apache.commons.collections.functors.InstantiateTransformer"); s.add("org.apache.commons.collections4.functors.InvokerTransformer"); s.add("org.apache.commons.collections4.functors.InstantiateTransformer"); s.add("org.codehaus.groovy.runtime.ConvertedClosure"); s.add("org.codehaus.groovy.runtime.MethodClosure"); s.add("org.springframework.beans.factory.ObjectFactory"); s.add("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } /** * Set of class names of types that are never to be deserialized. * * @since 2.8.9 */ protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES; /* /**********************************************************', 'return null; } // For checks like [databind#1599] checkIllegalTypes(ctxt, type, beanDesc); // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. String full = type.getRawClass().getName(); if (_cfgIllegalClassNames.contains(full)) { ctxt.reportBadTypeDefinition(beanDesc, "Illegal type (%s) to deserialize: prevented for security reasons", full); } } }'], ['', '', ''], ['protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<>(); s.add("org.apache.commons.collections.functors.InvokerTransformer"); s.add("org.apache.commons.collections.functors.InstantiateTransformer"); s.add("org.apache.commons.collections4.functors.InvokerTransformer"); s.add("org.apache.commons.collections4.functors.InstantiateTransformer"); s.add("org.codehaus.groovy.runtime.ConvertedClosure"); s.add("org.codehaus.groovy.runtime.MethodClosure"); s.add("org.springframework.beans.factory.ObjectFactory"); s.add("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;', 'checkIllegalTypes(ctxt, type, beanDesc);', 'protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { String full = type.getRawClass().getName(); if (_cfgIllegalClassNames.contains(full)) { ctxt.reportBadTypeDefinition(beanDesc, "Illegal type (%s) to deserialize: prevented for security reasons", full); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-79', 4, 4, 4, 4, ['@Override public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class); if (ref != null) { objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); } return objectIdInfo; } /*', '/** * @since 2.8.9 */ public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen, Class<? extends ObjectIdResolver> resolver)', '_resolver = resolver; } public ObjectIdInfo withAlwaysAsId(boolean state) { if (_alwaysAsId == state) {', "if (objectIdInfo == null) { // no ObjectId override, but maybe ObjectIdRef? if (oiw != null) { objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null)); oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); } } else { // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it"], ['@Override public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class); if (ref == null) { return objectIdInfo; } if (objectIdInfo == null) { objectIdInfo = ObjectIdInfo.empty(); } return objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); } /*', '/** * @since 2.8.9 */ private final static ObjectIdInfo EMPTY = new ObjectIdInfo(PropertyName.NO_NAME, Object.class, null, false, null); public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen, Class<? extends ObjectIdResolver> resolver)', '_resolver = resolver; } public static ObjectIdInfo empty() { return EMPTY; } public ObjectIdInfo withAlwaysAsId(boolean state) { if (_alwaysAsId == state) {', "if (objectIdInfo == null) { // no ObjectId override, but maybe ObjectIdRef? if (oiw != null) { objectIdInfo = intr.findObjectReferenceInfo(accessor, null); if (objectIdInfo != null) { oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); } } } else { // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it"], ['if (ref != null) { objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); return objectIdInfo;', '', '', 'objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));'], ['if (ref == null) { return objectIdInfo; if (objectIdInfo == null) { objectIdInfo = ObjectIdInfo.empty(); } return objectIdInfo.withAlwaysAsId(ref.alwaysAsId());', 'private final static ObjectIdInfo EMPTY = new ObjectIdInfo(PropertyName.NO_NAME, Object.class, null, false, null);', 'public static ObjectIdInfo empty() { return EMPTY; }', 'objectIdInfo = intr.findObjectReferenceInfo(accessor, null); if (objectIdInfo != null) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java']
['JacksonDatabind-80', 3, 3, 3, 3, ['} // then annotated types for property itself Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) {', 'nt.getType()); _collectAndResolve(ac, nt, config, ai, collected); } } NamedType rootType = new NamedType(rawBase, null);', '_collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName); // then with definitions from property Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) { ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType()); _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName); } } // and finally explicit type registrations (highest precedence) if (_registeredSubtypes != null) {'], ['} // then annotated types for property itself if (property != null) { Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) {', 'nt.getType()); _collectAndResolve(ac, nt, config, ai, collected); } } } NamedType rootType = new NamedType(rawBase, null);', '_collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName); // then with definitions from property if (property != null) { Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) { ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType()); _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName); } } } // and finally explicit type registrations (highest precedence) if (_registeredSubtypes != null) {'], ['', '', ''], ['if (property != null) {', '}', 'if (property != null) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java']
['JacksonDatabind-81', 7, 7, 7, 7, ['type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related",', 'keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements } else { throw new JsonMappingException(null, String.format("Can not refine serialization key type %s into %s; types not related",', 'contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements } else { throw new JsonMappingException(null, String.format("Can not refine serialization content type %s into %s; types not related",', ' // Ok: start by refining the main type itself; common to all types final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as()); if ((valueClass != null) && !type.hasRawClass(valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) {', 'if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs()); if (keyClass != null) { try { keyType = tf.constructSpecializedType(keyType, keyClass); type = ((MapLikeType) type).withKeyType(keyType);', 'if (contentType != null) { // collection[like], map[like], array, reference // And then value types for all containers: final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs()); if (contentClass != null) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType);', 'return StdTypeResolverBuilder.noTypeInfoBuilder(); } }'], ['type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else if (_primitiveAndWrapper(currRaw, serClass)) { // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements type = type.withStaticTyping(); } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related",', 'keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); } else if (_primitiveAndWrapper(currRaw, keyClass)) { // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements keyType = keyType.withStaticTyping(); } else { throw new JsonMappingException(null, String.format("Can not refine serialization key type %s into %s; types not related",', 'contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); } else if (_primitiveAndWrapper(currRaw, contentClass)) { // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements contentType = contentType.withStaticTyping(); } else { throw new JsonMappingException(null, String.format("Can not refine serialization content type %s into %s; types not related",', ' // Ok: start by refining the main type itself; common to all types final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as()); if ((valueClass != null) && !type.hasRawClass(valueClass) && !_primitiveAndWrapper(type, valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) {', 'if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs()); if ((keyClass != null) && !_primitiveAndWrapper(keyType, keyClass)) { try { keyType = tf.constructSpecializedType(keyType, keyClass); type = ((MapLikeType) type).withKeyType(keyType);', 'if (contentType != null) { // collection[like], map[like], array, reference // And then value types for all containers: final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs()); if ((contentClass != null) && !_primitiveAndWrapper(contentType, contentClass)) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType);', 'return StdTypeResolverBuilder.noTypeInfoBuilder(); } private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType == ClassUtil.primitiveType(refinement); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType); } return false; } private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType.hasRawClass(ClassUtil.primitiveType(refinement)); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType.getRawClass()); } return false; } }'], ['', '', '', 'if ((valueClass != null) && !type.hasRawClass(valueClass)) {', 'if (keyClass != null) {', 'if (contentClass != null) {', ''], ['} else if (_primitiveAndWrapper(currRaw, serClass)) { type = type.withStaticTyping();', '} else if (_primitiveAndWrapper(currRaw, keyClass)) { keyType = keyType.withStaticTyping();', '} else if (_primitiveAndWrapper(currRaw, contentClass)) { contentType = contentType.withStaticTyping();', 'if ((valueClass != null) && !type.hasRawClass(valueClass) && !_primitiveAndWrapper(type, valueClass)) {', 'if ((keyClass != null) && !_primitiveAndWrapper(keyType, keyClass)) {', 'if ((contentClass != null) && !_primitiveAndWrapper(contentType, contentClass)) {', 'private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType == ClassUtil.primitiveType(refinement); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType); } return false; } private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType.hasRawClass(ClassUtil.primitiveType(refinement)); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType.getRawClass()); } return false; }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java']
['JacksonDatabind-82', 1, 1, 1, 1, ['boolean ignoreAny = ignorals.getIgnoreUnknown(); builder.setIgnoreUnknownProperties(ignoreAny); // Or explicit/implicit definitions? ignored = ignorals.getIgnored(); for (String propName : ignored) { builder.addIgnorable(propName); }'], ['boolean ignoreAny = ignorals.getIgnoreUnknown(); builder.setIgnoreUnknownProperties(ignoreAny); // Or explicit/implicit definitions? ignored = ignorals.findIgnoredForDeserialization(); for (String propName : ignored) { builder.addIgnorable(propName); }'], ['ignored = ignorals.getIgnored();'], ['ignored = ignorals.findIgnoredForDeserialization();'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-83', 1, 1, 1, 1, ['// 19-May-2017, tatu: Used to require non-null result (assuming `null` // indicated error; but that seems wrong. Should be able to return // `null` as value. if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); } } catch (IllegalArgumentException iae) { cause = iae; } catch (MalformedURLException me) {'], ['// 19-May-2017, tatu: Used to require non-null result (assuming `null` // indicated error; but that seems wrong. Should be able to return // `null` as value. return _deserialize(text, ctxt); } catch (IllegalArgumentException iae) { cause = iae; } catch (MalformedURLException me) {'], ['if (_deserialize(text, ctxt) != null) { }'], [''], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java']
['JacksonDatabind-84', 1, 1, 1, 1, ['_referencedType = ref; } public JavaType getSelfReferencedType() { return _referencedType; }'], ['_referencedType = ref; } @Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); } public JavaType getSelfReferencedType() { return _referencedType; }'], [''], ['@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java']
['JacksonDatabind-85', 1, 1, 1, 1, [" // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky.. // First: custom pattern will override things if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: // Jackson's own `StdDateFormat` is quite easy to deal with... // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types // serializers.reportBadDefinition(handledType(), String.format( // Ugh. No way to change `Locale`, create copy; must re-crete completely: return this; } /*"], [' // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky.. // First: custom pattern will override things if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); // Jackson\'s own `StdDateFormat` is quite easy to deal with... if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } // 08-Jun-2017, tatu: Unfortunately there\'s no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can\'t config other types if (!(df0 instanceof SimpleDateFormat)) { // serializers.reportBadDefinition(handledType(), String.format( serializers.reportMappingProblem( "Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { // Ugh. No way to change `Locale`, create copy; must re-crete completely: df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); } /*'], ['if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } return this;'], ['if (format.hasPattern()) { SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportMappingProblem( "Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java']
['JacksonDatabind-86', 1, 1, 1, 1, ['_referencedType = ref; } public JavaType getSelfReferencedType() { return _referencedType; }'], ['_referencedType = ref; } @Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); } public JavaType getSelfReferencedType() { return _referencedType; }'], [''], ['@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java']
['JacksonDatabind-87', 8, 8, 8, 8, ['* * @since 2.8.10 */ /** * ISO-8601 with just the Date part, no time', 'protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN };', ' protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN;', 'DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); }', 'protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; /*', "} } else { // If not, plain date, no timezone StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; // And possible also millisecond part if missing if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0');", 'default: sb.append(".000"); } } sb.append(\'Z\'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { // 10-Jun-2017, tatu: As per [databind#1651], when using this format, // must use UTC, not whatever is configured as default timezone // (because we know `Z` identifier is used) df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } }', '_formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }'], ['* * @since 2.8.10 */ protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = "yyyy-MM-dd\'T\'HH:mm:ss.SSS"; /** * ISO-8601 with just the Date part, no time', 'protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_ISO8601_NO_TZ, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN };', ' protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10 protected final static DateFormat DATE_FORMAT_PLAIN;', 'DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); }', 'protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatISO8601_noTz; // 2.8.10 protected transient DateFormat _formatPlain; /*', "} } else { // If not, plain date, no timezone int timeLen = len - dateStr.lastIndexOf('T') - 1; // And possible also millisecond part if missing if (timeLen < 12) { // missing, or partial StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0');", 'default: sb.append(".000"); } dateStr = sb.toString(); } df = _formatISO8601_noTz; formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ; if (df == null) { // 10-Jun-2017, tatu: As per [databind#1651], when using this format, // must use UTC, not whatever is configured as default timezone // (because we know `Z` identifier is used) df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr, _timezone, _locale, _lenient); } } }', '_formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatISO8601_noTz = null; _formatPlain = null; }'], ['', '', '', '', '', 'StringBuilder sb = new StringBuilder(dateStr);', "sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);", ''], ['protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = "yyyy-MM-dd\'T\'HH:mm:ss.SSS";', 'DATE_FORMAT_STR_ISO8601_NO_TZ,', 'protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10', 'DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);', 'protected transient DateFormat _formatISO8601_noTz; // 2.8.10', 'StringBuilder sb = new StringBuilder(dateStr);', 'dateStr = sb.toString(); df = _formatISO8601_noTz; formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ; df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr, _timezone, _locale, _lenient);', '_formatISO8601_noTz = null;'], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-88', 1, 1, 1, 1, ["// compatibility -- needed later anyway, and not doing so may open // security issues. JavaType t = tf.constructFromCanonical(id); // Probably cleaner to have a method in `TypeFactory` but can't add in patch return t; } Class<?> cls;"], ['// compatibility -- needed later anyway, and not doing so may open // security issues. JavaType t = tf.constructFromCanonical(id); if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { // Probably cleaner to have a method in `TypeFactory` but can\'t add in patch throw new IllegalArgumentException(String.format( "Class %s not subtype of %s", t.getRawClass().getName(), _baseType)); } return t; } Class<?> cls;'], [''], ['if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { throw new IllegalArgumentException(String.format( "Class %s not subtype of %s", t.getRawClass().getName(), _baseType)); }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java']
['JacksonDatabind-89', 1, 1, 1, 1, ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided // [databind#1737]; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); // [databind#1737]; 3rd party s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], [''], ['s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-90', 2, 2, 2, 2, ['*/ public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean();', 'return (_withArgsCreator != null); } @Override public JavaType getDelegateType(DeserializationConfig config) {'], ['*/ public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateUsingArrayDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean();', 'return (_withArgsCreator != null); } @Override public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateUsingArrayDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); } @Override public JavaType getDelegateType(DeserializationConfig config) {'], ['|| canCreateUsingDelegate()', ''], ['|| canCreateUsingDelegate() || canCreateUsingArrayDelegate()', '@Override public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateUsingArrayDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java']
['JacksonDatabind-91', 1, 1, 1, 1, ['// First: value types may have both value and type handlers JavaType ct = t.getContentType(); if (ct != null) { return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null); // Second: map(-like) types may have value handler for key (but not type; keys are untyped) } } return false;'], ['// First: value types may have both value and type handlers JavaType ct = t.getContentType(); if (ct != null) { if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } // Second: map(-like) types may have value handler for key (but not type; keys are untyped) if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; } } } return false;'], ['return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);'], ['if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java']
['JacksonDatabind-92', 1, 1, 1, 1, ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided // [databind#1737]; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); // [databind#1737]; 3rd party s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], [''], ['s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-93', 1, 1, 1, 1, ['// 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling // for some Spring framework types // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); // looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there? if ("AbstractPointcutAdvisor".equals(name)'], ['// 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling // for some Spring framework types // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) { String name = cls.getSimpleName(); // looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there? if ("AbstractPointcutAdvisor".equals(name)'], ['if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {'], ['if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java']
['JacksonDatabind-94', 2, 2, 2, 2, ['{ protected final static String PREFIX_SPRING = "org.springframework."; /** * Set of well-known "nasty classes", deserialization of which is considered dangerous', '|| "AbstractApplicationContext".equals(name)) { break main_check; } // [databind#1737]; more 3rd party // s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); // s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); // [databind#1931]; more 3rd party // com.mchange.v2.c3p0.ComboPooledDataSource // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource } } return;'], ['{ protected final static String PREFIX_SPRING = "org.springframework."; protected final static String PREFIX_C3P0 = "com.mchange.v2.c3p0."; /** * Set of well-known "nasty classes", deserialization of which is considered dangerous', '|| "AbstractApplicationContext".equals(name)) { break main_check; } } } else if (full.startsWith(PREFIX_C3P0)) { // [databind#1737]; more 3rd party // s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); // s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); // [databind#1931]; more 3rd party // com.mchange.v2.c3p0.ComboPooledDataSource // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource if (full.endsWith("DataSource")) { break main_check; } } return;'], ['', ''], ['protected final static String PREFIX_C3P0 = "com.mchange.v2.c3p0.";', '} } else if (full.startsWith(PREFIX_C3P0)) { if (full.endsWith("DataSource")) { break main_check;'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java']
['JacksonDatabind-95', 4, 4, 4, 4, ['// also: if we start from untyped, not much to save do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) {', ' // (1) Original target type has no generics -- just resolve subtype if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } // (2) A small set of "well-known" List/Map subtypes where can take a short-cut', 'int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); }', "// can be comma that separates types, or closing '>' tokens.pushBack(token); } return _factory._fromClass(null, base, null); } protected List<JavaType> parseTypes(MyTokenizer tokens)"], ['// also: if we start from untyped, not much to save do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, EMPTY_BINDINGS); break; } if (!rawBase.isAssignableFrom(subclass)) {', ' // (1) Original target type has no generics -- just resolve subtype if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, EMPTY_BINDINGS); break; } // (2) A small set of "well-known" List/Map subtypes where can take a short-cut', 'int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS); } return constructParametricType(parametrized, pt); }', "// can be comma that separates types, or closing '>' tokens.pushBack(token); } return _factory._fromClass(null, base, TypeBindings.emptyBindings()); } protected List<JavaType> parseTypes(MyTokenizer tokens)"], ['newType = _fromClass(null, subclass, TypeBindings.emptyBindings());', 'newType = _fromClass(null, subclass, TypeBindings.emptyBindings());', 'pt[i] = _fromClass(null, parameterClasses[i], null);', 'return _factory._fromClass(null, base, null);'], ['newType = _fromClass(null, subclass, EMPTY_BINDINGS);', 'newType = _fromClass(null, subclass, EMPTY_BINDINGS);', 'pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);', 'return _factory._fromClass(null, base, TypeBindings.emptyBindings());'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java']
['JacksonDatabind-96', 1, 1, 1, 1, ['// 25-May-2018, tatu: as per [databind#2051], looks like we have to get // not implicit name, but name with possible strategy-based-rename // paramName = candidate.findImplicitParamName(0); paramName = candidate.findImplicitParamName(0); useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) {'], ['// 25-May-2018, tatu: as per [databind#2051], looks like we have to get // not implicit name, but name with possible strategy-based-rename // paramName = candidate.findImplicitParamName(0); paramName = candidate.paramName(0); useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) {'], ['paramName = candidate.findImplicitParamName(0);'], ['paramName = candidate.paramName(0);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java']
['JacksonDatabind-97', 1, 1, 1, 1, ['} else { // 25-May-2018, tatu: [databind#1991] do not call via generator but through context; // this to preserve contextual information gen.writeObject(_value); } }'], ['} else { // 25-May-2018, tatu: [databind#1991] do not call via generator but through context; // this to preserve contextual information ctxt.defaultSerializeValue(_value, gen); } }'], ['gen.writeObject(_value);'], ['ctxt.defaultSerializeValue(_value, gen);'], 'a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java']
['JacksonDatabind-98', 1, 1, 1, 1, ['if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) { // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to // apply deserializer... fun fun. buffer.assignParameter(typeProp, typeId); } } }'], ['if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) { // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to // apply deserializer... fun fun. final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v); } } }'], ['buffer.assignParameter(typeProp, typeId);'], ['final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java']
['JacksonDatabind-99', 1, 1, 1, 1, ["sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toCanonical()); return sb.toString(); }"], ["sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toCanonical()); sb.append('>'); return sb.toString(); }"], [''], ["sb.append('>');"], 'a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java']
['JacksonDatabind-100', 1, 1, 1, 1, ['if (n != null) { // [databind#2096]: although `binaryValue()` works for real binary node // and embedded "POJO" node, coercion from TextNode may require variant, so: byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; } } } // otherwise return null to mark we have no binary content return null;'], ['if (n != null) { // [databind#2096]: although `binaryValue()` works for real binary node // and embedded "POJO" node, coercion from TextNode may require variant, so: if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); } return n.binaryValue(); } // otherwise return null to mark we have no binary content return null;'], ['byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; }'], ['if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); return n.binaryValue();'], 'a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java']
['JacksonDatabind-101', 1, 1, 1, 1, ["// if so, need to copy all remaining tokens into buffer while (t == JsonToken.FIELD_NAME) { // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some // problems if we maintain invariants tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { // !!! 08-Jul-2011, tatu: Could probably support; but for now"], ['// if so, need to copy all remaining tokens into buffer while (t == JsonToken.FIELD_NAME) { // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that tokens.copyCurrentStructure(p); t = p.nextToken(); } // 28-Aug-2018, tatu: Let\'s add sanity check here, easier to catch off-by-some // problems if we maintain invariants if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, "Attempted to unwrap \'%s\' value", handledType().getName()); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { // !!! 08-Jul-2011, tatu: Could probably support; but for now'], ['p.nextToken();'], ['if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, "Attempted to unwrap \'%s\' value", handledType().getName()); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java']
['JacksonDatabind-102', 1, 1, 1, 1, ["{ // Note! Should not skip if `property` null since that'd skip check // for config overrides, in case of root value if (property == null) { return this; } JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this;"], ["{ // Note! Should not skip if `property` null since that'd skip check // for config overrides, in case of root value JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this;"], ['if (property == null) { return this; }'], [''], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java']
['JacksonDatabind-103', 26, 26, 26, 26, ['throw invalidTypeIdException(baseType, subClass, String.format( "problem: (%s) %s", e.getClass().getName(), e.getMessage())); } if (baseType.isTypeOrSuperTypeOf(cls)) { return getTypeFactory().constructSpecializedType(baseType, cls);', '} catch (ParseException e) { throw new IllegalArgumentException(String.format( "Failed to parse Date value \'%s\': %s", dateStr, e.getMessage())); } }', 'String excMsg; if (cause == null) { excMsg = "N/A"; } else if ((excMsg = cause.getMessage()) == null) { excMsg = ClassUtil.nameOf(cause.getClass()); } String msg = String.format("Cannot construct instance of %s, problem: %s",', ' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; /** * Checked exception used to signal fatal problems with mapping of', 'return new JsonMappingException(null, String.format("Unexpected IOException (of type %s): %s", src.getClass().getName(), src.getMessage())); } /**', 'jme = (JsonMappingException) src; } else { // [databind#2128]: try to avoid duplication String msg = src.getMessage(); // Let\'s use a more meaningful placeholder if all we have is null if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")";', "// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; // doesn't matter but compiler whines otherwise reportMappingProblem(iae, iae.getMessage()); } if (ser != null) {", '// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; reportMappingProblem(iae, iae.getMessage()); } if (ser != null) {', 'return b.buildTypeDeserializer(config, baseType, subtypes); } catch (IllegalArgumentException e0) { InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType); e.initCause(e0); throw e; }', "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null); } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);", "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null); } final DeserializationConfig config = ctxt.getConfig();", '} catch (IllegalArgumentException iae) { // We better only expose checked exceptions, since those // are what caller is expected to handle throw JsonMappingException.from(ctxt, iae.getMessage(), iae); } if (deser == null) { return null;', 'StringBuilder msg = new StringBuilder("Problem deserializing \\"any\\" property \'").append(propName); msg.append("\' of class "+getClassName()+" (expected type: ").append(_type); msg.append("; actual type: ").append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ").append(origMsg); } else {', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable t = ClassUtil.getRootCause(e); throw new JsonMappingException(null, t.getMessage(), t); } private String getClassName() { return _setter.getDeclaringClass().getName(); }", '.append(getType()) .append("; actual type: ") .append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ") .append(origMsg);', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable th = ClassUtil.getRootCause(e); throw JsonMappingException.from(p, th.getMessage(), th); } @Deprecated // since 2.7", '} catch (IllegalArgumentException iae) { return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value, "not a valid representation (error: %s)", iae.getMessage()); } }', '} catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// @since 2.9 protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException { return ctxt.handleWeirdKey(_keyClass, key, "problem: %s", e.getMessage()); } /*', '} } return new JsonMappingException(null, "Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t); } /**', 'ClassUtil.throwIfRTE(t); throw new IllegalArgumentException("Failed to instantiate bean of type " +_classInfo.getAnnotated().getName()+": ("+t.getClass().getName()+") " +t.getMessage(), t); } }', '} catch (Throwable t) { String msg = String.format( "Problem determining whether filter of type \'%s\' should filter out `null` values: (%s) %s", filter.getClass().getName(), t.getClass().getName(), t.getMessage()); reportBadDefinition(filter.getClass(), msg, t); return false; // never gets here }', 'if (e instanceof IOException) { return (IOException) e; } String msg = e.getMessage(); if (msg == null) { msg = "[no message for "+e.getClass().getName()+"]"; }', 'serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); } catch (JsonMappingException e) { if (propDef == null) { return prov.reportBadDefinition(declaredType, e.getMessage()); } return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage()); } // Container types can have separate type serializers for content (value / element) type', 'import java.util.*; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.JsonMappingException;', '* * @since 2.9.7 */ /* /**********************************************************'], ['throw invalidTypeIdException(baseType, subClass, String.format( "problem: (%s) %s", e.getClass().getName(), ClassUtil.exceptionMessage(e))); } if (baseType.isTypeOrSuperTypeOf(cls)) { return getTypeFactory().constructSpecializedType(baseType, cls);', '} catch (ParseException e) { throw new IllegalArgumentException(String.format( "Failed to parse Date value \'%s\': %s", dateStr, ClassUtil.exceptionMessage(e))); } }', 'String excMsg; if (cause == null) { excMsg = "N/A"; } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) { excMsg = ClassUtil.nameOf(cause.getClass()); } String msg = String.format("Cannot construct instance of %s, problem: %s",', ' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.util.ClassUtil; /** * Checked exception used to signal fatal problems with mapping of', 'return new JsonMappingException(null, String.format("Unexpected IOException (of type %s): %s", src.getClass().getName(), ClassUtil.exceptionMessage(src))); } /**', 'jme = (JsonMappingException) src; } else { // [databind#2128]: try to avoid duplication String msg = ClassUtil.exceptionMessage(src); // Let\'s use a more meaningful placeholder if all we have is null if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")";', "// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; // doesn't matter but compiler whines otherwise reportMappingProblem(iae, ClassUtil.exceptionMessage(iae)); } if (ser != null) {", '// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; reportMappingProblem(iae, ClassUtil.exceptionMessage(iae)); } if (ser != null) {', 'return b.buildTypeDeserializer(config, baseType, subtypes); } catch (IllegalArgumentException e0) { InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, ClassUtil.exceptionMessage(e0), baseType); e.initCause(e0); throw e; }', "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), ClassUtil.exceptionMessage(e), beanDesc, null); } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);", "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), ClassUtil.exceptionMessage(e), builderDesc, null); } final DeserializationConfig config = ctxt.getConfig();", '} catch (IllegalArgumentException iae) { // We better only expose checked exceptions, since those // are what caller is expected to handle throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae); } if (deser == null) { return null;', 'StringBuilder msg = new StringBuilder("Problem deserializing \\"any\\" property \'").append(propName); msg.append("\' of class "+getClassName()+" (expected type: ").append(_type); msg.append("; actual type: ").append(actType).append(")"); String origMsg = ClassUtil.exceptionMessage(e); if (origMsg != null) { msg.append(", problem: ").append(origMsg); } else {', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable t = ClassUtil.getRootCause(e); throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t); } private String getClassName() { return _setter.getDeclaringClass().getName(); }", '.append(getType()) .append("; actual type: ") .append(actType).append(")"); String origMsg = ClassUtil.exceptionMessage(e); if (origMsg != null) { msg.append(", problem: ") .append(origMsg);', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable th = ClassUtil.getRootCause(e); throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th); } @Deprecated // since 2.7", '} catch (IllegalArgumentException iae) { return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value, "not a valid representation (error: %s)", ClassUtil.exceptionMessage(iae)); } }', '} catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), ClassUtil.exceptionMessage(re)); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// @since 2.9 protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException { return ctxt.handleWeirdKey(_keyClass, key, "problem: %s", ClassUtil.exceptionMessage(e)); } /*', '} } return new JsonMappingException(null, "Instantiation of "+getValueTypeDesc()+" value failed: "+ClassUtil.exceptionMessage(t), t); } /**', 'ClassUtil.throwIfRTE(t); throw new IllegalArgumentException("Failed to instantiate bean of type " +_classInfo.getAnnotated().getName()+": ("+t.getClass().getName()+") " +ClassUtil.exceptionMessage(t), t); } }', '} catch (Throwable t) { String msg = String.format( "Problem determining whether filter of type \'%s\' should filter out `null` values: (%s) %s", filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t)); reportBadDefinition(filter.getClass(), msg, t); return false; // never gets here }', 'if (e instanceof IOException) { return (IOException) e; } String msg = ClassUtil.exceptionMessage(e); if (msg == null) { msg = "[no message for "+e.getClass().getName()+"]"; }', 'serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); } catch (JsonMappingException e) { if (propDef == null) { return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e)); } return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e)); } // Container types can have separate type serializers for content (value / element) type', 'import java.util.*; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.JsonMappingException;', '* * @since 2.9.7 */ public static String exceptionMessage(Throwable t) { if (t instanceof JsonProcessingException) { return ((JsonProcessingException) t).getOriginalMessage(); } return t.getMessage(); } /* /**********************************************************'], ['e.getMessage()));', 'e.getMessage()));', '} else if ((excMsg = cause.getMessage()) == null) {', '', 'src.getMessage()));', 'String msg = src.getMessage();', 'reportMappingProblem(iae, iae.getMessage());', 'reportMappingProblem(iae, iae.getMessage());', 'e0.getMessage(), baseType);', 'e.getMessage(),', 'e.getMessage(),', 'throw JsonMappingException.from(ctxt, iae.getMessage(), iae);', 'String origMsg = e.getMessage();', 'throw new JsonMappingException(null, t.getMessage(), t);', 'String origMsg = e.getMessage();', 'throw JsonMappingException.from(p, th.getMessage(), th);', 'iae.getMessage());', 're.getMessage());', 'e.getMessage());', '"Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t);', '+t.getMessage(), t);', 'filter.getClass().getName(), t.getClass().getName(), t.getMessage());', 'String msg = e.getMessage();', 'return prov.reportBadDefinition(declaredType, e.getMessage()); return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());', '', ''], ['ClassUtil.exceptionMessage(e)));', 'ClassUtil.exceptionMessage(e)));', '} else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {', 'import com.fasterxml.jackson.databind.util.ClassUtil;', 'ClassUtil.exceptionMessage(src)));', 'String msg = ClassUtil.exceptionMessage(src);', 'reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));', 'reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));', 'ClassUtil.exceptionMessage(e0), baseType);', 'ClassUtil.exceptionMessage(e),', 'ClassUtil.exceptionMessage(e),', 'throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);', 'String origMsg = ClassUtil.exceptionMessage(e);', 'throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);', 'String origMsg = ClassUtil.exceptionMessage(e);', 'throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);', 'ClassUtil.exceptionMessage(iae));', 'ClassUtil.exceptionMessage(re));', 'ClassUtil.exceptionMessage(e));', '"Instantiation of "+getValueTypeDesc()+" value failed: "+ClassUtil.exceptionMessage(t), t);', '+ClassUtil.exceptionMessage(t), t);', 'filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));', 'String msg = ClassUtil.exceptionMessage(e);', 'return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e)); return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));', 'import com.fasterxml.jackson.core.JsonProcessingException;', 'public static String exceptionMessage(Throwable t) { if (t instanceof JsonProcessingException) { return ((JsonProcessingException) t).getOriginalMessage(); } return t.getMessage(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java']
['JacksonDatabind-104', 3, 3, 3, 3, ["final int year = cal.get(Calendar.YEAR); // Assuming GregorianCalendar, special handling needed for BCE (aka BC) // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but // it seems that plus prefix IS mandated. Padding is an open question, but since agreeement // for max length would be needed, we ewould need to limit to arbitrary length // like five digits (erroring out if beyond or padding to that as minimum). // Instead, let's just print number out as is and let decoder try to make sense of it. pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-');", '} } // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become // "+0000", but rest (from `2` up, in that era) need minus sign. // as with CE, 4 digit variant needs padding; beyond that not (although that part is // open to debate, needs agreement with receiver) // But `pad4()` deals with "big" numbers now so: private static void pad2(StringBuffer buffer, int value) { int tens = value / 10;', "if (h == 0) { buffer.append('0').append('0'); } else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value);"], ["final int year = cal.get(Calendar.YEAR); // Assuming GregorianCalendar, special handling needed for BCE (aka BC) if (cal.get(Calendar.ERA) == GregorianCalendar.BC) { _formatBCEYear(buffer, year); } else { if (year > 9999) { // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but // it seems that plus prefix IS mandated. Padding is an open question, but since agreeement // for max length would be needed, we ewould need to limit to arbitrary length // like five digits (erroring out if beyond or padding to that as minimum). // Instead, let's just print number out as is and let decoder try to make sense of it. buffer.append('+'); } pad4(buffer, year); } buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-');", '} } protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) { // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become // "+0000", but rest (from `2` up, in that era) need minus sign. if (bceYearNoSign == 1) { buffer.append("+0000"); return; } final int isoYear = bceYearNoSign - 1; buffer.append(\'-\'); // as with CE, 4 digit variant needs padding; beyond that not (although that part is // open to debate, needs agreement with receiver) // But `pad4()` deals with "big" numbers now so: pad4(buffer, isoYear); } private static void pad2(StringBuffer buffer, int value) { int tens = value / 10;', "if (h == 0) { buffer.append('0').append('0'); } else { if (h > 99) { // [databind#2167]: handle above 9999 correctly buffer.append(h); } else { pad2(buffer, h); } value -= (100 * h); } pad2(buffer, value);"], ['', '', ''], ["if (cal.get(Calendar.ERA) == GregorianCalendar.BC) { _formatBCEYear(buffer, year); } else { if (year > 9999) { buffer.append('+'); } }", 'protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) { if (bceYearNoSign == 1) { buffer.append("+0000"); return; } final int isoYear = bceYearNoSign - 1; buffer.append(\'-\'); pad4(buffer, isoYear); }', 'if (h > 99) { // [databind#2167]: handle above 9999 correctly buffer.append(h); } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-105', 2, 2, 2, 2, ['UUID.class, AtomicBoolean.class, StackTraceElement.class, ByteBuffer.class }; for (Class<?> cls : types) { _classNames.add(cls.getName()); } for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }', 'if (rawType == ByteBuffer.class) { return new ByteBufferDeserializer(); } } return null; }'], ['UUID.class, AtomicBoolean.class, StackTraceElement.class, ByteBuffer.class, Void.class }; for (Class<?> cls : types) { _classNames.add(cls.getName()); } for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }', 'if (rawType == ByteBuffer.class) { return new ByteBufferDeserializer(); } if (rawType == Void.class) { return NullifyingDeserializer.instance; } } return null; }'], ['ByteBuffer.class', ''], ['ByteBuffer.class, Void.class', 'if (rawType == Void.class) { return NullifyingDeserializer.instance; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java']
['JacksonDatabind-106', 1, 1, 1, 1, ['@Override public int getIntValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); return node.longValue(); }'], ['@Override public int getIntValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowInt(); } return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowLong(); } return node.longValue(); }'], [''], ['if (!node.canConvertToInt()) { reportOverflowInt(); } if (!node.canConvertToInt()) { reportOverflowLong(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java']
['JacksonDatabind-107', 1, 1, 1, 1, ['JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { // what should this be taken to mean? // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but... return null; } // ... would this actually work? deser = ctxt.findContextualValueDeserializer(actual, _property);'], ['JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { // what should this be taken to mean? // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but... return NullifyingDeserializer.instance; } // ... would this actually work? deser = ctxt.findContextualValueDeserializer(actual, _property);'], ['return null;'], ['return NullifyingDeserializer.instance;'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java']
['JacksonDatabind-108', 2, 2, 2, 2, ['@SuppressWarnings("unchecked") @Override public <T extends TreeNode> T readTree(JsonParser p) throws IOException { return (T) _bindAsTree(p); } @Override', '* Same as {@link #_bindAsTree} except end-of-input is reported by returning * {@code null}, not "missing node" */ /** * @since 2.1'], ['@SuppressWarnings("unchecked") @Override public <T extends TreeNode> T readTree(JsonParser p) throws IOException { return (T) _bindAsTreeOrNull(p); } @Override', '* Same as {@link #_bindAsTree} except end-of-input is reported by returning * {@code null}, not "missing node" */ protected final JsonNode _bindAsTreeOrNull(JsonParser p) throws IOException { _config.initialize(p); if (_schema != null) { p.setSchema(_schema); } JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken(); if (t == null) { return null; } } final JsonNode resultNode; if (t == JsonToken.VALUE_NULL) { resultNode = _config.getNodeFactory().nullNode(); } else { final DeserializationContext ctxt = createDeserializationContext(p); final JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt); if (_unwrapRoot) { resultNode = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser); } else { resultNode = (JsonNode) deser.deserialize(p, ctxt); if (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) { _verifyNoTrailingTokens(p, ctxt, JSON_NODE_TYPE); } } } return resultNode; } /** * @since 2.1'], ['return (T) _bindAsTree(p);', ''], ['return (T) _bindAsTreeOrNull(p);', 'protected final JsonNode _bindAsTreeOrNull(JsonParser p) throws IOException { _config.initialize(p); if (_schema != null) { p.setSchema(_schema); } JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken(); if (t == null) { return null; } } final JsonNode resultNode; if (t == JsonToken.VALUE_NULL) { resultNode = _config.getNodeFactory().nullNode(); } else { final DeserializationContext ctxt = createDeserializationContext(p); final JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt); if (_unwrapRoot) { resultNode = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser); } else { resultNode = (JsonNode) deser.deserialize(p, ctxt); if (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) { _verifyNoTrailingTokens(p, ctxt, JSON_NODE_TYPE); } } } return resultNode; }'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java']
['JacksonDatabind-109', 5, 5, 5, 5, ['/** * Copied from `jackson-core` class `GeneratorBase` */ protected final boolean _isInt;', 'switch (format.getShape()) { case STRING: // [databind#2264]: Need special handling for `BigDecimal` return ToStringSerializer.instance; default: }', "/** * @since 2.10 */ // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this // ... but wouldn't it be nice to trigger error via generator? Alas, // no method to do that. So we'll do... // should never be called // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this }", ' import java.io.IOException; import java.lang.reflect.Type; import java.util.Map; import com.fasterxml.jackson.annotation.JsonFormat;', 'if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; default: }'], ['/** * Copied from `jackson-core` class `GeneratorBase` */ protected final static int MAX_BIG_DECIMAL_SCALE = 9999; protected final boolean _isInt;', 'switch (format.getShape()) { case STRING: // [databind#2264]: Need special handling for `BigDecimal` if (((Class<?>) handledType()) == BigDecimal.class) { return bigDecimalAsStringSerializer(); } return ToStringSerializer.instance; default: }', '/** * @since 2.10 */ public static JsonSerializer<?> bigDecimalAsStringSerializer() { return BigDecimalAsStringSerializer.BD_INSTANCE; } final static class BigDecimalAsStringSerializer extends ToStringSerializerBase { final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer(); public BigDecimalAsStringSerializer() { super(BigDecimal.class); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return valueToString(value).isEmpty(); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { final String text; if (gen.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { final BigDecimal bd = (BigDecimal) value; // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this if (!_verifyBigDecimalRange(gen, bd)) { // ... but wouldn\'t it be nice to trigger error via generator? Alas, // no method to do that. So we\'ll do... final String errorMsg = String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", bd.scale(), MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE); provider.reportMappingProblem(errorMsg); } text = bd.toPlainString(); } else { text = value.toString(); } gen.writeString(text); } @Override public String valueToString(Object value) { // should never be called throw new IllegalStateException(); } // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this protected boolean _verifyBigDecimalRange(JsonGenerator gen, BigDecimal value) throws IOException { int scale = value.scale(); return ((scale >= -MAX_BIG_DECIMAL_SCALE) && (scale <= MAX_BIG_DECIMAL_SCALE)); } } }', ' import java.io.IOException; import java.lang.reflect.Type; import java.math.BigDecimal; import java.util.Map; import com.fasterxml.jackson.annotation.JsonFormat;', 'if (format != null) { switch (format.getShape()) { case STRING: if (((Class<?>) handledType()) == BigDecimal.class) { return NumberSerializer.bigDecimalAsStringSerializer(); } return ToStringSerializer.instance; default: }'], ['', '', '', '', ''], ['protected final static int MAX_BIG_DECIMAL_SCALE = 9999;', 'if (((Class<?>) handledType()) == BigDecimal.class) { return bigDecimalAsStringSerializer(); }', 'public static JsonSerializer<?> bigDecimalAsStringSerializer() { return BigDecimalAsStringSerializer.BD_INSTANCE; } final static class BigDecimalAsStringSerializer extends ToStringSerializerBase { final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer(); public BigDecimalAsStringSerializer() { super(BigDecimal.class); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return valueToString(value).isEmpty(); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { final String text; if (gen.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { final BigDecimal bd = (BigDecimal) value; if (!_verifyBigDecimalRange(gen, bd)) { final String errorMsg = String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", bd.scale(), MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE); provider.reportMappingProblem(errorMsg); } text = bd.toPlainString(); } else { text = value.toString(); } gen.writeString(text); } @Override public String valueToString(Object value) { throw new IllegalStateException(); } protected boolean _verifyBigDecimalRange(JsonGenerator gen, BigDecimal value) throws IOException { int scale = value.scale(); return ((scale >= -MAX_BIG_DECIMAL_SCALE) && (scale <= MAX_BIG_DECIMAL_SCALE)); } }', 'import java.math.BigDecimal;', 'if (((Class<?>) handledType()) == BigDecimal.class) { return NumberSerializer.bigDecimalAsStringSerializer(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java']
['JacksonDatabind-110', 3, 3, 3, 3, ['/* 02-Mar-2019, tatu: for [databind#2265], need to consider possible alternate type... * which we essentially coerce into the other one */ private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {', 'CLASS_SINGLETON_LIST = list.getClass(); CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass(); // for [databind#2265] Map<?,?> map = Collections.singletonMap("a", "b"); CLASS_SINGLETON_MAP = map.getClass();', '} else if (type.hasRawClass(CLASS_SINGLETON_SET)) { conv = converter(TYPE_SINGLETON_SET, type, Set.class); // [databind#2265]: we may have another impl type for unmodifiable Lists, check both } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) { conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class); } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) { conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);'], ['/* 02-Mar-2019, tatu: for [databind#2265], need to consider possible alternate type... * which we essentially coerce into the other one */ private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS; private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {', 'CLASS_SINGLETON_LIST = list.getClass(); CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass(); // for [databind#2265] CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass(); Map<?,?> map = Collections.singletonMap("a", "b"); CLASS_SINGLETON_MAP = map.getClass();', '} else if (type.hasRawClass(CLASS_SINGLETON_SET)) { conv = converter(TYPE_SINGLETON_SET, type, Set.class); // [databind#2265]: we may have another impl type for unmodifiable Lists, check both } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) { conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class); } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) { conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);'], ['', '', '} else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {'], ['private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS;', 'CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass();', '} else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java']
['JacksonDatabind-111', 9, 9, 9, 9, ['return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new CreatorProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new FieldProperty(this, deser, _nullProvider); } @Override', 'Object readResolve() { return new FieldProperty(this); } No newline at end of file }', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new MethodProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new ObjectIdReferenceProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new ObjectIdValueProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new SetterlessProperty(this, deser, _nullProvider); } @Override', 'set(instance, value); return instance; } No newline at end of file }', ' @Override public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException { return new AtomicReference<Object>(); } @Override'], ['return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new CreatorProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new FieldProperty(this, deser, nvp); } @Override', 'Object readResolve() { return new FieldProperty(this); } } No newline at end of file', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new MethodProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdReferenceProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdValueProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new SetterlessProperty(this, deser, nvp); } @Override', 'set(instance, value); return instance; } } No newline at end of file', ' @Override public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException { return new AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt)); } @Override'], ['return new CreatorProperty(this, deser, _nullProvider);', 'return new FieldProperty(this, deser, _nullProvider);', '}', 'return new MethodProperty(this, deser, _nullProvider);', 'return new ObjectIdReferenceProperty(this, deser, _nullProvider);', 'return new ObjectIdValueProperty(this, deser, _nullProvider);', 'return new SetterlessProperty(this, deser, _nullProvider);', '}', 'return new AtomicReference<Object>();'], ['NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new CreatorProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new FieldProperty(this, deser, nvp);', '}', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new MethodProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdReferenceProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdValueProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new SetterlessProperty(this, deser, nvp);', '}', 'return new AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt));'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java']
['JacksonDatabind-112', 1, 1, 1, 1, ['JsonDeserializer<Object> delegate = null; if (_valueInstantiator != null) { // [databind#2324]: check both array-delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); }'], ['JsonDeserializer<Object> delegate = null; if (_valueInstantiator != null) { // [databind#2324]: check both array-delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); }'], ['AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();'], ['AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java']
['Closure-1', 1, 1, 1, 1, ["// is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 Node function = fnScope.getRootNode();"], ["// is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 if (!removeGlobals) { return; } Node function = fnScope.getRootNode();"], [''], ['if (!removeGlobals) { return; }'], 'a/src/com/google/javascript/jscomp/RemoveUnusedVars.java', 'b/src/com/google/javascript/jscomp/RemoveUnusedVars.java']
['Closure-2', 1, 1, 1, 1, ["ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"], ["ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = ImmutableSet.of(); } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); } for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"], [''], ['if (implicitProto == null) { currentPropertyNames = ImmutableSet.of(); } else { }'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-3', 3, 3, 3, 3, ['reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline()) { c.inlineVariable(); // If definition c has dependencies, then inlining it may have', 'return defMetadata.node; } private boolean canInline() { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false;', 'case Token.REGEXP: case Token.NEW: return true; } return false; }'], ['reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline(t.getScope())) { c.inlineVariable(); // If definition c has dependencies, then inlining it may have', 'return defMetadata.node; } private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false;', 'case Token.REGEXP: case Token.NEW: return true; case Token.NAME: Var var = scope.getOwnSlot(input.getString()); if (var != null && var.getParentNode().isCatch()) { return true; } } return false; }'], ['if (c.canInline()) {', 'private boolean canInline() {', ''], ['if (c.canInline(t.getScope())) {', 'private boolean canInline(final Scope scope) {', 'case Token.NAME: Var var = scope.getOwnSlot(input.getString()); if (var != null && var.getParentNode().isCatch()) { return true; }'], 'a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java', 'b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java']
['Closure-4', 2, 2, 2, 2, ['// makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); if (detectImplicitPrototypeCycle()) { handleTypeCycle(t); }', '} resolveViaProperties(t, enclosing); if (detectImplicitPrototypeCycle()) { handleTypeCycle(t); }'], ['// makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); if (detectInheritanceCycle()) { handleTypeCycle(t); }', '} resolveViaProperties(t, enclosing); if (detectInheritanceCycle()) { handleTypeCycle(t); }'], ['if (detectImplicitPrototypeCycle()) {', 'if (detectImplicitPrototypeCycle()) {'], ['if (detectInheritanceCycle()) {', 'if (detectInheritanceCycle()) {'], 'a/src/com/google/javascript/rhino/jstype/NamedType.java', 'b/src/com/google/javascript/rhino/jstype/NamedType.java']
['Closure-5', 1, 1, 1, 1, [" // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"], [" // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. if (gramps.isDelProp()) { return false; } // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"], [''], ['if (gramps.isDelProp()) { return false; }'], 'a/src/com/google/javascript/jscomp/InlineObjectLiterals.java', 'b/src/com/google/javascript/jscomp/InlineObjectLiterals.java']
['Closure-6', 3, 3, 3, 3, ['JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations.', '"assignment to property " + propName + " of " + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true;', 'boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } return false; } return true;'], ['JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations.', '"assignment to property " + propName + " of " + getReadableJSTypeName(owner, true), rightType, leftType); return false; } return true;', 'boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { mismatch(t, n, msg, rightType, leftType); return false; } return true;'], ['if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {', '}', 'if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { }'], ['', '', ''], 'a/src/com/google/javascript/jscomp/TypeValidator.java', 'b/src/com/google/javascript/jscomp/TypeValidator.java']
['Closure-7', 1, 1, 1, 1, ['public JSType caseObjectType(ObjectType type) { if (value.equals("function")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; // Objects are restricted to "Function", subtypes are left // Only filter out subtypes of "function" } return matchesExpectation("object") ? type : null; }'], ['public JSType caseObjectType(ObjectType type) { if (value.equals("function")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); if (resultEqualsValue) { // Objects are restricted to "Function", subtypes are left return ctorType.getGreatestSubtype(type); } else { // Only filter out subtypes of "function" return type.isSubtype(ctorType) ? null : type; } } return matchesExpectation("object") ? type : null; }'], ['return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;'], ['if (resultEqualsValue) { return ctorType.getGreatestSubtype(type); } else { return type.isSubtype(ctorType) ? null : type; }'], 'a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java', 'b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java']
['Closure-8', 1, 1, 1, 1, ['Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s && !blacklistedVars.contains(var); } } private void applyCollapses() { for (Collapse collapse : collapses) {'], ['Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s && !isNamedParameter(var) && !blacklistedVars.contains(var); } } private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); } private void applyCollapses() { for (Collapse collapse : collapses) {'], [''], ['&& !isNamedParameter(var) private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); }'], 'a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java', 'b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java']
['Closure-9', 2, 2, 2, 2, ['private String normalizeSourceName(String filename) { // The DOS command shell will normalize "/" to "\\", so we have to // wrestle it back. if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length());', 'Preconditions.checkArgument(scriptNodeCount == 1, "ProcessCommonJSModules supports only one invocation per " + "CompilerInput / script node"); String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {'], ['private String normalizeSourceName(String filename) { // The DOS command shell will normalize "/" to "\\", so we have to // wrestle it back. filename = filename.replace("\\\\", "/"); if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length());', 'Preconditions.checkArgument(scriptNodeCount == 1, "ProcessCommonJSModules supports only one invocation per " + "CompilerInput / script node"); String moduleName = guessCJSModuleName(script.getSourceFileName()); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {'], ['', 'String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));'], ['filename = filename.replace("\\\\", "/");', 'String moduleName = guessCJSModuleName(script.getSourceFileName());'], 'a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java', 'b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java']
['Closure-10', 1, 1, 1, 1, [' static boolean mayBeString(Node n, boolean recurse) { if (recurse) { return allResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); }'], [' static boolean mayBeString(Node n, boolean recurse) { if (recurse) { return anyResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); }'], ['return allResultsMatch(n, MAY_BE_STRING_PREDICATE);'], ['return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-11', 1, 1, 1, 1, [' if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "\'.\'", "dict"); } else if (n.getJSType() != null && parent.isAssign()) { return; } else if (validator.expectNotNullOrUndefined(t, n, childType, "No properties on this expression", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n);'], [' if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "\'.\'", "dict"); } else if (validator.expectNotNullOrUndefined(t, n, childType, "No properties on this expression", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n);'], ['} else if (n.getJSType() != null && parent.isAssign()) { return;'], [''], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-12', 1, 1, 1, 1, ['} private boolean hasExceptionHandler(Node cfgNode) { return false; }'], ['} private boolean hasExceptionHandler(Node cfgNode) { List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } } return false; }'], [''], ['List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } }'], 'a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java', 'b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java']
['Closure-13', 1, 1, 1, 1, ['do { Node c = node.getFirstChild(); while(c != null) { traverse(c); Node next = c.getNext(); c = next; }'], ['do { Node c = node.getFirstChild(); while(c != null) { Node next = c.getNext(); traverse(c); c = next; }'], ['Node next = c.getNext();'], ['Node next = c.getNext();'], 'a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java', 'b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java']
['Closure-14', 1, 1, 1, 1, ['} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); } } return computeFollowNode(fromNode, parent, cfa);'], ['} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { cfa.createEdge(fromNode, Branch.ON_EX, finallyNode); } } return computeFollowNode(fromNode, parent, cfa);'], ['cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);'], ['cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);'], 'a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java', 'b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java']
['Closure-15', 1, 1, 1, 1, ['return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {'], ['return true; } if (n.isDelProp()) { return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {'], [''], ['if (n.isDelProp()) { return true; }'], 'a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java', 'b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java']
['Closure-16', 2, 2, 2, 2, [' private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final String aliasName; AliasedTypeNode(Node typeReference, String aliasName) { this.typeReference = typeReference; this.aliasName = aliasName; } @Override public void applyAlias() { typeReference.setString(aliasName); } }', 'Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } }'], [' private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final Node aliasDefinition; private final String aliasName; AliasedTypeNode(Node typeReference, Node aliasDefinition, String aliasName) { this.typeReference = typeReference; this.aliasDefinition = aliasDefinition; this.aliasName = aliasName; } @Override public void applyAlias() { String typeName = typeReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } }', 'Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName)); } }'], ['AliasedTypeNode(Node typeReference, typeReference.setString(aliasName);', 'aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));'], ['private final Node aliasDefinition; AliasedTypeNode(Node typeReference, Node aliasDefinition, this.aliasDefinition = aliasDefinition; String typeName = typeReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));', 'aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-17', 1, 1, 1, 1, ["if (info.isConstant()) { JSType knownType = null; if (rValue != null) { if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { // If rValue has a type-cast, we use the type in the type-cast. // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"], ["if (info.isConstant()) { JSType knownType = null; if (rValue != null) { JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"], ['if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {'], ['JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-18', 1, 1, 1, 1, [' // Check if the sources need to be re-ordered. boolean staleInputs = false; if (options.dependencyOptions.needsManagement() && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.'], [' // Check if the sources need to be re-ordered. boolean staleInputs = false; if (options.dependencyOptions.needsManagement()) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.'], ['if (options.dependencyOptions.needsManagement() && options.closurePass) {'], ['if (options.dependencyOptions.needsManagement()) {'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-19', 1, 1, 1, 1, ['scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; // "this" references aren\'t currently modeled in the CFG. default: throw new IllegalArgumentException("Node cannot be refined. \\n" +'], ['scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; case Token.THIS: // "this" references aren\'t currently modeled in the CFG. break; default: throw new IllegalArgumentException("Node cannot be refined. \\n" +'], [''], ['case Token.THIS: break;'], 'a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java', 'b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java']
['Closure-20', 1, 1, 1, 1, ['// slightly different semantics than \'\' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); if (value != null) { Node addition = IR.add( IR.string("").srcref(callTarget), value.detachFromParent());'], ['// slightly different semantics than \'\' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) { Node addition = IR.add( IR.string("").srcref(callTarget), value.detachFromParent());'], ['if (value != null) {'], ['if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) {'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-21', 2, 2, 2, 2, ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; }', ' boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) {'], ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult() || n.isBlock()) { return; }', ' boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) {'], ['if (n.isExprResult()) {', 'if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ('], ['if (n.isExprResult() || n.isBlock()) {', 'if (!isResultUsed &&'], 'a/src/com/google/javascript/jscomp/CheckSideEffects.java', 'b/src/com/google/javascript/jscomp/CheckSideEffects.java']
['Closure-22', 1, 1, 1, 1, ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) { msg = "Is there a missing \'+\' on the previous line?";'], ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult() || n.isBlock()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) { msg = "Is there a missing \'+\' on the previous line?";'], ['if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) { } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { } if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }'], ['if (n.isExprResult() || n.isBlock()) { if (n.isQualifiedName() && n.getJSDocInfo() != null) {'], 'a/src/com/google/javascript/jscomp/CheckSideEffects.java', 'b/src/com/google/javascript/jscomp/CheckSideEffects.java']
['Closure-23', 1, 1, 1, 1, [' Node current = left.getFirstChild(); Node elem = null; for (int i = 0; current != null && i < intIndex; i++) { elem = current; current = current.getNext(); }'], [' Node current = left.getFirstChild(); Node elem = null; for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { elem = current; } current = current.getNext(); }'], ['for (int i = 0; current != null && i < intIndex; i++) {'], ['for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { }'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-24', 2, 2, 2, 2, ['Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar);', 'String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } }'], ['Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar);', 'String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. } else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }'], ['if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {', '}'], ['if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) {', '} else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) {'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-25', 2, 2, 2, 2, ['} private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) {', '} if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; }'], ['} private FlowScope traverseNew(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) {', '} if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); backwardsInferenceFromCallSite(n, ct); } } } n.setJSType(type); return scope; }'], ['scope = traverse(constructor, scope);', 'for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); }'], ['scope = traverseChildren(n, scope);', 'backwardsInferenceFromCallSite(n, ct);'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-26', 3, 3, 3, 3, ['AbstractPostOrderCallback { private int scriptNodeCount = 0; @Override public void visit(NodeTraversal t, Node n, Node parent) {', '*/ private void emitOptionalModuleExportsOverride(Node script, String moduleName) { Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string("module$exports"));', 'Node exports = prop.getChildAtIndex(1); exports.putProp(Node.ORIGINALNAME_PROP, "exports"); exports.setString("module$exports"); } /**'], ['AbstractPostOrderCallback { private int scriptNodeCount = 0; private Set<String> modulesWithExports = Sets.newHashSet(); @Override public void visit(NodeTraversal t, Node n, Node parent) {', '*/ private void emitOptionalModuleExportsOverride(Node script, String moduleName) { if (!modulesWithExports.contains(moduleName)) { return; } Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string("module$exports"));', 'Node exports = prop.getChildAtIndex(1); exports.putProp(Node.ORIGINALNAME_PROP, "exports"); exports.setString("module$exports"); modulesWithExports.add(moduleName); } /**'], ['', '', ''], ['private Set<String> modulesWithExports = Sets.newHashSet();', 'if (!modulesWithExports.contains(moduleName)) { return; }', 'modulesWithExports.add(moduleName);'], 'a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java', 'b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java']
['Closure-27', 3, 3, 3, 3, ['return block; } public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node', '} public static Node tryFinally(Node tryBody, Node finallyBody) { Preconditions.checkState(tryBody.isLabelName()); Preconditions.checkState(finallyBody.isLabelName()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); }', 'public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); Node catchBody = block(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); }'], ['return block; } private static Node blockUnchecked(Node stmt) { return new Node(Token.BLOCK, stmt); } public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node', '} public static Node tryFinally(Node tryBody, Node finallyBody) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(finallyBody.isBlock()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); }', 'public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); }'], ['', 'Preconditions.checkState(tryBody.isLabelName()); Preconditions.checkState(finallyBody.isLabelName());', 'Node catchBody = block(catchNode).copyInformationFrom(catchNode);'], ['private static Node blockUnchecked(Node stmt) { return new Node(Token.BLOCK, stmt); }', 'Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(finallyBody.isBlock());', 'Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);'], 'a/src/com/google/javascript/rhino/IR.java', 'b/src/com/google/javascript/rhino/IR.java']
['Closure-28', 1, 1, 1, 1, ["* Constants (true, false, null) are considered basically free, * because it's likely that they will get folded when we're done. */ } }"], ['* Constants (true, false, null) are considered basically free, * because it\'s likely that they will get folded when we\'re done. */ @Override void addConstant(String newcode) { add("0"); } } }'], [''], ['@Override void addConstant(String newcode) { add("0"); }'], 'a/src/com/google/javascript/jscomp/InlineCostEstimator.java', 'b/src/com/google/javascript/jscomp/InlineCostEstimator.java']
['Closure-29', 3, 3, 3, 3, ['*/ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent();', "// We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. continue; }", 'return false; } Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in'], ['*/ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent();', "// We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; }", 'return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in'], ['', '', ''], ['Set<String> validProperties = Sets.newHashSet();', 'String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } }', 'validProperties.add(child.getString());'], 'a/src/com/google/javascript/jscomp/InlineObjectLiterals.java', 'b/src/com/google/javascript/jscomp/InlineObjectLiterals.java']
['Closure-30', 4, 4, 4, 4, [' @Override public void process(Node externs, Node root) { (new NodeTraversal(compiler, this)).traverse(root); } @Override', 'private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); Definition(Node node) { this.node = node;', 'new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); def.depends.add(dep); } } });', 'GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); for (Var s : def.depends) { if (s.scope != jsScope) {'], [' @Override public void process(Node externs, Node root) { (new NodeTraversal(compiler, this)).traverseRoots(externs, root); } @Override', 'private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); private boolean unknownDependencies = false; Definition(Node node) { this.node = node;', 'new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName()) { Var dep = jsScope.getVar(n.getString()); if (dep == null) { def.unknownDependencies = true; } else { def.depends.add(dep); } } } });', 'GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def.unknownDependencies) { return true; } for (Var s : def.depends) { if (s.scope != jsScope) {'], ['(new NodeTraversal(compiler, this)).traverse(root);', '', 'if (n.isName() && jsScope.isDeclared(n.getString(), true)) {', ''], ['(new NodeTraversal(compiler, this)).traverseRoots(externs, root);', 'private boolean unknownDependencies = false;', 'if (n.isName()) { if (dep == null) { def.unknownDependencies = true; } else { }', 'if (def.unknownDependencies) { return true; }'], 'a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java', 'b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java']
['Closure-31', 1, 1, 1, 1, [' // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they'], [' // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they'], ['!options.skipAllPasses &&'], [''], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-32', 4, 4, 4, 4, ["// Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. } else { // The star is part of the comment. if (builder.length() > 0) {", '} ignoreStar = true; token = next(); continue;', 'ignoreStar = false; state = State.SEARCHING_ANNOTATION; // All tokens must be separated by a space. if (token == JsDocToken.EOC || token == JsDocToken.EOF ||', "return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine();"], ["// Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. int lineStartChar = -1; do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. lineStartChar = stream.getCharno() + 1; } else { // The star is part of the comment. if (builder.length() > 0) {", '} ignoreStar = true; lineStartChar = 0; token = next(); continue;', "ignoreStar = false; state = State.SEARCHING_ANNOTATION; boolean isEOC = token == JsDocToken.EOC; if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) { // All tokens must be separated by a space. builder.append(' '); } } if (token == JsDocToken.EOC || token == JsDocToken.EOF ||", 'return new ExtractionInfo(multilineText, token); } builder.append(toString(token)); line = stream.getRemainingJSDocLine();'], ['', '', '', "if (builder.length() > 0) { builder.append(' '); }"], ['int lineStartChar = -1; lineStartChar = stream.getCharno() + 1;', 'lineStartChar = 0;', "boolean isEOC = token == JsDocToken.EOC; if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) { builder.append(' '); } }", ''], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-33', 1, 1, 1, 1, ['@Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. // Handle the case where the constraint object is a record type. //'], ['@Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. if (hasReferenceName()) { return; } // Handle the case where the constraint object is a record type. //'], [''], ['if (hasReferenceName()) { return; }'], 'a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java', 'b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java']
['Closure-34', 3, 3, 3, 3, ['cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext); } return; }', 'Node current = firstNonOperator; do { current = current.getParent(); cc.listSeparator(); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); }', '@Override void appendOp(String op, boolean binOp) { if (binOp) { if (getLastChar() != \' \') { append(" "); } append(op);'], ['cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1); } return; }', 'Node current = firstNonOperator; do { current = current.getParent(); cc.addOp(opStr, true); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); }', '@Override void appendOp(String op, boolean binOp) { if (binOp) { if (getLastChar() != \' \' && op.charAt(0) != \',\') { append(" "); } append(op);'], ['addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext);', 'cc.listSeparator();', "if (getLastChar() != ' ') {"], ['unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);', 'cc.addOp(opStr, true);', "if (getLastChar() != ' ' && op.charAt(0) != ',') {"], 'a/src/com/google/javascript/jscomp/CodePrinter.java', 'b/src/com/google/javascript/jscomp/CodePrinter.java']
['Closure-35', 1, 1, 1, 1, [' ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } } }'], [' ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null) { type.matchConstraint(constraintObj); } }'], ['if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }'], ['if (constraintObj != null) { type.matchConstraint(constraintObj);'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-36', 1, 1, 1, 1, [" // issue 668: Don't inline singleton getter methods // calls as this confused class removing logic. } }"], [" // issue 668: Don't inline singleton getter methods // calls as this confused class removing logic. if (convention.getSingletonGetterClassName(callNode) != null) { return false; } } }"], [''], ['if (convention.getSingletonGetterClassName(callNode) != null) { return false; }'], 'a/src/com/google/javascript/jscomp/InlineVariables.java', 'b/src/com/google/javascript/jscomp/InlineVariables.java']
['Closure-37', 2, 2, 2, 2, [' // Body Preconditions.checkState(body.getNext() == null && body.isBlock()); traverseBranch(body, n); popScope();', "node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"], [' // Body Preconditions.checkState(body.getNext() == null && body.isBlock(), body); traverseBranch(body, n); popScope();', "node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); if (!bodyNode.isBlock()) { // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. Preconditions.checkState(config.isIdeMode); bodyNode = IR.block(); } parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"], ['body.isBlock());', ''], ['body.isBlock(), body);', 'if (!bodyNode.isBlock()) { Preconditions.checkState(config.isIdeMode); bodyNode = IR.block(); }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-38', 1, 1, 1, 1, ['// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); if (x < 0 && prev == \'-\') { add(" "); }'], ['// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); if ((x < 0 || negativeZero) && prev == \'-\') { add(" "); }'], ["if (x < 0 && prev == '-') {"], ["if ((x < 0 || negativeZero) && prev == '-') {"], 'a/src/com/google/javascript/jscomp/CodeConsumer.java', 'b/src/com/google/javascript/jscomp/CodeConsumer.java']
['Closure-39', 2, 2, 2, 2, [' sb.append(property); sb.append(": "); sb.append(getPropertyType(property).toString()); ++i; if (i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(", ..."); break; }', 'prettyPrint = true; return sb.toString(); } else { return "{...}"; } }'], [' sb.append(property); sb.append(": "); sb.append(getPropertyType(property).toStringHelper(forAnnotations)); ++i; if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(", ..."); break; }', 'prettyPrint = true; return sb.toString(); } else { return forAnnotations ? "?" : "{...}"; } }'], ['sb.append(getPropertyType(property).toString()); if (i == MAX_PRETTY_PRINTED_PROPERTIES) {', 'return "{...}";'], ['sb.append(getPropertyType(property).toStringHelper(forAnnotations)); if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {', 'return forAnnotations ? "?" : "{...}";'], 'a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java', 'b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java']
['Closure-40', 1, 1, 1, 1, ['Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } }'], ['Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { JsName name = getName(ns.name, true); refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } }'], ['JsName name = getName(ns.name, false); if (name != null) { }'], ['JsName name = getName(ns.name, true);'], 'a/src/com/google/javascript/jscomp/NameAnalyzer.java', 'b/src/com/google/javascript/jscomp/NameAnalyzer.java']
['Closure-41', 2, 2, 2, 2, ["} // Clone any remaining params that aren't in the function literal. parametersNode = paramBuilder.build(); }", "} // Copy over any old parameters that aren't in the param list. if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"], ["} // Clone any remaining params that aren't in the function literal. while (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } parametersNode = paramBuilder.build(); }", "} // Copy over any old parameters that aren't in the param list. if (!isVarArgs) { while (oldParameterType != null && !isVarArgs) { builder.newParameterFromNode(oldParameterType); oldParameterType = oldParameterType.getNext(); } } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"], ['', ''], ['while (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); }', 'if (!isVarArgs) { while (oldParameterType != null && !isVarArgs) { builder.newParameterFromNode(oldParameterType); oldParameterType = oldParameterType.getNext(); } }'], 'a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java', 'b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java']
['Closure-42', 1, 1, 1, 1, [' @Override Node processForInLoop(ForInLoop loopNode) { // Return the bare minimum to put the AST in a valid state. return newNode( Token.FOR, transform(loopNode.getIterator()),'], [' @Override Node processForInLoop(ForInLoop loopNode) { if (loopNode.isForEach()) { errorReporter.error( "unsupported language extension: for each", sourceName, loopNode.getLineno(), "", 0); // Return the bare minimum to put the AST in a valid state. return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } return newNode( Token.FOR, transform(loopNode.getIterator()),'], [''], ['if (loopNode.isForEach()) { errorReporter.error( "unsupported language extension: for each", sourceName, loopNode.getLineno(), "", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-43', 3, 3, 3, 3, ['* For more information, see * http://code.google.com/p/closure-compiler/issues/detail?id=314 */ /** * Type-less stubs.', '} // Analyze any @lends object literals in this statement. } private void attachLiteralTypes(NodeTraversal t, Node n) {', 'break; case Token.OBJECTLIT: defineObjectLiteral(n); break; // NOTE(nicksantos): If we ever support Array tuples,'], ['* For more information, see * http://code.google.com/p/closure-compiler/issues/detail?id=314 */ private List<Node> lentObjectLiterals = null; /** * Type-less stubs.', '} // Analyze any @lends object literals in this statement. if (n.getParent() != null && NodeUtil.isStatement(n) && lentObjectLiterals != null) { for (Node objLit : lentObjectLiterals) { defineObjectLiteral(objLit); } lentObjectLiterals.clear(); } } private void attachLiteralTypes(NodeTraversal t, Node n) {', 'break; case Token.OBJECTLIT: JSDocInfo info = n.getJSDocInfo(); if (info != null && info.getLendsName() != null) { if (lentObjectLiterals == null) { lentObjectLiterals = Lists.newArrayList(); } lentObjectLiterals.add(n); } else { defineObjectLiteral(n); } break; // NOTE(nicksantos): If we ever support Array tuples,'], ['', '', ''], ['private List<Node> lentObjectLiterals = null;', 'if (n.getParent() != null && NodeUtil.isStatement(n) && lentObjectLiterals != null) { for (Node objLit : lentObjectLiterals) { defineObjectLiteral(objLit); } lentObjectLiterals.clear(); }', 'JSDocInfo info = n.getJSDocInfo(); if (info != null && info.getLendsName() != null) { if (lentObjectLiterals == null) { lentObjectLiterals = Lists.newArrayList(); } lentObjectLiterals.add(n); } else { }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-44', 1, 1, 1, 1, ['// need space to separate. This is not pretty printing. // For example: "return foo;" append(" "); // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / } append(newcode);'], ['// need space to separate. This is not pretty printing. // For example: "return foo;" append(" "); } else if (c == \'/\' && getLastChar() == \'/\') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / append(" "); } append(newcode);'], [''], ['} else if (c == \'/\' && getLastChar() == \'/\') { append(" ");'], 'a/src/com/google/javascript/jscomp/CodeConsumer.java', 'b/src/com/google/javascript/jscomp/CodeConsumer.java']
['Closure-45', 3, 3, 3, 3, ['assignedToUnknownValue = true; } for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true;', 'assign.assignNode.getLastChild(), true)) { assignedToUnknownValue = true; } } if (assignedToUnknownValue && hasPropertyAssign) { changes = markReferencedVar(var) || changes; maybeUnreferenced.remove(current); current--;', 'this.nameNode = nameNode; this.isPropertyAssign = isPropertyAssign; this.maybeAliased = !assignNode.getParent().isExprResult(); this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||'], ['assignedToUnknownValue = true; } boolean maybeEscaped = false; for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true;', 'assign.assignNode.getLastChild(), true)) { assignedToUnknownValue = true; } if (assign.maybeAliased) { maybeEscaped = true; } } if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) { changes = markReferencedVar(var) || changes; maybeUnreferenced.remove(current); current--;', 'this.nameNode = nameNode; this.isPropertyAssign = isPropertyAssign; this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode); this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||'], ['', 'if (assignedToUnknownValue && hasPropertyAssign) {', 'this.maybeAliased = !assignNode.getParent().isExprResult();'], ['boolean maybeEscaped = false;', 'if (assign.maybeAliased) { maybeEscaped = true; } if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {', 'this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);'], 'a/src/com/google/javascript/jscomp/RemoveUnusedVars.java', 'b/src/com/google/javascript/jscomp/RemoveUnusedVars.java']
['Closure-46', 1, 1, 1, 1, ['propertyNode); } @Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();'], ['propertyNode); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();'], ['@Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }'], [''], 'a/src/com/google/javascript/rhino/jstype/RecordType.java', 'b/src/com/google/javascript/rhino/jstype/RecordType.java']
['Closure-47', 2, 2, 2, 2, ['// Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) .setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); }', "// zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. generator.addMapping( sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition); }"], ['// Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) .setLineNumber(entry.getSourceLine() + 1) .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); }', "// zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. int lineBaseOffset = 1; if (generator instanceof SourceMapGeneratorV1 || generator instanceof SourceMapGeneratorV2) { lineBaseOffset = 0; } generator.addMapping( sourceFile, originalName, new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); }"], ['.setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn());', 'new FilePosition(node.getLineno(), node.getCharno()),'], ['.setLineNumber(entry.getSourceLine() + 1) .setColumnPosition(entry.getSourceColumn() + 1);', 'int lineBaseOffset = 1; if (generator instanceof SourceMapGeneratorV1 || generator instanceof SourceMapGeneratorV2) { lineBaseOffset = 0; } new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),'], 'a/src/com/google/javascript/jscomp/SourceMap.java', 'b/src/com/google/javascript/jscomp/SourceMap.java']
['Closure-48', 1, 1, 1, 1, ['|| FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) {'], ['|| FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; } } if (!inferred) {'], ['if (inferred) { inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));'], ['if (inferred && rhsValue != null && rhsValue.isFunction()) { if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-49', 3, 3, 3, 3, ['renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer);', 'renamer.addDeclaredName(name); } // Add the function parameters // Add the function body declarations nameStack.push(renamer); }', ' case Token.FUNCTION: // Remove the function body scope // Remove function recursive name (if any). nameStack.pop(); break; // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the "shouldTraverse" // visit of LP, but remove it when when we exit the function above. case Token.CATCH: // Remove catch except name from the stack of names.'], ['renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer);', 'renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.LP: { Renamer renamer = nameStack.peek().forChildScope(); // Add the function parameters for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } // Add the function body declarations Node functionBody = n.getNext(); findDeclaredNames(functionBody, null, renamer); nameStack.push(renamer); }', ' case Token.FUNCTION: // Remove the function body scope nameStack.pop(); // Remove function recursive name (if any). nameStack.pop(); break; case Token.LP: // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the "shouldTraverse" // visit of LP, but remove it when when we exit the function above. break; case Token.CATCH: // Remove catch except name from the stack of names.'], ['if (declarationRoot.getType() == Token.FUNCTION) { for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else', '', ''], ['', 'nameStack.push(renamer); } break; case Token.LP: { Renamer renamer = nameStack.peek().forChildScope(); for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = n.getNext(); findDeclaredNames(functionBody, null, renamer);', 'nameStack.pop(); case Token.LP: break;'], 'a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java', 'b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java']
['Closure-50', 2, 2, 2, 2, [' Node right = callTarget.getNext(); if (right != null) { if (!NodeUtil.isImmutableValue(right)) { return n; } }', 'return n; } // "," is the default, it doesn\'t need to be explicit String joinString = (right == null) ? "," : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList();'], [' Node right = callTarget.getNext(); if (right != null) { if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) { return n; } }', 'return n; } if (right != null && right.getType() == Token.STRING && ",".equals(right.getString())) { // "," is the default, it doesn\'t need to be explicit n.removeChild(right); reportCodeChange(); } String joinString = (right == null) ? "," : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList();'], ['if (!NodeUtil.isImmutableValue(right)) {', ''], ['if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {', 'if (right != null && right.getType() == Token.STRING && ",".equals(right.getString())) { n.removeChild(right); reportCodeChange(); }'], 'a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java', 'b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java']
['Closure-51', 2, 2, 2, 2, ['add(" "); } if ((long) x == x) { long value = (long) x; long mantissa = value; int exp = 0;', '} else { add(String.valueOf(x)); } } static boolean isWordChar(char ch) {'], ['add(" "); } if ((long) x == x && !isNegativeZero(x)) { long value = (long) x; long mantissa = value; int exp = 0;', '} else { add(String.valueOf(x)); } } static boolean isNegativeZero(double x) { return x == 0.0 && Math.copySign(1, x) == -1.0; } static boolean isWordChar(char ch) {'], ['if ((long) x == x) {', ''], ['if ((long) x == x && !isNegativeZero(x)) {', '} static boolean isNegativeZero(double x) { return x == 0.0 && Math.copySign(1, x) == -1.0;'], 'a/src/com/google/javascript/jscomp/CodeConsumer.java', 'b/src/com/google/javascript/jscomp/CodeConsumer.java']
['Closure-52', 1, 1, 1, 1, ['return false; } } return len > 0; } static double getSimpleNumber(String s) {'], ["return false; } } return len > 0 && s.charAt(0) != '0'; } static double getSimpleNumber(String s) {"], ['return len > 0;'], ["return len > 0 && s.charAt(0) != '0';"], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-53', 2, 2, 2, 2, ['} Node replacement; // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE));', '} cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);'], ['} Node replacement; if (nodes.isEmpty()) { replacement = new Node(Token.TRUE); } else { // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE));', '} cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); } Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);'], ['', ''], ['if (nodes.isEmpty()) { replacement = new Node(Token.TRUE); } else {', '}'], 'a/src/com/google/javascript/jscomp/InlineObjectLiterals.java', 'b/src/com/google/javascript/jscomp/InlineObjectLiterals.java']
['Closure-54', 3, 3, 3, 3, ["// then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression,", '// // In the second case, we just use the anonymous object as the prototype. if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {', 'return false; } boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot("prototype", prototype, true); this.prototype.setOwnerFunction(this); // Disassociating the old prototype makes this easier to debug-- // we don\'t have to worry about two prototypes running around. if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor();'], ["// then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression,", '// // In the second case, we just use the anonymous object as the prototype. if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {', 'return false; } PrototypeObjectType oldPrototype = this.prototype; boolean replacedPrototype = oldPrototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot("prototype", prototype, true); this.prototype.setOwnerFunction(this); if (oldPrototype != null) { // Disassociating the old prototype makes this easier to debug-- // we don\'t have to worry about two prototypes running around. oldPrototype.setOwnerFunction(null); } if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor();'], ['if (!qVar.isTypeInferred()) {', 'baseType.isUnknownType() ||', 'boolean replacedPrototype = prototype != null;'], ['ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) {', '', 'PrototypeObjectType oldPrototype = this.prototype; boolean replacedPrototype = oldPrototype != null; if (oldPrototype != null) { oldPrototype.setOwnerFunction(null); }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-55', 1, 1, 1, 1, ['} private static boolean isReduceableFunctionExpression(Node n) { return NodeUtil.isFunctionExpression(n); } /**'], ['} private static boolean isReduceableFunctionExpression(Node n) { return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent()); } /**'], ['return NodeUtil.isFunctionExpression(n);'], ['return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent());'], 'a/src/com/google/javascript/jscomp/FunctionRewriter.java', 'b/src/com/google/javascript/jscomp/FunctionRewriter.java']
['Closure-56', 1, 1, 1, 1, ["// If next new line cannot be found, there are two cases // 1. pos already reaches the end of file, then null should be returned // 2. otherwise, return the contents between pos and the end of file. return null; } else { return js.substring(pos, js.indexOf('\\n', pos)); }"], ["// If next new line cannot be found, there are two cases // 1. pos already reaches the end of file, then null should be returned // 2. otherwise, return the contents between pos and the end of file. if (pos >= js.length()) { return null; } else { return js.substring(pos, js.length()); } } else { return js.substring(pos, js.indexOf('\\n', pos)); }"], [''], ['if (pos >= js.length()) { } else { return js.substring(pos, js.length()); }'], 'a/src/com/google/javascript/jscomp/SourceFile.java', 'b/src/com/google/javascript/jscomp/SourceFile.java']
['Closure-57', 1, 1, 1, 1, ['String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } }'], ['String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null && target.getType() == Token.STRING) { className = target.getString(); } }'], ['if (target != null) {'], ['if (target != null && target.getType() == Token.STRING) {'], 'a/src/com/google/javascript/jscomp/ClosureCodingConvention.java', 'b/src/com/google/javascript/jscomp/ClosureCodingConvention.java']
['Closure-58', 1, 1, 1, 1, ['// for(var x in y) {...} lhs = lhs.getLastChild(); } addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); computeGenKill(rhs, gen, kill, conditional); } return;'], ['// for(var x in y) {...} lhs = lhs.getLastChild(); } if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); } else { computeGenKill(lhs, gen, kill, conditional); } computeGenKill(rhs, gen, kill, conditional); } return;'], [''], ['if (NodeUtil.isName(lhs)) { } else { computeGenKill(lhs, gen, kill, conditional); }'], 'a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java', 'b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java']
['Closure-59', 1, 1, 1, 1, ['CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);'], ['CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);'], ['if (options.checkGlobalThisLevel.isOn()) {'], ['if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-60', 2, 2, 2, 2, ['// ignoring side-effects return TernaryValue.TRUE; default: return getPureBooleanValue(n);', 'return TernaryValue.FALSE; case Token.VOID: return TernaryValue.FALSE; case Token.NAME: String name = n.getString();'], ['// ignoring side-effects return TernaryValue.TRUE; case Token.VOID: return TernaryValue.FALSE; default: return getPureBooleanValue(n);', 'return TernaryValue.FALSE; case Token.VOID: if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; } break; case Token.NAME: String name = n.getString();'], ['', ''], ['case Token.VOID: return TernaryValue.FALSE;', 'if (!mayHaveSideEffects(n.getFirstChild())) { } break;'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-61', 1, 1, 1, 1, ['} // Functions in the "Math" namespace have no side effects. if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP'], ['} // Functions in the "Math" namespace have no side effects. if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals("Math")) { return false; } } if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP'], [''], ['if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals("Math")) { return false; } }'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-62', 1, 1, 1, 1, ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['&& 0 <= charno && charno < sourceExcerpt.length()) {'], ['&& 0 <= charno && charno <= sourceExcerpt.length()) {'], 'a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java', 'b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java']
['Closure-63', 1, 1, 1, 1, ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['&& 0 <= charno && charno < sourceExcerpt.length()) {'], ['&& 0 <= charno && charno <= sourceExcerpt.length()) {'], 'a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java', 'b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java']
['Closure-64', 2, 2, 2, 2, [" // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict' // for the first input file String code = toSource(root, sourceMap); if (!code.isEmpty()) { cb.append(code);", '@Override String toSource(Node n) { initCompilerOptionsIfTesting(); return toSource(n, null); } /** * Generates JavaScript source code for an AST. */ private String toSource(Node n, SourceMap sourceMap) { CodePrinter.Builder builder = new CodePrinter.Builder(n); builder.setPrettyPrint(options.prettyPrint); builder.setLineBreak(options.lineBreak); builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); builder.setTagAsStrict( options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT); builder.setLineLengthThreshold(options.lineLengthThreshold);'], [" // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict' // for the first input file String code = toSource(root, sourceMap, inputSeqNum == 0); if (!code.isEmpty()) { cb.append(code);", '@Override String toSource(Node n) { initCompilerOptionsIfTesting(); return toSource(n, null, true); } /** * Generates JavaScript source code for an AST. */ private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) { CodePrinter.Builder builder = new CodePrinter.Builder(n); builder.setPrettyPrint(options.prettyPrint); builder.setLineBreak(options.lineBreak); builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); builder.setTagAsStrict(firstOutput && options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT); builder.setLineLengthThreshold(options.lineLengthThreshold);'], ['String code = toSource(root, sourceMap);', 'return toSource(n, null); private String toSource(Node n, SourceMap sourceMap) { builder.setTagAsStrict('], ['String code = toSource(root, sourceMap, inputSeqNum == 0);', 'return toSource(n, null, true); private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) { builder.setTagAsStrict(firstOutput &&'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-65', 1, 1, 1, 1, ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\0\': sb.append("\\\\0"); break; case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\0\': sb.append("\\\\000"); break; case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], ['case \'\\0\': sb.append("\\\\0"); break;'], ['case \'\\0\': sb.append("\\\\000"); break;'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-66', 1, 1, 1, 1, ['// Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); // Object literal keys are not typeable } break;'], ['// Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); } else { // Object literal keys are not typeable typeable = false; } break;'], [''], ['} else { typeable = false;'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-67', 1, 1, 1, 1, ['Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP ) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;'], ['Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP && assign.getParent().getType() == Token.EXPR_RESULT) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;'], [') {'], ['&& assign.getParent().getType() == Token.EXPR_RESULT) {'], 'a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java', 'b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java']
['Closure-68', 3, 3, 3, 3, ['} break; } token = eatTokensUntilEOL(); } continue retry; } }', '} } return reportGenericTypeSyntaxWarning(); }', '// NOTE(nicksantos): We\'re not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { return reportTypeSyntaxWarning("msg.jsdoc.missing.lp"); }'], ['} break; } } token = eatTokensUntilEOL(); continue retry; } }', '} } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); }', '// NOTE(nicksantos): We\'re not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning("msg.jsdoc.missing.lp"); }'], ['}', '', ''], ['}', 'restoreLookAhead(token);', 'restoreLookAhead(token);'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-69', 1, 1, 1, 1, [" // Functions with explcit 'this' types must be called in a GETPROP // or GETELEM. visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType());"], [" // Functions with explcit 'this' types must be called in a GETPROP // or GETELEM. if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); } visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType());"], [''], ['if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); }'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-70', 1, 1, 1, 1, ['for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);'], ['for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), false); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);'], ['jsDocParameter.getJSType(), true);'], ['jsDocParameter.getJSType(), false);'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-71', 1, 1, 1, 1, ['if (objectType != null) { // Is this a normal property access, or are we trying to override // an existing property? boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;'], ['if (objectType != null) { // Is this a normal property access, or are we trying to override // an existing property? boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;'], ['boolean isOverride = t.inGlobalScope() &&'], ['boolean isOverride = parent.getJSDocInfo() != null &&'], 'a/src/com/google/javascript/jscomp/CheckAccessControls.java', 'b/src/com/google/javascript/jscomp/CheckAccessControls.java']
['Closure-72', 2, 2, 2, 2, ['"inline_", isCallInLoop))); // Make label names unique to this instance. } static class LabelNameSupplier implements Supplier<String> {', 'String name = nameNode.getString(); LabelInfo li = getLabelInfo(name); // This is a label... if (li.referenced) { String newName = getNameForId(li.id); if (!name.equals(newName)) { // ... and it is used, give it the short name.'], ['"inline_", isCallInLoop))); // Make label names unique to this instance. new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false) .process(null, fnNode); } static class LabelNameSupplier implements Supplier<String> {', 'String name = nameNode.getString(); LabelInfo li = getLabelInfo(name); // This is a label... if (li.referenced || !removeUnused) { String newName = getNameForId(li.id); if (!name.equals(newName)) { // ... and it is used, give it the short name.'], ['', 'if (li.referenced) {'], ['new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false) .process(null, fnNode);', 'if (li.referenced || !removeUnused) {'], 'a/src/com/google/javascript/jscomp/RenameLabels.java', 'b/src/com/google/javascript/jscomp/RenameLabels.java']
['Closure-73', 1, 1, 1, 1, ['// No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,'], ['// No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,'], ['if (c > 0x1f && c <= 0x7f) {'], ['if (c > 0x1f && c < 0x7f) {'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-74', 2, 2, 2, 2, ['&& right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {', '/** * @return Translate NOT expressions into TRUE or FALSE when possible. */ /** * The result of the comparison as a Boolean or null if the'], ['&& right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = getNormalizedNodeType(left); int rhType = getNormalizedNodeType(right); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {', '/** * @return Translate NOT expressions into TRUE or FALSE when possible. */ private int getNormalizedNodeType(Node n) { int type = n.getType(); if (type == Token.NOT) { TernaryValue value = NodeUtil.getPureBooleanValue(n); switch (value) { case TRUE: return Token.TRUE; case FALSE: return Token.FALSE; } } return type; } /** * The result of the comparison as a Boolean or null if the'], ['int lhType = left.getType(); int rhType = right.getType();', ''], ['int lhType = getNormalizedNodeType(left); int rhType = getNormalizedNodeType(right);', 'private int getNormalizedNodeType(Node n) { int type = n.getType(); if (type == Token.NOT) { TernaryValue value = NodeUtil.getPureBooleanValue(n); switch (value) { case TRUE: return Token.TRUE; case FALSE: return Token.FALSE; } } return type; }'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-75', 2, 2, 2, 2, ['} static Double getStringNumberValue(String rawJsString) { // vertical tab is not always whitespace String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s);', "static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\\u000B': // <VT> return TernaryValue.TRUE; case ' ': // <SP> case '\\n': // <LF> case '\\r': // <CR>"], ['} static Double getStringNumberValue(String rawJsString) { if (rawJsString.contains("\\u000b")) { // vertical tab is not always whitespace return null; } String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s);', 'static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case \'\\u000B\': // <VT> return TernaryValue.UNKNOWN; // IE says "no", EcmaScript says "yes" case \' \': // <SP> case \'\\n\': // <LF> case \'\\r\': // <CR>'], ['', 'return TernaryValue.TRUE;'], ['if (rawJsString.contains("\\u000b")) { return null; }', 'return TernaryValue.UNKNOWN; // IE says "no", EcmaScript says "yes"'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-76', 4, 4, 4, 4, ['// If the currently node is the first child of // AND/OR, be conservative only consider the READs // of the second operand. case Token.HOOK: // If current node is the condition, check each following // branch, otherwise it is a conditional branch and the // other branch can be ignored. default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); // If we see a READ or KILL there is no need to continue. if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent(); }', '*/ private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {', '// Conditionals case Token.OR: case Token.AND: // With a AND/OR the first branch always runs, but the second is // may not. case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);', '// Expressions are evaluated left-right, depth first. for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE;'], ['// If the currently node is the first child of // AND/OR, be conservative only consider the READs // of the second operand. if (n.getNext() != null) { state = isVariableReadBeforeKill( n.getNext(), variable); if (state == VariableLiveness.KILL) { state = VariableLiveness.MAYBE_LIVE; } } break; case Token.HOOK: // If current node is the condition, check each following // branch, otherwise it is a conditional branch and the // other branch can be ignored. if (n.getNext() != null && n.getNext().getNext() != null) { state = checkHookBranchReadBeforeKill( n.getNext(), n.getNext().getNext(), variable); } break; default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { state = isVariableReadBeforeKill(sibling, variable); if (state != VariableLiveness.MAYBE_LIVE) { break; } } } // If we see a READ or KILL there is no need to continue. if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } n = n.getParent(); }', '*/ private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION return VariableLiveness.MAYBE_LIVE; } if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {', '// Conditionals case Token.OR: case Token.AND: VariableLiveness v1 = isVariableReadBeforeKill( n.getFirstChild(), variable); VariableLiveness v2 = isVariableReadBeforeKill( n.getLastChild(), variable); // With a AND/OR the first branch always runs, but the second is // may not. if (v1 != VariableLiveness.MAYBE_LIVE) { return v1; } else if (v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else { return VariableLiveness.MAYBE_LIVE; } case Token.HOOK: VariableLiveness first = isVariableReadBeforeKill( n.getFirstChild(), variable); if (first != VariableLiveness.MAYBE_LIVE) { return first; } return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);', '// Expressions are evaluated left-right, depth first. for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE;'], ['if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { } } }', '', '', 'if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION }'], ['if (n.getNext() != null) { state = isVariableReadBeforeKill( n.getNext(), variable); if (state == VariableLiveness.KILL) { state = VariableLiveness.MAYBE_LIVE; } } break; if (n.getNext() != null && n.getNext().getNext() != null) { state = checkHookBranchReadBeforeKill( n.getNext(), n.getNext().getNext(), variable); } break; if (state != VariableLiveness.MAYBE_LIVE) { break; } } }', 'if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION return VariableLiveness.MAYBE_LIVE; }', 'VariableLiveness v1 = isVariableReadBeforeKill( n.getFirstChild(), variable); VariableLiveness v2 = isVariableReadBeforeKill( n.getLastChild(), variable); if (v1 != VariableLiveness.MAYBE_LIVE) { return v1; } else if (v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else { return VariableLiveness.MAYBE_LIVE; } VariableLiveness first = isVariableReadBeforeKill( n.getFirstChild(), variable); if (first != VariableLiveness.MAYBE_LIVE) { return first; }', ''], 'a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java', 'b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java']
['Closure-77', 1, 1, 1, 1, ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\0\': sb.append("\\\\0"); break; case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], [''], ['case \'\\0\': sb.append("\\\\0"); break;'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-78', 1, 1, 1, 1, ['break; case Token.MOD: if (rval == 0) { error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right); return null; } result = lval / rval;'], ['break; case Token.MOD: if (rval == 0) { return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { return null; } result = lval / rval;'], ['error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right); error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right);'], [''], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-79', 2, 2, 2, 2, ['public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) .traverse(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', 'getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); } /**'], ['public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) .traverseRoots(externs, root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', 'getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); compiler.reportCodeChange(); } /**'], ['.traverse(root);', ''], ['.traverseRoots(externs, root);', 'compiler.reportCodeChange();'], 'a/src/com/google/javascript/jscomp/VarCheck.java', 'b/src/com/google/javascript/jscomp/VarCheck.java']
['Closure-80', 2, 2, 2, 2, ['// Inversion case Token.NOT: // delete operator returns a boolean. return true; default: return false;', 'case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true;'], ['// Inversion case Token.NOT: // delete operator returns a boolean. case Token.DELPROP: return true; default: return false;', 'case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; case Token.DELPROP: case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true;'], ['', ''], ['case Token.DELPROP:', 'case Token.DELPROP:'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-81', 1, 1, 1, 1, ['Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { name = new Name(); name.setIdentifier(""); isUnnamedFunction = true;'], ['Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( "unnamed function statement", sourceName, functionNode.getLineno(), "", 0); } name = new Name(); name.setIdentifier(""); isUnnamedFunction = true;'], [''], ['int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( "unnamed function statement", sourceName, functionNode.getLineno(), "", 0); }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-82', 1, 1, 1, 1, ['} public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType(); } public boolean isNumberObjectType() {'], ['} public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() {'], ['return isNoType() || isNoObjectType() || isNoResolvedType();'], ['return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this);'], 'a/src/com/google/javascript/rhino/jstype/JSType.java', 'b/src/com/google/javascript/rhino/jstype/JSType.java']
['Closure-83', 1, 1, 1, 1, [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = params.getParameter(0); if (param == null) { setter.addValue(true);'], [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true);'], ['String param = params.getParameter(0);'], ['String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-84', 3, 3, 3, 3, ['@Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); return assign; }', 'operand.setDouble(-operand.getDouble()); return operand; } else { Node node = newNode(type, operand); if (exprNode.isPostfix()) {', '} } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {'], ['@Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( "invalid assignment target", sourceName, target.getLineno(), "", 0); } return assign; }', 'operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? "invalid increment target" : "invalid decrement target"; errorReporter.error( msg, sourceName, operand.getLineno(), "", 0); } } Node node = newNode(type, operand); if (exprNode.isPostfix()) {', '} } private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {'], ['', '', ''], ['Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( "invalid assignment target", sourceName, target.getLineno(), "", 0); }', 'if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? "invalid increment target" : "invalid decrement target"; errorReporter.error( msg, sourceName, operand.getLineno(), "", 0); } }', 'private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-85', 3, 3, 3, 3, ['return n; } if (n.getParent() == null) { List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); if (outEdges.size() == 1) { return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); } } switch (n.getType()) { case Token.BLOCK: if (n.hasChildren()) { Node first = n.getFirstChild(); return tryRemoveUnconditionalBranching(first); } else { return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); } case Token.RETURN: if (n.hasChildren()) { break;', '(n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) { Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n)); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);', ' private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); return next; }'], ['return n; } switch (n.getType()) { case Token.RETURN: if (n.hasChildren()) { break;', '(n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) { Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);', ' private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); while (next != null && next.getType() == Token.BLOCK) { if (next.hasChildren()) { next = next.getFirstChild(); } else { next = computeFollowing(next); } } return next; }'], ['if (n.getParent() == null) { List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); if (outEdges.size() == 1) { return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); } } case Token.BLOCK: if (n.hasChildren()) { Node first = n.getFirstChild(); return tryRemoveUnconditionalBranching(first); } else { return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); }', 'Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));', ''], ['', 'Node fallThrough = computeFollowing(n);', 'while (next != null && next.getType() == Token.BLOCK) { if (next.hasChildren()) { next = next.getFirstChild(); } else { next = computeFollowing(next); } }'], 'a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java', 'b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java']
['Closure-86', 1, 1, 1, 1, ["// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) return true; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:"], ["// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:"], ['return true;'], ['return false;'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-87', 1, 1, 1, 1, ["if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. return NodeUtil.isExpressionNode(maybeExpr); } }"], ['if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It\'s pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); // We only have to worry about methods with an implicit \'this\' // param, or this doesn\'t happen. if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith("on")) { return false; } } return true; } return false; } }'], ['return NodeUtil.isExpressionNode(maybeExpr);'], ['if (maybeExpr.getType() == Token.EXPR_RESULT) { if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith("on")) { return false; } } return true; } return false;'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-88', 1, 1, 1, 1, ['Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. return VariableLiveness.KILL; } else { return VariableLiveness.READ;'], ['Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ;'], [''], ['Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; }'], 'a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java', 'b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java']
['Closure-89', 2, 2, 2, 2, ['Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); // Create the new alias node. Node nameNode = NodeUtil.newName(', "} // If this is aliased, then its properties can't be collapsed either. if (type != Type.FUNCTION && aliasingGets > 0) { return false; }"], ['Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } // Create the new alias node. Node nameNode = NodeUtil.newName(', "} // If this is aliased, then its properties can't be collapsed either. if (aliasingGets > 0) { return false; }"], ['', 'if (type != Type.FUNCTION && aliasingGets > 0) {'], ['if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); }', 'if (aliasingGets > 0) {'], 'a/src/com/google/javascript/jscomp/GlobalNamespace.java', 'b/src/com/google/javascript/jscomp/GlobalNamespace.java']
['Closure-90', 2, 2, 2, 2, ['// create interfaces JSType, ObjectType, FunctionType etc and have // separate implementation instead of the class hierarchy, so that // union types can also be object types, etc. if (!type.isSubtype( typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false;', '// mean "nullable Foo". For certain tags (like @extends) we de-nullify // the name for them. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }'], ['// create interfaces JSType, ObjectType, FunctionType etc and have // separate implementation instead of the class hierarchy, so that // union types can also be object types, etc. if (!type.restrictByNotNullOrUndefined().isSubtype( typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false;', '// mean "nullable Foo". For certain tags (like @extends) we de-nullify // the name for them. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }'], ['if (!type.isSubtype(', ''], ['if (!type.restrictByNotNullOrUndefined().isSubtype(', 'if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-91', 1, 1, 1, 1, ["} // Don't traverse functions that are getting lent to a prototype. } if (parent != null && parent.getType() == Token.ASSIGN) {"], ['} // Don\'t traverse functions that are getting lent to a prototype. Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(".prototype")) { return false; } } } if (parent != null && parent.getType() == Token.ASSIGN) {'], [''], ['Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(".prototype")) { return false; } }'], 'a/src/com/google/javascript/jscomp/CheckGlobalThis.java', 'b/src/com/google/javascript/jscomp/CheckGlobalThis.java']
['Closure-92', 1, 1, 1, 1, ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["int indexOfDot = namespace.indexOf('.');"], ["int indexOfDot = namespace.lastIndexOf('.');"], 'a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java', 'b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java']
['Closure-93', 1, 1, 1, 1, ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["int indexOfDot = namespace.indexOf('.');"], ["int indexOfDot = namespace.lastIndexOf('.');"], 'a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java', 'b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java']
['Closure-94', 1, 1, 1, 1, ['return true; // Binary operators are only valid if both children are valid. case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); // Names are valid if and only if they are defines themselves.'], ['return true; // Binary operators are only valid if both children are valid. case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: case Token.POS: return isValidDefineValue(val.getFirstChild(), defines); // Names are valid if and only if they are defines themselves.'], [''], ['case Token.ADD: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); case Token.POS:'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-95', 1, 1, 1, 1, ['// scope where the root object appears. This helps out people // who declare "global" names in an anonymous namespace. Scope scopeToDeclareIn = scope; // don\'t try to declare in the global scope if there\'s // already a symbol there with this name. // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {'], ['// scope where the root object appears. This helps out people // who declare "global" names in an anonymous namespace. Scope scopeToDeclareIn = scope; if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); // don\'t try to declare in the global scope if there\'s // already a symbol there with this name. if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } } // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {'], [''], ['if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-96', 1, 1, 1, 1, ['Node parameter = null; Node argument = null; while (arguments.hasNext() && parameters.hasNext()) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. parameter = parameters.next(); argument = arguments.next(); ordinal++;'], ['Node parameter = null; Node argument = null; while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. if (parameters.hasNext()) { parameter = parameters.next(); } argument = arguments.next(); ordinal++;'], ['parameters.hasNext()) {'], ['(parameters.hasNext() || parameter != null && parameter.isVarArgs())) { if (parameters.hasNext()) { }'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-97', 1, 1, 1, 1, ['// JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. result = lvalInt >>> rvalInt; break; default: throw new AssertionError("Unknown shift operator: " +'], ['// JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt; break; default: throw new AssertionError("Unknown shift operator: " +'], ['result = lvalInt >>> rvalInt;'], ['long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt;'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-98', 3, 3, 3, 3, ['} // Make sure this assignment is not in a loop. return true; }', '/** * Whether this block denotes a function scope. */ /** * Whether this block denotes a loop. */ /** * Creates a new block.', '// only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); } BasicBlock getParent() {'], ['} // Make sure this assignment is not in a loop. for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; } } return true; }', '/** * Whether this block denotes a function scope. */ private final boolean isFunction; /** * Whether this block denotes a loop. */ private final boolean isLoop; /** * Creates a new block.', '// only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); this.isFunction = root.getType() == Token.FUNCTION; if (root.getParent() != null) { int pType = root.getParent().getType(); this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR; } else { this.isLoop = false; } } BasicBlock getParent() {'], ['', '', ''], ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; } }', 'private final boolean isFunction; private final boolean isLoop;', 'this.isFunction = root.getType() == Token.FUNCTION; if (root.getParent() != null) { int pType = root.getParent().getType(); this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR; } else { this.isLoop = false; }'], 'a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java', 'b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java']
['Closure-99', 2, 2, 2, 2, ['JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false;', '} else { // Only traverse the right side if it\'s not an assignment to a prototype // property or subproperty. if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals("prototype")) { return false; } if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(".prototype.")) { return false; } } }'], ['JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false;', '} else { // Only traverse the right side if it\'s not an assignment to a prototype // property or subproperty. if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals("prototype")) { return false; } Node llhs = lhs.getFirstChild(); if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals("prototype")) { return false; } } } }'], ['', 'if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(".prototype.")) {'], ['jsDoc.isInterface() ||', 'if (NodeUtil.isGet(lhs)) { Node llhs = lhs.getFirstChild(); if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals("prototype")) { }'], 'a/src/com/google/javascript/jscomp/CheckGlobalThis.java', 'b/src/com/google/javascript/jscomp/CheckGlobalThis.java']
['Closure-100', 2, 2, 2, 2, ['// var a = function() { }; // or // function a() {} // or // a.x = function() {}; } if (parent != null && parent.getType() == Token.ASSIGN) {', '} // Also report a THIS with a property access. return false; } /**'], ['// var a = function() { }; // or // function a() {} // or // a.x = function() {}; int pType = parent.getType(); if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) { return false; } } if (parent != null && parent.getType() == Token.ASSIGN) {', '} // Also report a THIS with a property access. return parent != null && NodeUtil.isGet(parent); } /**'], ['', 'return false;'], ['int pType = parent.getType(); if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) { return false; }', 'return parent != null && NodeUtil.isGet(parent);'], 'a/src/com/google/javascript/jscomp/CheckGlobalThis.java', 'b/src/com/google/javascript/jscomp/CheckGlobalThis.java']
['Closure-101', 1, 1, 1, 1, ['for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } if (flags.process_closure_primitives) { options.closurePass = true; } initOptionsFromFlags(options); return options; }'], ['for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }'], ['if (flags.process_closure_primitives) { options.closurePass = true; }'], ['options.closurePass = flags.process_closure_primitives;'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-102', 1, 1, 1, 1, ['@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }'], ['@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }'], ['removeDuplicateDeclarations(root);'], ['removeDuplicateDeclarations(root);'], 'a/src/com/google/javascript/jscomp/Normalize.java', 'b/src/com/google/javascript/jscomp/Normalize.java']
['Closure-103', 2, 2, 2, 2, ['case Token.ASSIGN: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false;', '} // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. return foundType; }'], ['case Token.ASSIGN: case Token.INC: case Token.DEC: case Token.INSTANCEOF: return true; case Token.FUNCTION: return false;', '} // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. if (foundType == null) { ObjectType maybeType = ObjectType.cast( registry.getGreatestSubtypeWithProperty(type, field)); // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. if (maybeType != null && maybeType.hasOwnProperty(field)) { foundType = maybeType; } } return foundType; }'], ['', ''], ['case Token.INSTANCEOF:', 'if (foundType == null) { ObjectType maybeType = ObjectType.cast( registry.getGreatestSubtypeWithProperty(type, field)); if (maybeType != null && maybeType.hasOwnProperty(field)) { foundType = maybeType; } }'], 'a/src/com/google/javascript/jscomp/DisambiguateProperties.java', 'b/src/com/google/javascript/jscomp/DisambiguateProperties.java']
['Closure-104', 1, 1, 1, 1, ['builder.addAlternate(that); } JSType result = builder.build(); if (result != null) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);'], ['builder.addAlternate(that); } JSType result = builder.build(); if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);'], ['if (result != null) {'], ['if (!result.isNoType()) {'], 'a/src/com/google/javascript/rhino/jstype/UnionType.java', 'b/src/com/google/javascript/rhino/jstype/UnionType.java']
['Closure-105', 2, 2, 2, 2, [' String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem);', 'elem = elem.getNext(); } if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));'], [' String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem);', 'elem = elem.getNext(); } if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));'], ['StringBuilder sb = new StringBuilder(); if (sb.length() > 0) { if (sb.length() > 0) { sb = new StringBuilder();', 'if (sb.length() > 0) {'], ['StringBuilder sb = null; if (sb == null) { sb = new StringBuilder(); } else { if (sb != null) { sb = null;', 'if (sb != null) {'], 'a/src/com/google/javascript/jscomp/FoldConstants.java', 'b/src/com/google/javascript/jscomp/FoldConstants.java']
['Closure-106', 2, 2, 2, 2, ["// Don't try to collapse if the one global set is a twin reference. // We could theoretically handle this case in CollapseProperties, but // it's probably not worth the effort. if (isClassOrEnum) { return true;", '* @return {@code true} if the description was recorded. */ public boolean recordBlockDescription(String description) { if (parseDocumentation) { populated = true; } return currentInfo.documentBlock(description); }'], ["// Don't try to collapse if the one global set is a twin reference. // We could theoretically handle this case in CollapseProperties, but // it's probably not worth the effort. Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; } if (isClassOrEnum) { return true;", '* @return {@code true} if the description was recorded. */ public boolean recordBlockDescription(String description) { populated = true; return currentInfo.documentBlock(description); }'], ['', 'if (parseDocumentation) { }'], ['Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; }', ''], 'a/src/com/google/javascript/rhino/JSDocInfoBuilder.java', 'b/src/com/google/javascript/rhino/JSDocInfoBuilder.java']
['Closure-107', 1, 1, 1, 1, ["// so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. options.messageBundle = new EmptyMessageBundle(); } return options;"], ["// so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. options.messageBundle = new EmptyMessageBundle(); options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF); } return options;"], [''], ['options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-108', 4, 4, 4, 4, ['private final Map<String, Var> aliases = Maps.newHashMap(); // Also temporary and cleared for each scope. // Suppose you create an alias. // var x = goog.x;', ' if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null;', '} else { grandparent.addChildBefore(newDecl, varNode); } } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', '// When we inject declarations, we duplicate jsdoc. Make sure // we only process that jsdoc once. JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }'], ['private final Map<String, Var> aliases = Maps.newHashMap(); // Also temporary and cleared for each scope. private final Set<Node> injectedDecls = Sets.newHashSet(); // Suppose you create an alias. // var x = goog.x;', ' if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); injectedDecls.clear(); aliases.clear(); forbiddenLocals.clear(); transformation = null;', '} else { grandparent.addChildBefore(newDecl, varNode); } injectedDecls.add(newDecl.getFirstChild()); } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', '// When we inject declarations, we duplicate jsdoc. Make sure // we only process that jsdoc once. JSDocInfo info = n.getJSDocInfo(); if (info != null && !injectedDecls.contains(n)) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }'], ['', '', '', 'if (info != null) {'], ['private final Set<Node> injectedDecls = Sets.newHashSet();', 'injectedDecls.clear();', 'injectedDecls.add(newDecl.getFirstChild());', 'if (info != null && !injectedDecls.contains(n)) {'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-109', 1, 1, 1, 1, ['* For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { return parseTypeName(token); } /**'], ['* For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); } } /**'], ['return parseTypeName(token);'], ['if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); }'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-110', 6, 6, 6, 6, ['Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) {', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name);', ' // First, we need to free up the function expression (EXPR) // to be used in another expression. // Replace "function NAME() { ... }" with "var NAME;". // We can\'t keep the local name on the function expression, // because IE is buggy and will leak the name into the global', '// // This will only cause problems if this is a hoisted, recursive // function, and the programmer is using the hoisting. // If this is a VAR, we can just detach the expression and // the tree will still be valid. // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info.', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', 'return null; } Node n = first; while (n.next != child) { n = n.next;'], ['Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) {', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVar || isFunctionDecl) { boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent); Node grandparent = parent.getParent(); Node value = v.getInitialValue() != null ? v.getInitialValue() : null; Node varNode = null; String name = n.getString(); int nameCount = scopedAliasNames.count(name);', ' // First, we need to free up the function expression (EXPR) // to be used in another expression. if (isFunctionDecl) { // Replace "function NAME() { ... }" with "var NAME;". Node existingName = v.getNameNode(); // We can\'t keep the local name on the function expression, // because IE is buggy and will leak the name into the global', '// // This will only cause problems if this is a hoisted, recursive // function, and the programmer is using the hoisting. Node newName = IR.name("").useSourceInfoFrom(existingName); value.replaceChild(existingName, newName); varNode = IR.var(existingName).useSourceInfoFrom(existingName); grandparent.replaceChild(parent, varNode); } else { if (value != null) { // If this is a VAR, we can just detach the expression and // the tree will still be valid. value.detachFromParent(); } varNode = parent; } // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info.', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); if (isHoisted) { grandparent.addChildToFront(newDecl); } else { grandparent.addChildBefore(newDecl, varNode); } } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', 'return null; } Node n = first; if (n == null) { throw new RuntimeException("node is not a child"); } while (n.next != child) { n = n.next;'], ['', '} else if (isVar) { Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : Node varNode = parent;', '', '', '', ''], ['boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);', '} else if (isVar || isFunctionDecl) { boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent); Node value = v.getInitialValue() != null ? v.getInitialValue() : Node varNode = null;', 'if (isFunctionDecl) { Node existingName = v.getNameNode();', 'Node newName = IR.name("").useSourceInfoFrom(existingName); value.replaceChild(existingName, newName); varNode = IR.var(existingName).useSourceInfoFrom(existingName); grandparent.replaceChild(parent, varNode); } else { if (value != null) { value.detachFromParent(); } varNode = parent; }', 'if (isHoisted) { grandparent.addChildToFront(newDecl); } else { }', 'if (n == null) { throw new RuntimeException("node is not a child"); }'], 'a/src/com/google/javascript/rhino/Node.java', 'b/src/com/google/javascript/rhino/Node.java']
['Closure-111', 1, 1, 1, 1, ['new RestrictByTrueTypeOfResultVisitor() { @Override protected JSType caseTopType(JSType topType) { return topType; } @Override'], ['new RestrictByTrueTypeOfResultVisitor() { @Override protected JSType caseTopType(JSType topType) { return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType; } @Override'], ['return topType;'], ['return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType;'], 'a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java', 'b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java']
['Closure-112', 1, 1, 1, 1, ["} // Try to infer the template types Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n); // Replace all template types. If we couldn't find a replacement, we // replace it with UNKNOWN."], ["} // Try to infer the template types Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} ); // Replace all template types. If we couldn't find a replacement, we // replace it with UNKNOWN."], ['Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);'], ['Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} );'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-113', 1, 1, 1, 1, ['// the checks for broken requires turned off. In these cases, we // allow broken requires to be preserved by the first run to // let them be caught in the subsequent run. if (provided != null) { parent.detachFromParent(); compiler.reportCodeChange(); }'], ['// the checks for broken requires turned off. In these cases, we // allow broken requires to be preserved by the first run to // let them be caught in the subsequent run. if (provided != null || requiresLevel.isOn()) { parent.detachFromParent(); compiler.reportCodeChange(); }'], ['if (provided != null) {'], ['if (provided != null || requiresLevel.isOn()) {'], 'a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java', 'b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java']
['Closure-114', 1, 1, 1, 1, ["} else { recordDepScope(nameNode, ns); } } else { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"], ["} else { recordDepScope(nameNode, ns); } } else if (!(parent.isCall() && parent.getFirstChild() == n)) { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"], ['} else {'], ['} else if (!(parent.isCall() && parent.getFirstChild() == n)) {'], 'a/src/com/google/javascript/jscomp/NameAnalyzer.java', 'b/src/com/google/javascript/jscomp/NameAnalyzer.java']
['Closure-115', 2, 2, 2, 2, [' Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop.'], [' Node block = fnNode.getLastChild(); // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop.'], ['boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }', 'if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }'], ['', ''], 'a/src/com/google/javascript/jscomp/FunctionInjector.java', 'b/src/com/google/javascript/jscomp/FunctionInjector.java']
['Closure-116', 2, 2, 2, 2, [' Node block = fnNode.getLastChild(); // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a'], [' Node block = fnNode.getLastChild(); boolean hasSideEffects = false; // empty function case if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects( stmt.getFirstChild(), compiler); } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a'], ['', ''], ['boolean hasSideEffects = false; // empty function case if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects( stmt.getFirstChild(), compiler); } }', 'if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }'], 'a/src/com/google/javascript/jscomp/FunctionInjector.java', 'b/src/com/google/javascript/jscomp/FunctionInjector.java']
['Closure-117', 2, 2, 2, 2, ["* to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { // The best type name is the actual type name. // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where", '} } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;'], ["* to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } // The best type name is the actual type name. if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where", '} } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;'], ['', 'JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }'], ['JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }', ''], 'a/src/com/google/javascript/jscomp/TypeValidator.java', 'b/src/com/google/javascript/jscomp/TypeValidator.java']
['Closure-118', 1, 1, 1, 1, ['child != null; child = child.getNext()) { // Maybe STRING, GET, SET // We should never see a mix of numbers and strings. String name = child.getString();'], ['child != null; child = child.getNext()) { // Maybe STRING, GET, SET if (child.isQuotedString()) { continue; } // We should never see a mix of numbers and strings. String name = child.getString();'], [''], ['if (child.isQuotedString()) { continue; }'], 'a/src/com/google/javascript/jscomp/DisambiguateProperties.java', 'b/src/com/google/javascript/jscomp/DisambiguateProperties.java']
['Closure-119', 1, 1, 1, 1, ['isSet = true; type = Name.Type.FUNCTION; break; case Token.INC: case Token.DEC: isSet = true;'], ['isSet = true; type = Name.Type.FUNCTION; break; case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;'], [''], ['case Token.CATCH:'], 'a/src/com/google/javascript/jscomp/GlobalNamespace.java', 'b/src/com/google/javascript/jscomp/GlobalNamespace.java']
['Closure-120', 1, 1, 1, 1, ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false;'], ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { if (ref.getSymbol().getScope() != ref.scope) { return false; } break; } else if (block.isLoop) { return false;'], [''], ['if (ref.getSymbol().getScope() != ref.scope) { return false; }'], 'a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java', 'b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java']
['Closure-121', 1, 1, 1, 1, ['if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();'], ['if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();'], ['referenceInfo.isAssignedOnceInLifetime()) {'], ['referenceInfo.isAssignedOnceInLifetime() && (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {'], 'a/src/com/google/javascript/jscomp/InlineVariables.java', 'b/src/com/google/javascript/jscomp/InlineVariables.java']
['Closure-122', 1, 1, 1, 1, ['* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { if (comment.getValue().indexOf("/* @") != -1 || comment.getValue().indexOf("\\n * @") != -1) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,'], ['* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { Pattern p = Pattern.compile("(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]"); if (p.matcher(comment.getValue()).find()) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,'], ['if (comment.getValue().indexOf("/* @") != -1 || comment.getValue().indexOf("\\n * @") != -1) {'], ['Pattern p = Pattern.compile("(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]"); if (p.matcher(comment.getValue()).find()) {'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-123', 1, 1, 1, 1, ['case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); Context rhsContext = Context.OTHER; addExpr(first, p + 1, context); cc.addOp("?", true); addExpr(first.getNext(), 1, rhsContext);'], ['case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); Context rhsContext = getContextForNoInOperator(context); addExpr(first, p + 1, context); cc.addOp("?", true); addExpr(first.getNext(), 1, rhsContext);'], ['Context rhsContext = Context.OTHER;'], ['Context rhsContext = getContextForNoInOperator(context);'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-124', 1, 1, 1, 1, ['} Preconditions.checkArgument(node.isGetProp()); node = node.getFirstChild(); if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false;'], ['} Preconditions.checkArgument(node.isGetProp()); while (node.isGetProp()) { node = node.getFirstChild(); } if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false;'], [''], ['while (node.isGetProp()) { }'], 'a/src/com/google/javascript/jscomp/ExploitAssigns.java', 'b/src/com/google/javascript/jscomp/ExploitAssigns.java']
['Closure-125', 1, 1, 1, 1, ['JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {'], ['JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {'], ['if (fnType != null) {'], ['if (fnType != null && fnType.hasInstanceType()) {'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-126', 1, 1, 1, 1, ["* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'."], ["* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ } // Just a 'label'."], ['if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }'], [''], 'a/src/com/google/javascript/jscomp/MinimizeExitPoints.java', 'b/src/com/google/javascript/jscomp/MinimizeExitPoints.java']
['Closure-127', 1, 1, 1, 1, ['outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeNode(n); } } } } private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);'], ['outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } } private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } } private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);'], ['if (nextCfgNode == fallThrough) {'], ['if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } }'], 'a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java', 'b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java']
['Closure-128', 1, 1, 1, 1, [" static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0 && s.charAt(0) != '0'; } static double getSimpleNumber(String s) {"], [" static boolean isSimpleNumber(String s) { int len = s.length(); if (len == 0) { return false; } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len == 1 || s.charAt(0) != '0'; } static double getSimpleNumber(String s) {"], ["return len > 0 && s.charAt(0) != '0';"], ["if (len == 0) { return false; } return len == 1 || s.charAt(0) != '0';"], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-129', 1, 1, 1, 1, ['Node first = n.getFirstChild(); // ignore cast nodes. if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);'], ['Node first = n.getFirstChild(); // ignore cast nodes. while (first.isCast()) { first = first.getFirstChild(); } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);'], [''], ['while (first.isCast()) { first = first.getFirstChild(); }'], 'a/src/com/google/javascript/jscomp/PrepareAst.java', 'b/src/com/google/javascript/jscomp/PrepareAst.java']
['Closure-130', 1, 1, 1, 1, ['continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { // {@code name} meets condition (b). Find all of its local aliases // and try to inline them.'], ['continue; } if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { // {@code name} meets condition (b). Find all of its local aliases // and try to inline them.'], ['if (name.globalSets == 1 && name.localSets == 0 &&'], ['if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&'], 'a/src/com/google/javascript/jscomp/CollapseProperties.java', 'b/src/com/google/javascript/jscomp/CollapseProperties.java']
['Closure-131', 1, 1, 1, 1, ['int length = s.length(); if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if ( !Character.isJavaIdentifierPart(s.charAt(i))) { return false; }'], ['int length = s.length(); if (length == 0 || Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if (Character.isIdentifierIgnorable(s.charAt(i)) || !Character.isJavaIdentifierPart(s.charAt(i))) { return false; }'], ['if ('], ['Character.isIdentifierIgnorable(s.charAt(0)) || if (Character.isIdentifierIgnorable(s.charAt(i)) ||'], 'a/src/com/google/javascript/rhino/TokenStream.java', 'b/src/com/google/javascript/rhino/TokenStream.java']
['Closure-132', 1, 1, 1, 1, ['// evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild();'], ['// evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... !mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild();'], ['!mayEffectMutableState(lhs)) {'], ['!mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-133', 1, 1, 1, 1, ['*/ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }'], ['*/ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); unreadToken = NO_UNREAD_TOKEN; return result; }'], [''], ['unreadToken = NO_UNREAD_TOKEN;'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-134', 6, 6, 6, 6, ['for (Property p : propertyMap.values()) { if (!p.skipAmbiguating) { ++numRenamedPropertyNames; computeRelatedTypes(p.type); propsByFreq.add(p); } else { ++numSkippedPropertyNames;', 'if (typesRelatedToSet.intersects(prop.typesSet)) { return false; } return !getRelated(prop.type).intersects(typesInSet); } /**', '*/ public void addNode(Property prop) { typesInSet.or(prop.typesSet); typesRelatedToSet.or(getRelated(prop.type)); } /**', '/** Encapsulates the information needed for renaming a property. */ private class Property { final String oldName; JSType type; String newName; int numOccurrences; boolean skipAmbiguating; JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size()); Property(String name) { this.oldName = name;', 'return; } if (type == null) { type = newType; } else { type = type.getLeastSupertype(newType); } typesSet.set(getIntForType(newType)); } }', "JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } // If it's not, then check to see if it's implemented // on an implemented interface. return null; }"], ['for (Property p : propertyMap.values()) { if (!p.skipAmbiguating) { ++numRenamedPropertyNames; propsByFreq.add(p); } else { ++numSkippedPropertyNames;', 'if (typesRelatedToSet.intersects(prop.typesSet)) { return false; } return !prop.relatedTypesSet.intersects(typesInSet); } /**', '*/ public void addNode(Property prop) { typesInSet.or(prop.typesSet); typesRelatedToSet.or(prop.relatedTypesSet); } /**', '/** Encapsulates the information needed for renaming a property. */ private class Property { final String oldName; String newName; int numOccurrences; boolean skipAmbiguating; JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size()); JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size()); Property(String name) { this.oldName = name;', 'return; } int typeInt = getIntForType(newType); if (!typesSet.get(typeInt)) { computeRelatedTypes(newType); typesSet.set(typeInt); relatedTypesSet.or(getRelatedTypesOnNonUnion(newType)); } } }', "JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { // If it's not, then check to see if it's implemented // on an implemented interface. for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } } } return null; }"], ['computeRelatedTypes(p.type);', 'return !getRelated(prop.type).intersects(typesInSet);', 'typesRelatedToSet.or(getRelated(prop.type));', 'JSType type;', 'if (type == null) { type = newType; } else { type = type.getLeastSupertype(newType); typesSet.set(getIntForType(newType));', '}'], ['', 'return !prop.relatedTypesSet.intersects(typesInSet);', 'typesRelatedToSet.or(prop.relatedTypesSet);', 'JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size());', 'int typeInt = getIntForType(newType); if (!typesSet.get(typeInt)) { computeRelatedTypes(newType); typesSet.set(typeInt); relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));', '} else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } } }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-135', 3, 3, 3, 3, ['for (Node child : node.children()) { if (NodeUtil.isThis(child)) { Node newName = Node.newString(Token.NAME, name); node.replaceChild(child, newName); } else { replaceReferencesToThis(child, name);', 'return super.hasProperty(name) || "prototype".equals(name); } @Override public JSType getPropertyType(String name) {', 'if ("prototype".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { return setPrototype( new FunctionPrototypeType( registry, this, objType, isNativeObjectType()));'], ['for (Node child : node.children()) { if (NodeUtil.isThis(child)) { Node newName = Node.newString(Token.NAME, name); newName.setJSType(child.getJSType()); node.replaceChild(child, newName); } else { replaceReferencesToThis(child, name);', 'return super.hasProperty(name) || "prototype".equals(name); } @Override public boolean hasOwnProperty(String name) { return super.hasOwnProperty(name) || "prototype".equals(name); } @Override public JSType getPropertyType(String name) {', 'if ("prototype".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (objType.equals(prototype)) { return true; } return setPrototype( new FunctionPrototypeType( registry, this, objType, isNativeObjectType()));'], ['', '', ''], ['newName.setJSType(child.getJSType());', '@Override public boolean hasOwnProperty(String name) { return super.hasOwnProperty(name) || "prototype".equals(name); }', 'if (objType.equals(prototype)) { return true; }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-136', 2, 2, 2, 2, ['* itself or the name of a function). */ private void addPossibleSignature(String name, Node node, NodeTraversal t) { boolean signatureAdded = false; if (node.getType() == Token.FUNCTION) { // The node we\'re looking at is a function, so we can add it directly addSignature(name, node, t.getSourceName()); signatureAdded = true; } else if (node.getType() == Token.NAME) { String functionName = node.getString(); Scope.Var v = t.getScope().getVar(functionName); if (v == null) { if (compiler.isIdeMode()) { return; } else { throw new IllegalStateException( "VarCheck should have caught this undefined function"); } } Node function = v.getInitialValue(); if (function != null && function.getType() == Token.FUNCTION) { addSignature(name, function, v.getInputName()); signatureAdded = true; } } if (!signatureAdded) { nonMethodProperties.add(name); } }', ' // Check if we can rename this. if (!okToRenameVar(name, local)) { // Blindly de-uniquify for the Prototype library for issue 103. return; }'], ["* itself or the name of a function). */ private void addPossibleSignature(String name, Node node, NodeTraversal t) { if (node.getType() == Token.FUNCTION) { // The node we're looking at is a function, so we can add it directly addSignature(name, node, t.getSourceName()); } else { nonMethodProperties.add(name); } }", ' // Check if we can rename this. if (!okToRenameVar(name, local)) { if (local) { // Blindly de-uniquify for the Prototype library for issue 103. String newName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName( name); if (!newName.equals(name)) { n.setString(newName); } } return; }'], ['boolean signatureAdded = false; signatureAdded = true; } else if (node.getType() == Token.NAME) { String functionName = node.getString(); Scope.Var v = t.getScope().getVar(functionName); if (v == null) { if (compiler.isIdeMode()) { return; } else { throw new IllegalStateException( "VarCheck should have caught this undefined function"); } } Node function = v.getInitialValue(); if (function != null && function.getType() == Token.FUNCTION) { addSignature(name, function, v.getInputName()); signatureAdded = true; } } if (!signatureAdded) {', ''], ['} else {', 'if (local) { String newName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName( name); if (!newName.equals(name)) { n.setString(newName); } }'], 'a/src/com/google/javascript/jscomp/RenameVars.java', 'b/src/com/google/javascript/jscomp/RenameVars.java']
['Closure-137', 10, 10, 10, 10, ['import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;', 'class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer;', "/** * Inverts the transformation by {@link ContextualRenamer}, when possible. */ static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; // The set of names referenced in the current scope. // Stack reference sets. // Name are globally unique initially, so we don't need a per-scope map. private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;", 'private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } /** * Prepare a set for the new scope. */ private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } /** * Rename vars for the current scope, and merge any referenced * names into the parent scope reference set. */ @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); // Merge any names that were referenced but not declared in the current // scope. // If there isn\'t anything left in the stack we will be going into the // global scope: don\'t try to build a set of referenced names for the // global scope. boolean recurseScopes = false; if (!suffix.matches("\\\\d+")) { recurseScopes = true; } /** * For the Var declared in the current scope determine if it is possible * to revert the name to its orginal form without conflicting with other * values. */ // Check if the new name is valid and if it would cause conflicts. if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); // Adding a reference to the new name to prevent either the parent // scopes or the current scope renaming another var to this new name. Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } // Add all referenced names to the set so it is possible to check for // conflicts. // Store only references to candidate names in the node map. } } } } /**', '*/ @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else {', 'String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } }', ' @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); }', '* @return Whether the name is a reference to a variable, function or * function parameter (not a label or a empty anonymous function name). */ /** @return Whether the node is a label name. */ static boolean isLabelName(Node n) {', 'public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', "// } // otherwise 'var e = 1' would be rewritten as 'e = 1'. // TODO(johnlenz): Introduce a seperate scope for catch nodes. new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"], ['import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;', 'class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { public static final String ARGUMENTS = "arguments"; private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer;', "/** * Inverts the transformation by {@link ContextualRenamer}, when possible. */ static class ContextualRenameInverter implements ScopedCallback, CompilerPass { private final AbstractCompiler compiler; // The set of names referenced in the current scope. private Set<String> referencedNames = ImmutableSet.of(); // Stack reference sets. private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>(); // Name are globally unique initially, so we don't need a per-scope map. private Map<String, List<Node>> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;", "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } /** * Prepare a set for the new scope. */ public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } referenceStack.push(referencedNames); referencedNames = Sets.newHashSet(); } /** * Rename vars for the current scope, and merge any referenced * names into the parent scope reference set. */ public void exitScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); handleScopeVar(v); } // Merge any names that were referenced but not declared in the current // scope. Set<String> current = referencedNames; referencedNames = referenceStack.pop(); // If there isn't anything left in the stack we will be going into the // global scope: don't try to build a set of referenced names for the // global scope. if (!referenceStack.isEmpty()) { referencedNames.addAll(current); } } /** * For the Var declared in the current scope determine if it is possible * to revert the name to its orginal form without conflicting with other * values. */ void handleScopeVar(Var v) { String name = v.getName(); if (containsSeparator(name)) { String newName = getOrginalName(name); // Check if the new name is valid and if it would cause conflicts. if (TokenStream.isJSIdentifier(newName) && !referencedNames.contains(newName) && !newName.equals(ARGUMENTS)) { referencedNames.remove(name); // Adding a reference to the new name to prevent either the parent // scopes or the current scope renaming another var to this new name. referencedNames.add(newName); List<Node> references = nameMap.get(name); Preconditions.checkState(references != null); for (Node n : references) { Preconditions.checkState(n.getType() == Token.NAME); n.setString(newName); } compiler.reportCodeChange(); } nameMap.remove(name); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (t.inGlobalScope()) { return; } if (NodeUtil.isReferenceName(node)) { String name = node.getString(); // Add all referenced names to the set so it is possible to check for // conflicts. referencedNames.add(name); // Store only references to candidate names in the node map. if (containsSeparator(name)) { addCandidateNameReference(name, node); } } } private void addCandidateNameReference(String name, Node n) { List<Node> nodes = nameMap.get(name); if (null == nodes) { nodes = Lists.newLinkedList(); nameMap.put(name, nodes); } nodes.add(n); } } /**", '*/ @Override public void addDeclaredName(String name) { if (!name.equals(ARGUMENTS)) { if (global) { reserveName(name); } else {', 'String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } }', ' @Override public void addDeclaredName(String name) { Preconditions.checkState(!name.equals(ARGUMENTS)); if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); }', '* @return Whether the name is a reference to a variable, function or * function parameter (not a label or a empty anonymous function name). */ static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); } /** @return Whether the node is a label name. */ static boolean isLabelName(Node n) {', 'public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', "// } // otherwise 'var e = 1' would be rewritten as 'e = 1'. // TODO(johnlenz): Introduce a seperate scope for catch nodes. removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"], ['import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;', '', 'static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private Map<Var, String> nameMap = Maps.newHashMap();', 'private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches("\\\\d+")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); nameMap.put(var, newName);', '', 'declarations.put(name, newName);', '', '', 'removeDuplicateDeclarations(root);', ''], ['import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;', 'public static final String ARGUMENTS = "arguments";', 'static class ContextualRenameInverter implements ScopedCallback, CompilerPass { private Set<String> referencedNames = ImmutableSet.of(); private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>(); private Map<String, List<Node>> nameMap = Maps.newHashMap();', 'public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } referenceStack.push(referencedNames); referencedNames = Sets.newHashSet(); public void exitScope(NodeTraversal t) { if (t.inGlobalScope()) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); handleScopeVar(v); } Set<String> current = referencedNames; referencedNames = referenceStack.pop(); if (!referenceStack.isEmpty()) { referencedNames.addAll(current); } } void handleScopeVar(Var v) { String name = v.getName(); if (containsSeparator(name)) { String newName = getOrginalName(name); if (TokenStream.isJSIdentifier(newName) && !referencedNames.contains(newName) && !newName.equals(ARGUMENTS)) { referencedNames.remove(name); referencedNames.add(newName); List<Node> references = nameMap.get(name); Preconditions.checkState(references != null); for (Node n : references) { Preconditions.checkState(n.getType() == Token.NAME); n.setString(newName); } nameMap.remove(name); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (t.inGlobalScope()) { return; if (NodeUtil.isReferenceName(node)) { String name = node.getString(); referencedNames.add(name); if (containsSeparator(name)) { addCandidateNameReference(name, node); private void addCandidateNameReference(String name, Node n) { List<Node> nodes = nameMap.get(name); if (null == nodes) { nodes = Lists.newLinkedList(); nameMap.put(name, nodes); } nodes.add(n); }', 'if (!name.equals(ARGUMENTS)) {', '} declarations.put(name, newName);', 'Preconditions.checkState(!name.equals(ARGUMENTS));', 'static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); }', '', 'removeDuplicateDeclarations(root);'], 'a/src/com/google/javascript/jscomp/Normalize.java', 'b/src/com/google/javascript/jscomp/Normalize.java']
['Closure-138', 3, 3, 3, 3, ['Node param = condition.getLastChild(); if (callee.getType() == GETPROP && param.isQualifiedName()) { JSType paramType = getTypeIfRefinable(param, blindScope); if (paramType != null) { Node left = callee.getFirstChild(); Node right = callee.getLastChild(); if (left.getType() == NAME && "goog".equals(left.getString()) &&', 'if (restricter != null) { return restrictParameter(param, paramType, blindScope, restricter, outcome); } } } }', "return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) { // There are two situations where we don't want to use type information // from the scope, even if we have it. // 1) The var is escaped in a weird way, e.g., // function f() { var x = 3; function g() { x = null } (x); } // 2) We're reading type information from another scope for an // inferred variable. // var t = null; function f() { (t); } type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); } } }"], ['Node param = condition.getLastChild(); if (callee.getType() == GETPROP && param.isQualifiedName()) { JSType paramType = getTypeIfRefinable(param, blindScope); Node left = callee.getFirstChild(); Node right = callee.getLastChild(); if (left.getType() == NAME && "goog".equals(left.getString()) &&', 'if (restricter != null) { return restrictParameter(param, paramType, blindScope, restricter, outcome); } } }', "return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { // There are two situations where we don't want to use type information // from the scope, even if we have it. // 1) The var is escaped in a weird way, e.g., // function f() { var x = 3; function g() { x = null } (x); } boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && unflowableVarNames.contains(varName); // 2) We're reading type information from another scope for an // inferred variable. // var t = null; function f() { (t); } boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); } } } }"], ['if (paramType != null) {', '}', 'if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {'], ['', '', 'if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && unflowableVarNames.contains(varName); boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { }'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-139', 4, 4, 4, 4, ['} break; } }', '* to: * var f = function () {}; */ /** * Rewrite the function declaration from:', '* LP * BLOCK */ // Prepare a spot for the function. // Prepare the function // Move the function /** * Do normalizations that introduce new siblings or parents.', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { // If name is "arguments", Var maybe null. Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps);'], ['} break; case Token.FUNCTION: normalizeFunctionDeclaration(n); break; } }', '* to: * var f = function () {}; */ private void normalizeFunctionDeclaration(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); if (!NodeUtil.isFunctionAnonymous(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) { rewriteFunctionDeclaration(n); } } /** * Rewrite the function declaration from:', '* LP * BLOCK */ private void rewriteFunctionDeclaration(Node n) { // Prepare a spot for the function. Node oldNameNode = n.getFirstChild(); Node fnNameNode = oldNameNode.cloneNode(); Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno()); var.copyInformationFrom(n); // Prepare the function oldNameNode.setString(""); // Move the function Node parent = n.getParent(); parent.replaceChild(n, var); fnNameNode.addChildToFront(n); reportCodeChange("Function declaration"); } /** * Do normalizations that introduce new siblings or parents.', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); Var v = s.getVar(name); // If name is "arguments", Var maybe null. Preconditions.checkState( v == null || v.getParentNode().getType() != Token.CATCH); if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) { s.undeclare(v); s.declare(name, n, n.getJSType(), v.input); replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); } } else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps);'], ['', '', '', 'if (parent.getType() == Token.VAR) {'], ['case Token.FUNCTION: normalizeFunctionDeclaration(n); break;', 'private void normalizeFunctionDeclaration(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); if (!NodeUtil.isFunctionAnonymous(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) { rewriteFunctionDeclaration(n); } }', 'private void rewriteFunctionDeclaration(Node n) { Node oldNameNode = n.getFirstChild(); Node fnNameNode = oldNameNode.cloneNode(); Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno()); var.copyInformationFrom(n); oldNameNode.setString(""); Node parent = n.getParent(); parent.replaceChild(n, var); fnNameNode.addChildToFront(n); reportCodeChange("Function declaration"); }', 'Var v = s.getVar(name); Preconditions.checkState( v == null || v.getParentNode().getType() != Token.CATCH); if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) { s.undeclare(v); s.declare(name, n, n.getJSType(), v.input); replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); } } else if (parent.getType() == Token.VAR) {'], 'a/src/com/google/javascript/jscomp/Normalize.java', 'b/src/com/google/javascript/jscomp/Normalize.java']
['Closure-140', 3, 3, 3, 3, ['initOptions(options); checkFirstModule(modules); this.externs = makeCompilerInput(externs, true); this.modules = modules;', '* Fill any empty modules with a place holder file. It makes any cross module * motion easier. */ static final DiagnosticType DUPLICATE_INPUT_IN_MODULES = DiagnosticType.error("JSC_DUPLICATE_INPUT_IN_MODULES_ERROR",', 'if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) { inputs = m.getInputs(); if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } } throw new IllegalStateException("Root module has no inputs"); }'], ['initOptions(options); checkFirstModule(modules); fillEmptyModules(modules); this.externs = makeCompilerInput(externs, true); this.modules = modules;', '* Fill any empty modules with a place holder file. It makes any cross module * motion easier. */ private void fillEmptyModules(JSModule[] modules) { for (int i = 1; i < modules.length; i ++) { JSModule module = modules[i]; if (module.getInputs().isEmpty()) { module.add(JSSourceFile.fromCode("[" + module.getName() + "]", "")); } } } static final DiagnosticType DUPLICATE_INPUT_IN_MODULES = DiagnosticType.error("JSC_DUPLICATE_INPUT_IN_MODULES_ERROR",', 'if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } throw new IllegalStateException("Root module has no inputs"); }'], ['', '', 'for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) { inputs = m.getInputs(); if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } }'], ['fillEmptyModules(modules);', 'private void fillEmptyModules(JSModule[] modules) { for (int i = 1; i < modules.length; i ++) { JSModule module = modules[i]; if (module.getInputs().isEmpty()) { module.add(JSSourceFile.fromCode("[" + module.getName() + "]", "")); } } }', ''], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-141', 3, 3, 3, 3, ['case Token.GETELEM: return true; // Anonymous functions definitions are not changed by side-effects, // and named functions are not part of expressions. } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {', '*/ private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { List<Definition> result = Lists.newArrayList(); if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; } Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) {', '} return result; } /**'], ['case Token.GETELEM: return true; case Token.FUNCTION: // Anonymous functions definitions are not changed by side-effects, // and named functions are not part of expressions. Preconditions.checkState(NodeUtil.isAnonymousFunction(n)); return false; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {', '*/ private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) { List<Definition> result = Lists.newArrayList(); Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) {', '} return result; } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) { Node firstVal; if (name.getType() == Token.HOOK) { firstVal = name.getFirstChild().getNext(); } else { firstVal = name.getFirstChild(); } Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal); Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext()); if (defs1 != null && defs2 != null) { defs1.addAll(defs2); return defs1; } else { return null; } } else { return null; } } /**'], ['', 'if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; }', ''], ['case Token.FUNCTION: Preconditions.checkState(NodeUtil.isAnonymousFunction(n)); return false;', 'if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {', '} else if (name.getType() == Token.OR || name.getType() == Token.HOOK) { Node firstVal; if (name.getType() == Token.HOOK) { firstVal = name.getFirstChild().getNext(); } else { firstVal = name.getFirstChild(); } Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal); Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext()); if (defs1 != null && defs2 != null) { defs1.addAll(defs2); return defs1; } else { return null; } } else { return null; }'], 'a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java', 'b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java']
['Closure-142', 3, 3, 3, 3, ['// a work-around for an IE bug where it throws an exception if you // write to the parameters of the callback in a sort(). See: // http://code.google.com/p/closure-compiler/issues/detail?id=58 liveness.analyze(); UndiGraph<Var, Void> interferenceGraph =', "case EOF: // When we're capturing a license block, annotations // in the block are ok. String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) {", '} return new ExtractionInfo(multilineText, token); // FALL THROUGH'], ['// a work-around for an IE bug where it throws an exception if you // write to the parameters of the callback in a sort(). See: // http://code.google.com/p/closure-compiler/issues/detail?id=58 if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) { liveness.markAllParametersEscaped(); } liveness.analyze(); UndiGraph<Var, Void> interferenceGraph =', "case EOF: // When we're capturing a license block, annotations // in the block are ok. if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) {", '} return new ExtractionInfo(multilineText, token); } // FALL THROUGH'], ['', '', ''], ['if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) { liveness.markAllParametersEscaped(); }', 'if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) {', '}'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-143', 2, 2, 2, 2, ["} else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') )) { // If the value starts and ends with a single quote, // we assume that it's a string. String maybeStringVal =", ' Node exprBody = node.getFirstChild(); if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody) ) { changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody)); } }'], ['} else if (defValue.length() > 1 && ((defValue.charAt(0) == \'\\\'\' && defValue.charAt(defValue.length() - 1) == \'\\\'\') || (defValue.charAt(0) == \'\\"\' && defValue.charAt(defValue.length() - 1) == \'\\"\'))) { // If the value starts and ends with a single quote, // we assume that it\'s a string. String maybeStringVal =', ' Node exprBody = node.getFirstChild(); if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody) || exprBody.getType() == Token.NEW || exprBody.getType() == Token.CALL) { changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody)); } }'], [')) {', ') {'], ['|| (defValue.charAt(0) == \'\\"\' && defValue.charAt(defValue.length() - 1) == \'\\"\'))) {', '|| exprBody.getType() == Token.NEW || exprBody.getType() == Token.CALL) {'], 'a/src/com/google/javascript/jscomp/RemoveConstantExpressions.java', 'b/src/com/google/javascript/jscomp/RemoveConstantExpressions.java']
['Closure-144', 9, 9, 9, 9, ['private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null;', '*/ FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); }', '* If we haven\'t found a return value yet, try to look at the "return" * statements in the function. */ /** * Infer the role of the function (whether it\'s a constructor or interface)', '.withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType) .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build();', 'Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry);', '.setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode) .inferThisType(info, owner) .buildAndRegister(); } }', '.inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) .buildAndRegister(); }', "} /** Set the return type and whether it's inferred. */ /** Sets an inferred return type. */ public FunctionBuilder withInferredReturnType(JSType returnType) {", ' FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) { return new FunctionType( registry, null, null, new ArrowType( registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);'], ['private final Scope scope; private JSType returnType = null; private boolean returnTypeInferred = false; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null;', '*/ FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : null; if (templateTypeName != null && returnType != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); }', '* If we haven\'t found a return value yet, try to look at the "return" * statements in the function. */ FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) { if (functionBlock == null || compiler.getInput(sourceName).isExtern()) { return this; } Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK); if (returnType == null) { boolean hasNonEmptyReturns = false; List<Node> worklist = Lists.newArrayList(functionBlock); while (!worklist.isEmpty()) { Node current = worklist.remove(worklist.size() - 1); int cType = current.getType(); if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) { hasNonEmptyReturns = true; break; } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) { for (Node child = current.getFirstChild(); child != null; child = child.getNext()) { worklist.add(child); } } } if (!hasNonEmptyReturns) { returnType = typeRegistry.getNativeType(VOID_TYPE); returnTypeInferred = true; } } return this; } /** * Infer the role of the function (whether it\'s a constructor or interface)', '.withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType, returnTypeInferred) .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build();', 'Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry);', '.setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode) .inferThisType(info, owner) .inferReturnStatements(fnBlock) .buildAndRegister(); } }', '.inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) .inferReturnStatements(fnBlock) .buildAndRegister(); }', "} /** Set the return type and whether it's inferred. */ public FunctionBuilder withReturnType(JSType returnType, boolean inferred) { this.returnType = returnType; this.inferredReturnType = inferred; return this; } /** Sets an inferred return type. */ public FunctionBuilder withInferredReturnType(JSType returnType) {", ' FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) { return new FunctionType( registry, null, source, new ArrowType( registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);'], ['', 'info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);', '', '.withReturnType(returnType)', '', '', '', '', 'registry, null, null,'], ['private boolean returnTypeInferred = false;', 'info.getReturnType().evaluate(scope, typeRegistry) : null; returnType != null &&', 'FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) { if (functionBlock == null || compiler.getInput(sourceName).isExtern()) { return this; } Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK); if (returnType == null) { boolean hasNonEmptyReturns = false; List<Node> worklist = Lists.newArrayList(functionBlock); while (!worklist.isEmpty()) { Node current = worklist.remove(worklist.size() - 1); int cType = current.getType(); if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) { hasNonEmptyReturns = true; break; } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) { for (Node child = current.getFirstChild(); child != null; child = child.getNext()) { worklist.add(child); } } } if (!hasNonEmptyReturns) { returnType = typeRegistry.getNativeType(VOID_TYPE); returnTypeInferred = true; } } return this; }', '.withReturnType(returnType, returnTypeInferred)', 'Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;', '.inferReturnStatements(fnBlock)', '.inferReturnStatements(fnBlock)', 'public FunctionBuilder withReturnType(JSType returnType, boolean inferred) { this.returnType = returnType; this.inferredReturnType = inferred; return this; }', 'registry, null, source,'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-145', 1, 1, 1, 1, ["* labels). */ private boolean isOneExactlyFunctionOrDo(Node n) { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } /**"], ["* labels). */ private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } /**"], [''], ['if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } } } else { }'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-146', 1, 1, 1, 1, ['// other types switch (this.testForEquality(that)) { case TRUE: return new TypePair(null, null); case FALSE: case UNKNOWN:'], ['// other types switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN:'], ['return new TypePair(null, null);'], ['JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);'], 'a/src/com/google/javascript/rhino/jstype/JSType.java', 'b/src/com/google/javascript/rhino/jstype/JSType.java']
['Closure-147', 2, 2, 2, 2, ['if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) { return false; } } ld mode 100755 ew mode 100644', ' // To satisfy normalization constraints, the type checking must be // added after any inner function declarations. for (Node paramType : funType.getParameters()) { // Can this ever happen? ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644'], ['if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || pType == Token.OBJECTLIT)) { return false; } } ld mode 100755 ew mode 100644', ' // To satisfy normalization constraints, the type checking must be // added after any inner function declarations. for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) { insertionPoint = next; } for (Node paramType : funType.getParameters()) { // Can this ever happen? ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644'], ['pType == Token.ASSIGN)) {', ''], ['pType == Token.ASSIGN || pType == Token.OBJECTLIT)) {', 'for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) { insertionPoint = next; }'], 'a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java', 'b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java']
['Closure-148', 16, 16, 16, 16, ['case Token.ARRAYLIT: typeNameString = "object"; break; case Token.NAME: // We assume here that programs don\'t change the value of the // keyword undefined to something other than the value undefined.', '*/ public class SourceMap { /** * A mapping from a given position in an input source file to a given position', '/** * A unique ID for this mapping for record keeping purposes. */ int id; /** * The input source file.', '/** * Whether the mapping is actually used by the source map. */ /** * Cache of escaped source file name. */ /** * Appends the mapping to the given buffer. */ void appendTo(Appendable out) throws IOException { out.append("["); out.append(sourceFile); // The source file rarely changes, so cache the escaped string. out.append(","); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(","); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(","); out.append(originalName); } out.append("]"); } /** * Add used mappings to the supplied Appendable. */ } /**', 'private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; /** * Adds a mapping for the given node. Mappings must be added in order.', 'return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, "s1 != s2" not "!s1.equals(s2)" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; // Create the new mapping. Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } // If the mapping is found on the first line, we need to offset // its character position by the number of characters found on // the *last* line of the source file to which the code is', 'mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }', 'prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } /** * Appends the source map in LavaBug format to the given buffer. *', '// 11) ["c.js", 1, 4] // 12) ["d.js", 3, 78, "foo"] int maxLine = findLastLine(); // Add the line character maps. out.append("/** Begin line maps. **/{ \\"file\\" : ");', '// Add the mappings themselves. out.append("/** Begin mapping definitions. **/\\n"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append("\\n"); } } /** * Assigns sequential ids to used mappings, and returns the last line mapped. */ // Mark any unused mappings. // Renumber used mappings and keep track of the last line. // Adjust for the prefix. private class LineMapper { // The destination. private final Appendable out; private int line; private int col; // Whether the current line has had a value written yet. private boolean firstChar = true; private final static String UNMAPPED_STRING = "-1"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;', '/** * As each segment is visited write out the appropriate line mapping. */ // Prevent the creation of unnecessary temporary stings for often // repeated values. // Append the line mapping entries. void appendLineMappings() throws IOException {', '// Start the first line. openLine(); // And close the final line. /** * Begin the entry for a new line. */ /** * End the entry for a line. */ /** * Add a new char position entry. * @param id The mapping id to record. */ /** * Mark any visited mapping as "used". */ /** * @throws IOException */ /** * @param m The mapping for the current code segment. null if the segment * is unmapped.', '* @param endCol The ending column * @throws IOException */ /** * Walk the mappings and visit each segment of the mappings, unmapped * segments are visited with a null mapping, unused mapping are not visited. */ // The last line and column written // Append the line mapping entries. // The mapping list is ordered as a pre-order traversal. The mapping // positions give us enough information to rebuild the stack and this', '// closed in the reverse order of when they encountered. while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } // Any gaps between the current line position and the start of the // current mapping belong to the parent. Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }', '// mappings in the reverse order of when they encountered. while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append("["); this.firstChar = true; } private void closeLine() throws IOException { out.append("]\\n"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(","); } out.append(id); } /**', '* Write any needed entries from the current position to the end of the * provided mapping. */ private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); // If this anything remaining in this mapping beyond the // current line and column position, write it out now. if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } /** * Write any needed entries to complete the provided mapping. */ private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); // If the previous value is null, no mapping exists. int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } /** * Write any entries needed between the current position the next position * and update the current position. */ private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, ""); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { // Nothing to do. return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;'], ['case Token.ARRAYLIT: typeNameString = "object"; break; case Token.VOID: typeNameString = "undefined"; break; case Token.NAME: // We assume here that programs don\'t change the value of the // keyword undefined to something other than the value undefined.', '*/ public class SourceMap { private final static int UNMAPPED = -1; /** * A mapping from a given position in an input source file to a given position', '/** * A unique ID for this mapping for record keeping purposes. */ int id = UNMAPPED; /** * The input source file.', '/** * Whether the mapping is actually used by the source map. */ boolean used = false; } private class MappingWriter { /** * Cache of escaped source file name. */ private String lastSourceFile = null; private String lastSourceFileEscaped = null; private int lastLine = 0; private String lastLineString = String.valueOf(0); /** * Appends the mapping to the given buffer. */ private void appendMappingTo( Mapping m, Appendable out) throws IOException { out.append("["); String sourceFile = m.sourceFile; // The source file rarely changes, so cache the escaped string. String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2) lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; out.append(escapedSourceFile); out.append(","); int line = m.originalPosition.getLineNumber(); if (line != lastLine) { lastLineString = String.valueOf(line); } String lineValue = lastLineString; out.append(lineValue); out.append(","); out.append(String.valueOf( m.originalPosition.getCharacterIndex())); if (m.originalName != null) { out.append(","); out.append(escapeString(m.originalName)); } out.append("]\\n"); } /** * Add used mappings to the supplied Appendable. */ void appendMappings(Appendable out) throws IOException { for (Mapping m : mappings) { if (m.used) { appendMappingTo(m, out); } } } } /**', 'private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } /** * Adds a mapping for the given node. Mappings must be added in order.', 'return; } // Create the new mapping. Mapping mapping = new Mapping(); mapping.sourceFile = sourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = originalName; } if (offsetPosition.getLineNumber() == 0 && offsetPosition.getCharacterIndex() == 0) { mapping.startPosition = startPosition; mapping.endPosition = endPosition; } else { // If the mapping is found on the first line, we need to offset // its character position by the number of characters found on // the *last* line of the source file to which the code is', 'mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); } mappings.add(mapping); }', 'prefixPosition = new Position(0, 0); } /** * Appends the source map in LavaBug format to the given buffer. *', '// 11) ["c.js", 1, 4] // 12) ["d.js", 3, 78, "foo"] int maxLine = prepMappings(); // Add the line character maps. out.append("/** Begin line maps. **/{ \\"file\\" : ");', '// Add the mappings themselves. out.append("/** Begin mapping definitions. **/\\n"); (new MappingWriter()).appendMappings(out); } /** * Assigns sequential ids to used mappings, and returns the last line mapped. */ private int prepMappings() throws IOException { // Mark any unused mappings. (new MappingTraversal()).traverse(new UsedMappingCheck()); // Renumber used mappings and keep track of the last line. int id = 0; int maxLine = 0; for (Mapping m : mappings) { if (m.used) { m.id = id++; int endPositionLine = m.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } } // Adjust for the prefix. return maxLine + prefixPosition.getLineNumber(); } private class LineMapper implements MappingVisitor { // The destination. private final Appendable out; // Whether the current line has had a value written yet. private boolean firstChar = true; private final static String UNMAPPED_STRING = "-1"; private int lastId = UNMAPPED; private String lastIdString = UNMAPPED_STRING; LineMapper(Appendable out) { this.out = out;', '/** * As each segment is visited write out the appropriate line mapping. */ public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { int id = (m != null) ? m.id : UNMAPPED; if (lastId != id) { // Prevent the creation of unnecessary temporary stings for often // repeated values. lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); lastId = id; } String idString = lastIdString; for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } } // Append the line mapping entries. void appendLineMappings() throws IOException {', '// Start the first line. openLine(); (new MappingTraversal()).traverse(this); // And close the final line. closeLine(); } /** * Begin the entry for a new line. */ private void openLine() throws IOException { if (out != null) { out.append("["); this.firstChar = true; } } /** * End the entry for a line. */ private void closeLine() throws IOException { if (out != null) { out.append("]\\n"); } } /** * Add a new char position entry. * @param id The mapping id to record. */ private void addCharEntry(String id) throws IOException { if (out != null) { if (firstChar) { firstChar = false; } else { out.append(","); } out.append(id); } } } /** * Mark any visited mapping as "used". */ private class UsedMappingCheck implements MappingVisitor { /** * @throws IOException */ @Override public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { if (m != null) { m.used = true; } } } private interface MappingVisitor { /** * @param m The mapping for the current code segment. null if the segment * is unmapped.', '* @param endCol The ending column * @throws IOException */ void visit(Mapping m, int line, int col, int endLine, int endCol) throws IOException; } /** * Walk the mappings and visit each segment of the mappings, unmapped * segments are visited with a null mapping, unused mapping are not visited. */ private class MappingTraversal { // The last line and column written private int line; private int col; MappingTraversal() { } // Append the line mapping entries. void traverse(MappingVisitor v) throws IOException { Preconditions.checkState(!mappings.isEmpty()); // The mapping list is ordered as a pre-order traversal. The mapping // positions give us enough information to rebuild the stack and this', '// closed in the reverse order of when they encountered. while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); maybeVisit(v, previous); } // Any gaps between the current line position and the start of the // current mapping belong to the parent. Mapping parent = stack.peek(); maybeVisitParent(v, parent, m); stack.push(m); }', '// mappings in the reverse order of when they encountered. while (!stack.isEmpty()) { Mapping m = stack.pop(); maybeVisit(v, m); } } /**', '* Write any needed entries from the current position to the end of the * provided mapping. */ private void maybeVisit(MappingVisitor v, Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); // If this anything remaining in this mapping beyond the // current line and column position, write it out now. if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, m, nextLine, nextCol); } } /** * Write any needed entries to complete the provided mapping. */ private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m) throws IOException { int nextLine = getAdjustedLine(m.startPosition); int nextCol = getAdjustedCol(m.startPosition); // If the previous value is null, no mapping exists. Preconditions.checkState(line < nextLine || col <= nextCol); if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, parent, nextLine, nextCol); } } /** * Write any entries needed between the current position the next position * and update the current position. */ private void visit(MappingVisitor v, Mapping m, int nextLine, int nextCol) throws IOException { Preconditions.checkState(line <= nextLine); Preconditions.checkState(line < nextLine || col < nextCol); if (line == nextLine && col == nextCol) { // Nothing to do. Preconditions.checkState(false); return; } v.visit(m, line, col, nextLine, nextCol); line = nextLine; col = nextCol;'], ['', '', 'int id;', 'void appendTo(Appendable out) throws IOException { out.append(sourceFile); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(originalName); out.append("]");', 'private String lastSourceFile = null; private String lastSourceFileEscaped = null;', 'String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, "s1 != s2" not "!s1.equals(s2)" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalName = escapeString(originalName);', '', 'private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }', 'int maxLine = findLastLine();', 'for (Mapping mapping : mappings) { mapping.appendTo(out); out.append("\\n"); } private class LineMapper { private int line; private int col; private final static int UNMAPPED = -1;', '', '', '', 'writeClosedMapping(previous); writeCharsBetween(parent, m);', 'writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append("["); this.firstChar = true; } private void closeLine() throws IOException { out.append("]\\n"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(","); out.append(id);', 'private void writeClosedMapping(Mapping m) throws IOException { writeCharsUpTo(nextLine, nextCol, m.id); private void writeCharsBetween(Mapping prev, Mapping next) int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); private void writeCharsUpTo( int nextLine, int nextCol, int id) Preconditions.checkState(line <= nextLine, ""); Preconditions.checkState(line < nextLine || col <= nextCol); String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }'], ['case Token.VOID: typeNameString = "undefined"; break;', 'private final static int UNMAPPED = -1;', 'int id = UNMAPPED;', 'boolean used = false; } private class MappingWriter { private String lastSourceFile = null; private String lastSourceFileEscaped = null; private int lastLine = 0; private String lastLineString = String.valueOf(0); private void appendMappingTo( Mapping m, Appendable out) throws IOException { String sourceFile = m.sourceFile; String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2) lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; out.append(escapedSourceFile); int line = m.originalPosition.getLineNumber(); if (line != lastLine) { lastLineString = String.valueOf(line); } String lineValue = lastLineString; out.append(lineValue); out.append(String.valueOf( m.originalPosition.getCharacterIndex())); if (m.originalName != null) { out.append(escapeString(m.originalName)); out.append("]\\n"); void appendMappings(Appendable out) throws IOException { for (Mapping m : mappings) { if (m.used) { appendMappingTo(m, out); } } }', '', 'mapping.sourceFile = sourceFile; mapping.originalName = originalName; if (offsetPosition.getLineNumber() == 0 && offsetPosition.getCharacterIndex() == 0) { mapping.startPosition = startPosition; mapping.endPosition = endPosition; } else {', '}', '', 'int maxLine = prepMappings();', '(new MappingWriter()).appendMappings(out); private int prepMappings() throws IOException { (new MappingTraversal()).traverse(new UsedMappingCheck()); int id = 0; int maxLine = 0; for (Mapping m : mappings) { if (m.used) { m.id = id++; int endPositionLine = m.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } } return maxLine + prefixPosition.getLineNumber(); } private class LineMapper implements MappingVisitor { private int lastId = UNMAPPED; private String lastIdString = UNMAPPED_STRING;', 'public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { int id = (m != null) ? m.id : UNMAPPED; if (lastId != id) { lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); lastId = id; } String idString = lastIdString; for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } }', '(new MappingTraversal()).traverse(this); closeLine(); } private void openLine() throws IOException { if (out != null) { out.append("["); this.firstChar = true; } } private void closeLine() throws IOException { if (out != null) { out.append("]\\n"); } } private void addCharEntry(String id) throws IOException { if (out != null) { if (firstChar) { firstChar = false; } else { out.append(","); } out.append(id); } } } private class UsedMappingCheck implements MappingVisitor { @Override public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { if (m != null) { m.used = true; } } } private interface MappingVisitor {', 'void visit(Mapping m, int line, int col, int endLine, int endCol) throws IOException; } private class MappingTraversal { private int line; private int col; MappingTraversal() { } void traverse(MappingVisitor v) throws IOException { Preconditions.checkState(!mappings.isEmpty());', 'maybeVisit(v, previous); maybeVisitParent(v, parent, m);', 'maybeVisit(v, m);', 'private void maybeVisit(MappingVisitor v, Mapping m) throws IOException { visit(v, m, nextLine, nextCol); private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m) int nextLine = getAdjustedLine(m.startPosition); int nextCol = getAdjustedCol(m.startPosition); Preconditions.checkState(line < nextLine || col <= nextCol); if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, parent, nextLine, nextCol); } private void visit(MappingVisitor v, Mapping m, int nextLine, int nextCol) Preconditions.checkState(line <= nextLine); Preconditions.checkState(line < nextLine || col < nextCol); Preconditions.checkState(false); v.visit(m, line, col, nextLine, nextCol);'], 'a/src/com/google/javascript/jscomp/SourceMap.java', 'b/src/com/google/javascript/jscomp/SourceMap.java']
['Closure-149', 7, 7, 7, 7, ['options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) {', 'Result result; setRunOptions(options); if (inputCharset == Charsets.UTF_8) { options.outputCharset = Charsets.US_ASCII; } else { options.outputCharset = inputCharset; } boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) {', '* be a supported charset. * @throws FlagUsageException if flag is not a valid Charset name. */ protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {', '} options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }', 'builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); Charset charset = options.outputCharset; builder.setOutputCharset(charset); return builder.build();', "* Charset to use when generating code. If null, then output ASCII. * This needs to be a string because CompilerOptions is serializable. */ public Charset outputCharset; /** * Whether the named objects types included 'undefined' by default.", '/** * Sets the output charset by name. */ /** * Whether to include "undefined" in the default types.'], ['options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); options.outputCharset = getOutputCharset(); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) {', 'Result result; setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) {', '* be a supported charset. * @throws FlagUsageException if flag is not a valid Charset name. */ private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + " is not a valid charset name."); } return config.charset; } return "US-ASCII"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {', '} options.closurePass = flags.process_closure_primitives; return options; }', 'builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null; builder.setOutputCharset(charset); return builder.build();', "* Charset to use when generating code. If null, then output ASCII. * This needs to be a string because CompilerOptions is serializable. */ String outputCharset; /** * Whether the named objects types included 'undefined' by default.", '/** * Sets the output charset by name. */ public void setOutputCharset(String charsetName) { this.outputCharset = charsetName; } /** * Whether to include "undefined" in the default types.'], ['', 'if (inputCharset == Charsets.UTF_8) { options.outputCharset = Charsets.US_ASCII; } else { options.outputCharset = inputCharset; }', '', 'initOptionsFromFlags(options);', 'Charset charset = options.outputCharset;', 'public Charset outputCharset;', ''], ['options.outputCharset = getOutputCharset();', '', 'private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + " is not a valid charset name."); } return config.charset; } return "US-ASCII"; }', '', 'Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;', 'String outputCharset;', 'public void setOutputCharset(String charsetName) { this.outputCharset = charsetName; }'], 'a/src/com/google/javascript/jscomp/CompilerOptions.java', 'b/src/com/google/javascript/jscomp/CompilerOptions.java']
['Closure-150', 1, 1, 1, 1, ['return; } attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } } /** Handle bleeding functions and function parameters. */'], ['return; } super.visit(t, n, parent); } /** Handle bleeding functions and function parameters. */'], ['attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; }'], ['super.visit(t, n, parent);'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-151', 3, 3, 3, 3, ['+ "a manifest for each module.") private String output_manifest = ""; // Our own option parser to be backwards-compatible. // It needs to be public because of the crazy reflection that args4j does.', ' private final Flags flags = new Flags(); private boolean isConfigValid = false;', 'isConfigValid = false; } if (!isConfigValid || flags.display_help) { isConfigValid = false;'], ['+ "a manifest for each module.") private String output_manifest = ""; @Option(name = "--version", usage = "Prints the compiler version to stderr.") private boolean version = false; // Our own option parser to be backwards-compatible. // It needs to be public because of the crazy reflection that args4j does.', ' private final Flags flags = new Flags(); private static final String configResource = "com.google.javascript.jscomp.parsing.ParserConfig"; private boolean isConfigValid = false;', 'isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( "Closure Compiler (http://code.google.com/p/closure/compiler)\\n" + "Version: " + config.getString("compiler.version") + "\\n" + "Built on: " + config.getString("compiler.date")); err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false;'], ['', '', ''], ['@Option(name = "--version", usage = "Prints the compiler version to stderr.") private boolean version = false;', 'private static final String configResource = "com.google.javascript.jscomp.parsing.ParserConfig";', 'if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( "Closure Compiler (http://code.google.com/p/closure/compiler)\\n" + "Version: " + config.getString("compiler.version") + "\\n" + "Built on: " + config.getString("compiler.date")); err.flush(); }'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-152', 1, 1, 1, 1, ["// Warning about typeOfThis if it doesn't resolve to an ObjectType // is handled further upstream. // TODO(nicksantos): Handle this correctly if we have a UnionType. typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces ="], ["// Warning about typeOfThis if it doesn't resolve to an ObjectType // is handled further upstream. // TODO(nicksantos): Handle this correctly if we have a UnionType. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces ="], ['typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);'], ['JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-153', 13, 13, 13, 13, ['private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { /** * Remove duplicate VAR declarations encountered discovered during', '*/ @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); Var v = s.getVar(name); // We allow variables to be duplicate declared if one // declaration appears in source and the other in externs. // This deals with issues where a browser built-in is declared // in one browser but not in another. // If name is "arguments", Var maybe null. if (v != null && v.getParentNode().getType() == Token.CATCH) {', 'name); compiler.report( JSError.make( NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name)); } else if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) {', '} else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } }', 'import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.JSType; /**', '// been declared in the outer scope. String fnName = fnNameNode.getString(); if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) { declareVar(fnName, fnNameNode, n, null, null, n); } // Args: Declare function variables', 'for (Node a = args.getFirstChild(); a != null; a = a.getNext()) { Preconditions.checkState(a.getType() == Token.NAME); declareVar(a.getString(), a, args, n, null, n); } // Body', 'for (Node child = n.getFirstChild(); child != null;) { Node next = child.getNext(); Preconditions.checkState(child.getType() == Token.NAME); String name = child.getString(); declareVar(name, child, n, parent, null, n); child = next; } return;', "// This is invalid, but allow it so the checks can catch it. return; } declareVar(fnName, n.getFirstChild(), n, parent, null, n); return; // should not examine function's children case Token.CATCH:", 'final Node var = n.getFirstChild(); final Node block = var.getNext(); declareVar(var.getString(), var, n, parent, null, n); scanVars(block, n); return; // only one child to scan', '*/ interface RedeclarationHandler { void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber); } /**', "*/ private class DefaultRedeclarationHandler implements RedeclarationHandler { public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { // Don't allow multiple variables to be declared at the top level scope if (scope.isGlobal()) {", "* @param n The node corresponding to the variable name. * @param declaredType The variable's type, according to JSDoc */ private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) { if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) { redeclarationHandler.onRedeclaration( scope, name, n, parent, gramps, nodeWithLineNumber); } else { scope.declare(name, n, declaredType, compiler.getInput(sourceName)); } } }"], ['private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { private Set<Var> hasOkDuplicateDeclaration = Sets.newHashSet(); /** * Remove duplicate VAR declarations encountered discovered during', '*/ @Override public void onRedeclaration( Scope s, String name, Node n, CompilerInput input) { Preconditions.checkState(n.getType() == Token.NAME); Node parent = n.getParent(); Var v = s.getVar(name); if (v != null && s.isGlobal()) { // We allow variables to be duplicate declared if one // declaration appears in source and the other in externs. // This deals with issues where a browser built-in is declared // in one browser but not in another. if (v.isExtern() && !input.isExtern()) { if (hasOkDuplicateDeclaration.add(v)) { return; } } } // If name is "arguments", Var maybe null. if (v != null && v.getParentNode().getType() == Token.CATCH) {', 'name); compiler.report( JSError.make( input.getName(), n, CATCH_BLOCK_VAR_ERROR, name)); } else if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) {', '} else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, parent.getParent()); } }', 'import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; /**', '// been declared in the outer scope. String fnName = fnNameNode.getString(); if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) { declareVar(fnNameNode); } // Args: Declare function variables', 'for (Node a = args.getFirstChild(); a != null; a = a.getNext()) { Preconditions.checkState(a.getType() == Token.NAME); declareVar(a); } // Body', 'for (Node child = n.getFirstChild(); child != null;) { Node next = child.getNext(); declareVar(child); child = next; } return;', "// This is invalid, but allow it so the checks can catch it. return; } declareVar(n.getFirstChild()); return; // should not examine function's children case Token.CATCH:", 'final Node var = n.getFirstChild(); final Node block = var.getNext(); declareVar(var); scanVars(block, n); return; // only one child to scan', '*/ interface RedeclarationHandler { void onRedeclaration( Scope s, String name, Node n, CompilerInput input); } /**', "*/ private class DefaultRedeclarationHandler implements RedeclarationHandler { public void onRedeclaration( Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent(); // Don't allow multiple variables to be declared at the top level scope if (scope.isGlobal()) {", "* @param n The node corresponding to the variable name. * @param declaredType The variable's type, according to JSDoc */ private void declareVar(Node n) { Preconditions.checkState(n.getType() == Token.NAME); CompilerInput input = compiler.getInput(sourceName); String name = n.getString(); if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) { redeclarationHandler.onRedeclaration( scope, name, n, input); } else { scope.declare(name, n, null, input); } } }"], ['', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {', 'NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,', 'replaceVarWithAssignment(n, parent, gramps);', 'import com.google.javascript.rhino.jstype.JSType;', 'declareVar(fnName, fnNameNode, n, null, null, n);', 'declareVar(a.getString(), a, args, n, null, n);', 'Preconditions.checkState(child.getType() == Token.NAME); String name = child.getString(); declareVar(name, child, n, parent, null, n);', 'declareVar(fnName, n.getFirstChild(), n, parent, null, n);', 'declareVar(var.getString(), var, n, parent, null, n);', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {', 'private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) { scope, name, n, parent, gramps, nodeWithLineNumber); scope.declare(name, n, declaredType, compiler.getInput(sourceName));'], ['private Set<Var> hasOkDuplicateDeclaration = Sets.newHashSet();', 'Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent(); if (v != null && s.isGlobal()) { if (v.isExtern() && !input.isExtern()) { if (hasOkDuplicateDeclaration.add(v)) { return; } } }', 'input.getName(), n,', 'replaceVarWithAssignment(n, parent, parent.getParent());', '', 'declareVar(fnNameNode);', 'declareVar(a);', 'declareVar(child);', 'declareVar(n.getFirstChild());', 'declareVar(var);', 'Scope s, String name, Node n, CompilerInput input);', 'Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent();', 'private void declareVar(Node n) { Preconditions.checkState(n.getType() == Token.NAME); CompilerInput input = compiler.getInput(sourceName); String name = n.getString(); scope, name, n, input); scope.declare(name, n, null, input);'], 'a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java', 'b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java']
['Closure-154', 6, 6, 6, 6, ['"original: {2}\\n" + "override: {3}"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}"); static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( "JSC_UNKNOWN_OVERRIDE",', 'HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE,', 'HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } if (interfaceHasProperty) { JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString())); } } } }', '"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED", "property {0} on interface {1} is not implemented by type {2}"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST,', 'MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler;', 'prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); // Implemented, but not correctly typed } }'], ['"original: {2}\\n" + "override: {3}"); static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( "JSC_UNKNOWN_OVERRIDE",', 'HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE,', 'HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } } }', '"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED", "property {0} on interface {1} is not implemented by type {2}"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST,', 'MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler;', 'prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); } else { JSType found = instance.getPropertyType(prop); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { // Implemented, but not correctly typed if (shouldReport) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())); } registerMismatch(found, required); } } }'], ['static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}");', 'HIDDEN_INTERFACE_PROPERTY_MISMATCH,', 'if (interfaceHasProperty) { JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString())); } }', '', 'INTERFACE_METHOD_NOT_IMPLEMENTED);', ''], ['', '', '', 'static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}");', 'INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH);', '} else { JSType found = instance.getPropertyType(prop); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { if (shouldReport) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())); } registerMismatch(found, required); }'], 'a/src/com/google/javascript/jscomp/TypeValidator.java', 'b/src/com/google/javascript/jscomp/TypeValidator.java']
['Closure-155', 7, 7, 7, 7, ['private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next();', '// inlining heuristics. See InlineConstantsTest. continue; } else { inlineNonConstants(v, referenceInfo); } } } // Any reference that is not a read of the arguments property // consider a escape of the arguments object. private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference();', "// inline an alias of it. (If the variable was inlined, then the // reference data is out of sync. We're better off just waiting for // the next pass.) if ( !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references;", '*/ public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString()); if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek()));', '/** Whether this is a bottom scope for the purposes of type inference. */ private final boolean isBottom; /** Stores info about a variable */ public static class Var implements StaticSlot<JSType> {', '* scope. */ // TODO(johnlenz): Include this the list of Vars for the scope. // TODO(johnlenz): provide the type of "Arguments". /** * Creates a Scope given the parent Scope and the root node of the scope.', '/** * Get a unique VAR object to represents "arguments" within this scope */ /** * Returns true if a variable is declared.'], ['private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap); for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next();', '// inlining heuristics. See InlineConstantsTest. continue; } else { inlineNonConstants(v, referenceInfo, maybeModifiedArguments); } } } private boolean maybeEscapedOrModifiedArguments( Scope scope, Map<Var, ReferenceCollection> referenceMap) { if (scope.isLocal()) { Var arguments = scope.getArgumentsVar(); ReferenceCollection refs = referenceMap.get(arguments); if (refs != null && !refs.references.isEmpty()) { for (Reference ref : refs.references) { Node refNode = ref.getNameNode(); Node refParent = ref.getParent(); // Any reference that is not a read of the arguments property // consider a escape of the arguments object. if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) { return true; } } } } return false; } private boolean isLValue(Node n) { Node parent = n.getParent(); return (parent.getType() == Token.INC || parent.getType() == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); } private void inlineNonConstants( Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference();', "// inline an alias of it. (If the variable was inlined, then the // reference data is out of sync. We're better off just waiting for // the next pass.) if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references;", '*/ public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v; if (n.getString().equals("arguments")) { v = t.getScope().getArgumentsVar(); } else { v = t.getScope().getVar(n.getString()); } if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek()));', '/** Whether this is a bottom scope for the purposes of type inference. */ private final boolean isBottom; private Var arguments; /** Stores info about a variable */ public static class Var implements StaticSlot<JSType> {', '* scope. */ // TODO(johnlenz): Include this the list of Vars for the scope. public static class Arguments extends Var { Arguments(Scope scope) { super( false, // no inferred "arguments", // always arguments null, // no declaration node // TODO(johnlenz): provide the type of "Arguments". null, // no type info scope, -1, // no variable index null, // input, false, // not a define null // no jsdoc ); } @Override public boolean equals(Object other) { if (!(other instanceof Arguments)) { return false; } Arguments otherVar = (Arguments) other; return otherVar.scope.getRootNode() == scope.getRootNode(); } @Override public int hashCode() { return System.identityHashCode(this); } } /** * Creates a Scope given the parent Scope and the root node of the scope.', '/** * Get a unique VAR object to represents "arguments" within this scope */ public Var getArgumentsVar() { if (arguments == null) { arguments = new Arguments(this); } return arguments; } /** * Returns true if a variable is declared.'], ['', 'inlineNonConstants(v, referenceInfo); Var v, ReferenceCollection referenceInfo) {', 'if (', 'Var v = t.getScope().getVar(n.getString());', '', '', ''], ['boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);', 'inlineNonConstants(v, referenceInfo, maybeModifiedArguments); private boolean maybeEscapedOrModifiedArguments( Scope scope, Map<Var, ReferenceCollection> referenceMap) { if (scope.isLocal()) { Var arguments = scope.getArgumentsVar(); ReferenceCollection refs = referenceMap.get(arguments); if (refs != null && !refs.references.isEmpty()) { for (Reference ref : refs.references) { Node refNode = ref.getNameNode(); Node refParent = ref.getParent(); if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) { return true; } } } } return false; } private boolean isLValue(Node n) { Node parent = n.getParent(); return (parent.getType() == Token.INC || parent.getType() == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); } Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {', 'if (!maybeModifiedArguments &&', 'Var v; if (n.getString().equals("arguments")) { v = t.getScope().getArgumentsVar(); } else { v = t.getScope().getVar(n.getString()); }', 'private Var arguments;', 'public static class Arguments extends Var { Arguments(Scope scope) { super( false, // no inferred "arguments", // always arguments null, // no declaration node null, // no type info scope, -1, // no variable index null, // input, false, // not a define null // no jsdoc ); } @Override public boolean equals(Object other) { if (!(other instanceof Arguments)) { return false; } Arguments otherVar = (Arguments) other; return otherVar.scope.getRootNode() == scope.getRootNode(); } @Override public int hashCode() { return System.identityHashCode(this); } }', 'public Var getArgumentsVar() { if (arguments == null) { arguments = new Arguments(this); } return arguments; }'], 'a/src/com/google/javascript/jscomp/Scope.java', 'b/src/com/google/javascript/jscomp/Scope.java']
['Closure-156', 7, 7, 7, 7, ['boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); // Handle this name first so that nested object literals get unrolled. if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) {', "* this name. (This is mostly passed for convenience; it's equivalent to * n.canCollapseChildNames()). */ private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { // Some names do not have declarations, because they // are only defined in local scopes.", ' switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } }', '* @param alias The flattened name for {@code n} (e.g. "a", "a$b$c") */ private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { // NOTE: It\'s important that we don\'t add additional nodes // (e.g. a var node before the exprstmt) because the exprstmt might be // the child of an if statement that\'s not inside a block).', 'insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) {', '* * @param n An object representing a global name (e.g. "a") */ private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString();', '* * @param n An object representing a global name (e.g. "a") */ private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString();'], ['boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); // Handle this name first so that nested object literals get unrolled. if (n.canCollapse()) { updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames); } if (n.props != null) {', "* this name. (This is mostly passed for convenience; it's equivalent to * n.canCollapseChildNames()). */ private void updateObjLitOrFunctionDeclaration( Name n, String alias, boolean canCollapseChildNames) { if (n.declaration == null) { // Some names do not have declarations, because they // are only defined in local scopes.", ' switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode( n, alias, canCollapseChildNames); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames); break; } }', '* @param alias The flattened name for {@code n} (e.g. "a", "a$b$c") */ private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias, boolean canCollapseChildNames) { // NOTE: It\'s important that we don\'t add additional nodes // (e.g. a var node before the exprstmt) because the exprstmt might be // the child of an if statement that\'s not inside a block).', 'insertedVarNode = true; } if (canCollapseChildNames) { if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); } if (insertedVarNode) { if (!varNode.hasChildren()) {', '* * @param n An object representing a global name (e.g. "a") */ private void updateObjLitOrFunctionDeclarationAtVarNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; } Ref ref = n.declaration; String name = ref.node.getString();', '* * @param n An object representing a global name (e.g. "a") */ private void updateFunctionDeclarationAtFunctionNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; } Ref ref = n.declaration; String fnName = ref.node.getString();'], ['if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias);', 'private void updateObjLitOrFunctionDeclaration(Name n, String alias) {', 'updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); updateObjLitOrFunctionDeclarationAtVarNode(n); updateFunctionDeclarationAtFunctionNode(n);', 'Name n, String alias) {', 'if (isObjLit) { addStubsForUndeclaredProperties(n, alias, varParent, varNode);', 'private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {', 'private void updateFunctionDeclarationAtFunctionNode(Name n) {'], ['if (n.canCollapse()) { updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);', 'private void updateObjLitOrFunctionDeclaration( Name n, String alias, boolean canCollapseChildNames) {', 'updateObjLitOrFunctionDeclarationAtAssignNode( n, alias, canCollapseChildNames); updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames); updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);', 'Name n, String alias, boolean canCollapseChildNames) {', 'if (canCollapseChildNames) { if (isObjLit) { } addStubsForUndeclaredProperties(n, alias, varParent, varNode);', 'private void updateObjLitOrFunctionDeclarationAtVarNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; }', 'private void updateFunctionDeclarationAtFunctionNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; }'], 'a/src/com/google/javascript/jscomp/CollapseProperties.java', 'b/src/com/google/javascript/jscomp/CollapseProperties.java']
['Closure-157', 7, 7, 7, 7, ['Node body = fn.getLastChild(); // Add the property name. if (TokenStream.isJSIdentifier(name) && // do not encode literally any non-literal characters that were // unicode escaped. NodeUtil.isLatin(name)) { add(name); } else { // Determine if the string is a simple number. add(jsString(n.getString(), outputCharsetEncoder)); } add(parameters);', 'if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { // Object literal property names don\'t have to be quoted if they // are not JavaScript keywords if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // do not encode literally any non-literal characters that // were unicode escaped. NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { // Determine if the string is a simple number. addExpr(c, 1); } add(":"); addExpr(c.getFirstChild(), 1);', 'cc.endSourceMapping(n); } /** * @return Whether the name is an indirect eval.', 'child != null; child = child.getNext()) { if (child.getType() != Token.NUMBER) { markObjLitPropertyCandidate(child, t.getInput()); } }', ' for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { if (key.getType() != Token.NUMBER) { // May be STRING, GET, or SET markPrototypePropertyCandidate(key, input); }', 'return irNode; } // Return "1" instead of "1.0" private void setSourceInfo(Node irNode, AstNode node) { // If we have a named function, set the position to that of the name.', 'Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else { ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); } } return ret; }'], ['Node body = fn.getLastChild(); // Add the property name. if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // do not encode literally any non-literal characters that were // unicode escaped. NodeUtil.isLatin(name)) { add(name); } else { // Determine if the string is a simple number. double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { add(jsString(n.getString(), outputCharsetEncoder)); } } add(parameters);', 'if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { Preconditions.checkState(c.getType() == Token.STRING); String key = c.getString(); // Object literal property names don\'t have to be quoted if they // are not JavaScript keywords if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && // do not encode literally any non-literal characters that // were unicode escaped. NodeUtil.isLatin(key)) { add(key); } else { // Determine if the string is a simple number. double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1); } } add(":"); addExpr(c.getFirstChild(), 1);', "cc.endSourceMapping(n); } static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0; } static double getSimpleNumber(String s) { if (isSimpleNumber(s)) { long l = Long.parseLong(s); if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) { return l; } } return Double.NaN; } /** * @return Whether the name is an indirect eval.", 'child != null; child = child.getNext()) { if (TokenStream.isJSIdentifier(child.getString())) { markObjLitPropertyCandidate(child, t.getInput()); } }', ' for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { if (TokenStream.isJSIdentifier(key.getString())) { // May be STRING, GET, or SET markPrototypePropertyCandidate(key, input); }', 'return irNode; } private Node transformNumberAsString(NumberLiteral literalNode) { JSDocInfo jsDocInfo = handleJsDoc(literalNode); Node irNode = newStringNode(getStringValue(literalNode.getNumber())); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; } private static String getStringValue(double value) { long longValue = (long) value; // Return "1" instead of "1.0" if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } } private void setSourceInfo(Node irNode, AstNode node) { // If we have a named function, set the position to that of the name.', 'Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true); } else { ret = transform(n); ret.putBooleanProp(Node.QUOTED_PROP, true); } Preconditions.checkState(ret.getType() == Token.STRING); return ret; }'], ['if (TokenStream.isJSIdentifier(name) && add(jsString(n.getString(), outputCharsetEncoder));', 'if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); addExpr(c, 1);', '', 'if (child.getType() != Token.NUMBER) {', 'if (key.getType() != Token.NUMBER) {', '', 'Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { }'], ['if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { add(jsString(n.getString(), outputCharsetEncoder)); }', 'Preconditions.checkState(c.getType() == Token.STRING); String key = c.getString(); if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { add(key); double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1); }', "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0; } static double getSimpleNumber(String s) { if (isSimpleNumber(s)) { long l = Long.parseLong(s); if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) { return l; } } return Double.NaN; }", 'if (TokenStream.isJSIdentifier(child.getString())) {', 'if (TokenStream.isJSIdentifier(key.getString())) {', 'private Node transformNumberAsString(NumberLiteral literalNode) { JSDocInfo jsDocInfo = handleJsDoc(literalNode); Node irNode = newStringNode(getStringValue(literalNode.getNumber())); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; } private static String getStringValue(double value) { long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } }', '} else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true); Preconditions.checkState(ret.getType() == Token.STRING);'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-158', 12, 12, 12, 12, ['throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false);', 'return this; } private final List<String> jscompError = Lists.newArrayList(); /** * Add warning guards. */ CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; }', '* A little helper class to make it easier to collect warning types * from --jscomp_error, --jscomp_warning, and --jscomp_off. */ // The entries, in the order that they were added. }', 'import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser;', '// I don\'t really care about unchecked warnings in this class. @SuppressWarnings("unchecked") private static class Flags { @Option(name = "--help", handler = BooleanOptionHandler.class,', 'private String create_source_map = ""; @Option(name = "--jscomp_error", usage = "Make the named class of warnings an error. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = "--jscomp_warning", usage = "Make the named class of warnings a normal warning. " + "Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = "--jscomp_off", usage = "Turn off the named class of warnings. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList();', ' // Our own parser for warning guards that preserves the original order // of the flags. } /**', 'List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); // Currently we are not supporting this (prevent direct/indirect loops)', 'List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {}));', '.setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)', 'import com.google.common.collect.ImmutableMap; import com.google.common.collect.Maps; import java.util.List; import java.util.Map; /**', '/** * Adds warning levels by name. */ void setWarningLevels(CompilerOptions options, List<String> diagnosticGroups, CheckLevel level) { for (String name : diagnosticGroups) { DiagnosticGroup group = forName(name); Preconditions.checkNotNull(group, "No warning class for name: " + name); options.setWarningLevel(group, level); } } }'], ['throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); if (config.warningGuards != null) { for (WarningGuardSpec.Entry entry : config.warningGuards.entries) { diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level); } } createDefineOrTweakReplacements(config.define, options, false);', 'return this; } private WarningGuardSpec warningGuards = null; /** * Add warning guards. */ CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) { this.warningGuards = spec; return this; }', '* A little helper class to make it easier to collect warning types * from --jscomp_error, --jscomp_warning, and --jscomp_off. */ protected static class WarningGuardSpec { private static class Entry { private final CheckLevel level; private final String groupName; private Entry(CheckLevel level, String groupName) { this.level = level; this.groupName = groupName; } } // The entries, in the order that they were added. private final List<Entry> entries = Lists.newArrayList(); protected void add(CheckLevel level, String groupName) { entries.add(new Entry(level, groupName)); } protected void clear() { entries.clear(); } } }', 'import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser;', '// I don\'t really care about unchecked warnings in this class. @SuppressWarnings("unchecked") private static class Flags { private static final WarningGuardSpec warningGuardSpec = new WarningGuardSpec(); @Option(name = "--help", handler = BooleanOptionHandler.class,', 'private String create_source_map = ""; @Option(name = "--jscomp_error", handler = WarningGuardErrorOptionHandler.class, usage = "Make the named class of warnings an error. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = "--jscomp_warning", handler = WarningGuardWarningOptionHandler.class, usage = "Make the named class of warnings a normal warning. " + "Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = "--jscomp_off", handler = WarningGuardOffOptionHandler.class, usage = "Turn off the named class of warnings. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList();', ' // Our own parser for warning guards that preserves the original order // of the flags. public static class WarningGuardErrorOptionHandler extends StringOptionHandler { public WarningGuardErrorOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR)); } } public static class WarningGuardWarningOptionHandler extends StringOptionHandler { public WarningGuardWarningOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.WARNING)); } } public static class WarningGuardOffOptionHandler extends StringOptionHandler { public WarningGuardOffOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF)); } } private static class WarningGuardSetter implements Setter { private final Setter proxy; private final CheckLevel level; private WarningGuardSetter(Setter proxy, CheckLevel level) { this.proxy = proxy; this.level = level; } @Override public boolean isMultiValued() { return proxy.isMultiValued(); } @Override public Class getType() { return proxy.getType(); } @Override public void addValue(Object value) throws CmdLineException { proxy.addValue((String) value); warningGuardSpec.add(level, (String) value); } } } /**', 'List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); Flags.warningGuardSpec.clear(); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); // Currently we are not supporting this (prevent direct/indirect loops)', 'List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); Flags.warningGuardSpec.clear(); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {}));', '.setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setWarningGuardSpec(Flags.warningGuardSpec) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)', 'import com.google.common.collect.ImmutableMap; import com.google.common.collect.Maps; import java.util.Map; /**', '/** * Adds warning levels by name. */ void setWarningLevel(CompilerOptions options, String name, CheckLevel level) { DiagnosticGroup group = forName(name); Preconditions.checkNotNull(group, "No warning class for name: " + name); options.setWarningLevel(group, level); } }'], ['diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF);', 'private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff);', '', '', '', '', '', '', '', '.setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off)', 'import java.util.List;', 'void setWarningLevels(CompilerOptions options, List<String> diagnosticGroups, CheckLevel level) { for (String name : diagnosticGroups) { }'], ['if (config.warningGuards != null) { for (WarningGuardSpec.Entry entry : config.warningGuards.entries) { diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level); } }', 'private WarningGuardSpec warningGuards = null; CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) { this.warningGuards = spec;', 'protected static class WarningGuardSpec { private static class Entry { private final CheckLevel level; private final String groupName; private Entry(CheckLevel level, String groupName) { this.level = level; this.groupName = groupName; } } private final List<Entry> entries = Lists.newArrayList(); protected void add(CheckLevel level, String groupName) { entries.add(new Entry(level, groupName)); } protected void clear() { entries.clear(); } }', 'import com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec;', 'private static final WarningGuardSpec warningGuardSpec = new WarningGuardSpec();', 'handler = WarningGuardErrorOptionHandler.class, handler = WarningGuardWarningOptionHandler.class, handler = WarningGuardOffOptionHandler.class,', 'public static class WarningGuardErrorOptionHandler extends StringOptionHandler { public WarningGuardErrorOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR)); } } public static class WarningGuardWarningOptionHandler extends StringOptionHandler { public WarningGuardWarningOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.WARNING)); } } public static class WarningGuardOffOptionHandler extends StringOptionHandler { public WarningGuardOffOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF)); } } private static class WarningGuardSetter implements Setter { private final Setter proxy; private final CheckLevel level; private WarningGuardSetter(Setter proxy, CheckLevel level) { this.proxy = proxy; this.level = level; } @Override public boolean isMultiValued() { return proxy.isMultiValued(); } @Override public Class getType() { return proxy.getType(); } @Override public void addValue(Object value) throws CmdLineException { proxy.addValue((String) value); warningGuardSpec.add(level, (String) value); } }', 'Flags.warningGuardSpec.clear();', 'Flags.warningGuardSpec.clear();', '.setWarningGuardSpec(Flags.warningGuardSpec)', '', 'void setWarningLevel(CompilerOptions options, String name, CheckLevel level) {'], 'a/src/com/google/javascript/jscomp/DiagnosticGroups.java', 'b/src/com/google/javascript/jscomp/DiagnosticGroups.java']
['Closure-159', 1, 1, 1, 1, ['Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); // For each referenced function, add a new reference if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); } }'], ['Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); // For each referenced function, add a new reference if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString()); } }'], ['if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());'], ['if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString());'], 'a/src/com/google/javascript/jscomp/InlineFunctions.java', 'b/src/com/google/javascript/jscomp/InlineFunctions.java']
['Closure-160', 2, 2, 2, 2, ["getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also", '// about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && (warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = new ComposeWarningsGuard(guards); } /**'], ["getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also", '// about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; } /**'], ['', '(warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( this.warningsGuard = new ComposeWarningsGuard(guards);'], ['ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);', '!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( this.warningsGuard = composedGuards;'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-161', 1, 1, 1, 1, ['// If GETPROP/GETELEM is used as assignment target the array literal is // acting as a temporary we can\'t fold it here: // "[][0] += 1" if (right.getType() != Token.NUMBER) { // Sometimes people like to use complex expressions to index into'], ['// If GETPROP/GETELEM is used as assignment target the array literal is // acting as a temporary we can\'t fold it here: // "[][0] += 1" if (isAssignmentTarget(n)) { return n; } if (right.getType() != Token.NUMBER) { // Sometimes people like to use complex expressions to index into'], [''], ['if (isAssignmentTarget(n)) { return n; }'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-162', 6, 6, 6, 6, ['/** * Return an iterable over all of the variables declared in this scope. */ @Override public Iterable<Var> getReferences(Var var) {', 'if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } }', 'hasErrors = true; } // TODO(robbyw): Support using locals for private variables. private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) {', "validateScopeCall(t, n, n.getParent()); } // Validate the top level of the goog.scope block. if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Return early, to ensure that we don't record a definition // twice. return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);", "// Validate all descendent scopes of the goog.scope block. if (t.getScopeDepth() >= 2) { // Check if this name points to an alias. if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { // Note, to support the transitive case, it's important we don't // clone aliasedNode here. For example, // var g = goog; var d = g.dom; d.createElement('DIV');", "// with <code>g.dom.createElement('DIV')</code>. Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo();"], ['/** * Return an iterable over all of the variables declared in this scope. */ Iterable<Var> getVarIterable() { return vars.values(); } @Override public Iterable<Var> getReferences(Var var) {', 'if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } }', 'hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) {', "validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } // Validate the top level of the goog.scope block. if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); // Return early, to ensure that we don't record a definition // twice. return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);", "// Validate all descendent scopes of the goog.scope block. if (t.getScopeDepth() >= 2) { // Check if this name points to an alias. if (aliasVar != null) { // Note, to support the transitive case, it's important we don't // clone aliasedNode here. For example, // var g = goog; var d = g.dom; d.createElement('DIV');", "// with <code>g.dom.createElement('DIV')</code>. Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } JSDocInfo info = n.getJSDocInfo();"], ['', '', '', 'int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); }', 'if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {', '}'], ['Iterable<Var> getVarIterable() { return vars.values(); }', 'findAliases(t);', 'private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } }', 'if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());', 'if (aliasVar != null) {', ''], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-163', 18, 18, 18, 18, ["// given a name context. These contexts do not have scopes. private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); // NOTE(nicksantos): We use the same anonymous node for all // functions that do not have reasonable names. I can't remember // at the moment why we do this. I think it's because anonymous // nodes can never have in-edges. They're just there as a placeholder // for scope information, and do not matter in the edge propagation. } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { // Process prototype assignments to non-functions. if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; }", 'if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals("prototype")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { // Do not mark prototype prop assigns as a \'use\' in the global scope. addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && // Make sure that we\'re not handling object literals being // assigned to a prototype, as in: // Foo.prototype = {bar: 3, baz: 5}; !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( "prototype"))) { // var x = {a: 1, b: 2} // should count as a use of property a and b.', 'if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {', '} // Process prototype assignments to non-functions. if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } }', '* If this is a non-function prototype assign, return the prop name. * Otherwise, return null. */ /** * Determines whether {@code n} is the FUNCTION node in a global function', "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { // Make sure we're either in the global scope, or the function // we're looking at is the root of the current local scope. return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } /** * Returns true if this is the r-value of an assignment. */ private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); /** * Returns the name of a prototype property being assigned to this r-value.", '* the R-value is used in multiple expressions (i.e., if there\'s * a prototype property assignment in a more complex expression). */ if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals("prototype")) { return true; } } } return false; } /**', '* If it is, record it and return true. Otherwise, return false. */ private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||', "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); // If the function name is exported, we should create an edge here // so that it's never removed.", '* under an assignment (in the case of Foo.prototype = ...). * @return True if a declaration was added. */ private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { // Foo.prototype.getBar = function() { ... } case Token.GETPROP:', 'String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;', 'String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module,', '/** * The variable for the root of this symbol. */ /** * Returns the module where this appears.', '*/ class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {', '*/ static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; /** * @param node An EXPR node. */ AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }', 'private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); }', ' // If this is a function context, then scope will be the scope of the // corresponding function. Otherwise, it will be null. Scope scope; NameContext(NameInfo name) { this.name = name; } }', '// So if we move a prototype method into a deeper module, we must // replace it with a stub function so that it preserves its original // behavior. Node value = prop.getValue(); if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&'], ["// given a name context. These contexts do not have scopes. private Stack<NameContext> symbolStack = new Stack<NameContext>(); @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode(); if (n.isFunction()) { String propName = getPrototypePropertyNameFromRValue(n); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), t.getScope())); } else if (isGlobalFunctionDeclaration(t, n)) { Node parent = n.getParent(); String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push( new NameContext(getNameInfoForName(name, VAR), t.getScope())); } else { // NOTE(nicksantos): We use the same anonymous node for all // functions that do not have reasonable names. I can't remember // at the moment why we do this. I think it's because anonymous // nodes can never have in-edges. They're just there as a placeholder // for scope information, and do not matter in the edge propagation. symbolStack.push(new NameContext(anonymousNode, t.getScope())); } } else { Preconditions.checkState(t.inGlobalScope()); symbolStack.push(new NameContext(globalNode, t.getScope())); } } @Override public void exitScope(NodeTraversal t) { symbolStack.pop(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { // Process prototype assignments to non-functions. String propName = processNonFunctionPrototypeAssign(n, parent); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), null)); } return true; }", 'if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (n.isQualifiedName()) { if (propName.equals("prototype")) { if (processPrototypeRef(t, n)) { return; } } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); return; } else { // Do not mark prototype prop assigns as a \'use\' in the global scope. if (n.getParent().isAssign() && n.getNext() != null) { String rValueName = getPrototypePropertyNameFromRValue(n); if (rValueName != null) { return; } } } } addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit()) { // Make sure that we\'re not handling object literals being // assigned to a prototype, as in: // Foo.prototype = {bar: 3, baz: 5}; String lValueName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); if (lValueName != null && lValueName.endsWith(".prototype")) { return; } // var x = {a: 1, b: 2} // should count as a use of property a and b.', 'if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, var)) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {', '} // Process prototype assignments to non-functions. if (processNonFunctionPrototypeAssign(n, parent) != null) { symbolStack.pop(); } }', '* If this is a non-function prototype assign, return the prop name. * Otherwise, return null. */ private String processNonFunctionPrototypeAssign(Node n, Node parent) { if (isAssignRValue(n, parent) && !n.isFunction()) { return getPrototypePropertyNameFromRValue(n); } return null; } /** * Determines whether {@code n} is the FUNCTION node in a global function', "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { // Make sure we're either in the global scope, or the function // we're looking at is the root of the current local scope. Scope s = t.getScope(); if (!(s.isGlobal() || s.getDepth() == 1 && s.getRootNode() == n)) { return false; } return NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName(); } /** * Returns true if this is the r-value of an assignment. */ private boolean isAssignRValue(Node n, Node parent) { return parent != null && parent.isAssign() && parent.getFirstChild() != n; } /** * Returns the name of a prototype property being assigned to this r-value.", '* the R-value is used in multiple expressions (i.e., if there\'s * a prototype property assignment in a more complex expression). */ private String getPrototypePropertyNameFromRValue(Node rValue) { Node lValue = NodeUtil.getBestLValue(rValue); if (lValue == null || lValue.getParent() == null || lValue.getParent().getParent() == null || !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) || NodeUtil.isExprAssign(lValue.getParent().getParent()))) { return null; } String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue)); if (lValueName == null) { return null; } int lastDot = lValueName.lastIndexOf(\'.\'); if (lastDot == -1) { return null; } String firstPart = lValueName.substring(0, lastDot); if (!firstPart.endsWith(".prototype")) { return null; } return lValueName.substring(lastDot + 1); } /**', '* If it is, record it and return true. Otherwise, return false. */ private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Var v) { Node firstChild = nameNode.getFirstChild(); Node parent = nameNode.getParent(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||', "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, v, t.getModule())); // If the function name is exported, we should create an edge here // so that it's never removed.", '* under an assignment (in the case of Foo.prototype = ...). * @return True if a declaration was added. */ private boolean processPrototypeRef(NodeTraversal t, Node ref) { Node root = NodeUtil.getRootOfQualifiedName(ref); Node n = ref.getParent(); switch (n.getType()) { // Foo.prototype.getBar = function() { ... } case Token.GETPROP:', 'String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getScope().getVar(root.getString()), t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); return true; } break;', 'String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getScope().getVar(root.getString()), t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } return true; } break; } return false; } private void addGlobalUseOfSymbol(String name, JSModule module,', '/** * The variable for the root of this symbol. */ Var getRootVar(); /** * Returns the module where this appears.', '*/ class GlobalFunction implements Symbol { private final Node nameNode; private final Var var; private final JSModule module; GlobalFunction(Node nameNode, Var var, JSModule module) { Node parent = nameNode.getParent(); Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.var = var; this.module = module; } @Override public Var getRootVar() { return var; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {', '*/ static class AssignmentProperty implements Property { private final Node exprNode; private final Var rootVar; private final JSModule module; /** * @param node An EXPR node. */ AssignmentProperty(Node node, Var rootVar, JSModule module) { this.exprNode = node; this.rootVar = rootVar; this.module = module; } @Override public Var getRootVar() { return rootVar; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }', 'private final Node value; private final Node map; private final Node assign; private final Var rootVar; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, Var rootVar, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.rootVar = rootVar; this.module = module; } @Override public Var getRootVar() { return rootVar; } @Override public void remove() { map.removeChild(key); }', ' // If this is a function context, then scope will be the scope of the // corresponding function. Otherwise, it will be null. final Scope scope; NameContext(NameInfo name, Scope scope) { this.name = name; this.scope = scope; } }', '// So if we move a prototype method into a deeper module, we must // replace it with a stub function so that it preserves its original // behavior. if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) { continue; } Node value = prop.getValue(); if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&'], ['private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } symbolStack.peek().scope = t.getScope(); if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));', 'processPrototypeParent(t, parent); addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( "prototype"))) {', 'if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {', 'if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {', '', 'return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp();', 'if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals("prototype")) { return true; } } return false;', 'Node nameNode, Node parent, Node gramps) {', 'new GlobalFunction(nameNode, parent, gramps, t.getModule()));', 'private void processPrototypeParent(NodeTraversal t, Node n) {', '', '', '', 'GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {', 'AssignmentProperty(Node node, JSModule module) {', 'JSModule module) {', 'Scope scope; NameContext(NameInfo name) {', ''], ['Node n = t.getCurrentNode(); if (n.isFunction()) { String propName = getPrototypePropertyNameFromRValue(n); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), t.getScope())); } else if (isGlobalFunctionDeclaration(t, n)) { Node parent = n.getParent(); String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push( new NameContext(getNameInfoForName(name, VAR), t.getScope())); } else { symbolStack.push(new NameContext(anonymousNode, t.getScope())); } } else { Preconditions.checkState(t.inGlobalScope()); symbolStack.push(new NameContext(globalNode, t.getScope())); } symbolStack.pop(); String propName = processNonFunctionPrototypeAssign(n, parent); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), null));', 'if (n.isQualifiedName()) { if (processPrototypeRef(t, n)) { return; } return; if (n.getParent().isAssign() && n.getNext() != null) { String rValueName = getPrototypePropertyNameFromRValue(n); if (rValueName != null) { return; } } } addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit()) { String lValueName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); if (lValueName != null && lValueName.endsWith(".prototype")) { return; }', 'if (!processGlobalFunctionDeclaration(t, n, var)) {', 'if (processNonFunctionPrototypeAssign(n, parent) != null) {', 'private String processNonFunctionPrototypeAssign(Node n, Node parent) { if (isAssignRValue(n, parent) && !n.isFunction()) { return getPrototypePropertyNameFromRValue(n); } return null; }', 'Scope s = t.getScope(); if (!(s.isGlobal() || s.getDepth() == 1 && s.getRootNode() == n)) { return false; } return NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName(); private boolean isAssignRValue(Node n, Node parent) { return parent != null && parent.isAssign() && parent.getFirstChild() != n; }', 'private String getPrototypePropertyNameFromRValue(Node rValue) { Node lValue = NodeUtil.getBestLValue(rValue); if (lValue == null || lValue.getParent() == null || lValue.getParent().getParent() == null || !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) || NodeUtil.isExprAssign(lValue.getParent().getParent()))) { return null; } String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue)); if (lValueName == null) { return null; } int lastDot = lValueName.lastIndexOf(\'.\'); if (lastDot == -1) { return null; String firstPart = lValueName.substring(0, lastDot); if (!firstPart.endsWith(".prototype")) { return null; } return lValueName.substring(lastDot + 1);', 'Node nameNode, Var v) { Node parent = nameNode.getParent();', 'new GlobalFunction(nameNode, v, t.getModule()));', 'private boolean processPrototypeRef(NodeTraversal t, Node ref) { Node root = NodeUtil.getRootOfQualifiedName(ref); Node n = ref.getParent();', 't.getScope().getVar(root.getString()), return true;', 't.getScope().getVar(root.getString()), return true; return false;', 'Var getRootVar();', 'private final Var var; GlobalFunction(Node nameNode, Var var, JSModule module) { Node parent = nameNode.getParent(); this.var = var; public Var getRootVar() { return var; } @Override', 'private final Var rootVar; AssignmentProperty(Node node, Var rootVar, JSModule module) { this.rootVar = rootVar; public Var getRootVar() { return rootVar; } @Override', 'private final Var rootVar; Var rootVar, JSModule module) { this.rootVar = rootVar; public Var getRootVar() { return rootVar; } @Override', 'final Scope scope; NameContext(NameInfo name, Scope scope) { this.scope = scope;', 'if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) { continue; }'], 'a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java', 'b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java']
['Closure-164', 2, 2, 2, 2, [' boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); // "that" can\'t be a supertype, because it\'s missing a required argument. // NOTE(nicksantos): In our type system, we use {function(...?)} and // {function(...NoType)} to to indicate that arity should not be // checked. Strictly speaking, this is not a correct formulation, // because now a sub-function can required arguments that are var_args // in the super-function. So we special-case this. // don\'t advance if we have variable arguments if (!thisIsVarArgs) {', '} // "that" can\'t be a supertype, because it\'s missing a required arguement. return true; }'], [' boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); // "that" can\'t be a supertype, because it\'s missing a required argument. if (!thisIsOptional && thatIsOptional) { // NOTE(nicksantos): In our type system, we use {function(...?)} and // {function(...NoType)} to to indicate that arity should not be // checked. Strictly speaking, this is not a correct formulation, // because now a sub-function can required arguments that are var_args // in the super-function. So we special-case this. boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } } // don\'t advance if we have variable arguments if (!thisIsVarArgs) {', '} // "that" can\'t be a supertype, because it\'s missing a required arguement. if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; } return true; }'], ['', ''], ['boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); if (!thisIsOptional && thatIsOptional) { boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } }', 'if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; }'], 'a/src/com/google/javascript/rhino/jstype/ArrowType.java', 'b/src/com/google/javascript/rhino/jstype/ArrowType.java']
['Closure-165', 10, 10, 10, 10, ["if (!greatestSubtype.isEmptyType()) { // We've found a type with this property. Now we just have to make // sure it's not a type used for internal bookkeeping. return true; }", "* don't actually exist in the user's program. They're just used for * bookkeeping in the type system. */ /** * Defines a property whose type is inferred.", 'private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private boolean isFrozen = false; /** * Creates a record type.', '* @throws IllegalStateException if the {@code RecordProperty} associated * with a property is null. */ RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { super(registry, null, null); setPrettyPrint(true); for (String property : properties.keySet()) { RecordProperty prop = properties.get(property);', 'throw new IllegalStateException( "RecordProperty associated with a property should not be null!"); } defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } // Freeze the record type.', '} /** @return Is this synthesized for internal bookkeeping? */ @Override public boolean isEquivalentTo(JSType other) {', 'if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type', '*/ public class RecordTypeBuilder { private boolean isEmpty = true; private final JSTypeRegistry registry; private final HashMap<String, RecordProperty> properties = Maps.newHashMap();', '} /** See the comments on RecordType about synthetic types. */ /** * Adds a property with the given name and type to the record type.', '} return new RecordType( registry, Collections.unmodifiableMap(properties)); } static class RecordProperty {'], ["if (!greatestSubtype.isEmptyType()) { // We've found a type with this property. Now we just have to make // sure it's not a type used for internal bookkeeping. RecordType maybeRecordType = greatestSubtype.toMaybeRecordType(); if (maybeRecordType != null && maybeRecordType.isSynthetic()) { continue; } return true; }", "* don't actually exist in the user's program. They're just used for * bookkeeping in the type system. */ public final boolean defineSynthesizedProperty(String propertyName, JSType type, Node propertyNode) { return defineProperty(propertyName, type, false, propertyNode); } /** * Defines a property whose type is inferred.", 'private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private final boolean declared; private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); } /** * Creates a record type.', '* @throws IllegalStateException if the {@code RecordProperty} associated * with a property is null. */ RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared; for (String property : properties.keySet()) { RecordProperty prop = properties.get(property);', 'throw new IllegalStateException( "RecordProperty associated with a property should not be null!"); } if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); } } // Freeze the record type.', '} /** @return Is this synthesized for internal bookkeeping? */ boolean isSynthetic() { return !declared; } @Override public boolean isEquivalentTo(JSType other) {', 'if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type', '*/ public class RecordTypeBuilder { private boolean isEmpty = true; private boolean isDeclared = true; private final JSTypeRegistry registry; private final HashMap<String, RecordProperty> properties = Maps.newHashMap();', '} /** See the comments on RecordType about synthetic types. */ void setSynthesized(boolean synthesized) { isDeclared = !synthesized; } /** * Adds a property with the given name and type to the record type.', '} return new RecordType( registry, Collections.unmodifiableMap(properties), isDeclared); } static class RecordProperty {'], ['', '', '', 'RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {', '', '', '', '', '', 'registry, Collections.unmodifiableMap(properties));'], ['RecordType maybeRecordType = greatestSubtype.toMaybeRecordType(); if (maybeRecordType != null && maybeRecordType.isSynthetic()) { continue; }', 'public final boolean defineSynthesizedProperty(String propertyName, JSType type, Node propertyNode) { return defineProperty(propertyName, type, false, propertyNode); }', 'private final boolean declared; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); }', 'RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { this.declared = declared;', 'if (declared) { } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); }', 'boolean isSynthetic() { return !declared; }', 'builder.setSynthesized(true);', 'private boolean isDeclared = true;', 'void setSynthesized(boolean synthesized) { isDeclared = !synthesized; }', 'registry, Collections.unmodifiableMap(properties), isDeclared);'], 'a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java', 'b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java']
['Closure-166', 1, 1, 1, 1, ['// properties on this object. if (constraint.isRecordType()) { matchRecordTypeConstraint(constraint.toObjectType()); } }'], ['// properties on this object. if (constraint.isRecordType()) { matchRecordTypeConstraint(constraint.toObjectType()); } else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } } } }'], [''], ['} else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } }'], 'a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java', 'b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java']
['Closure-167', 6, 6, 6, 6, ['if (merged != null) { return maybeRestrictTwoNames( blindScope, left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB); } return blindScope; }', '// creating new scope return maybeRestrictTwoNames( blindScope, left, leftIsRefineable, restrictedLeftType, right, rightIsRefineable, restrictedRightType); } return blindScope; }', '*/ private FlowScope maybeRestrictName( FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) { if (restrictedType != null && !restrictedType.equals(originalType)) { FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, node, restrictedType); return informed;', '*/ private FlowScope maybeRestrictTwoNames( FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) { boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null; boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null; if (shouldRefineLeft || shouldRefineRight) { FlowScope informed = blindScope.createChildFlowScope(); if (shouldRefineLeft) {', 'boolean outcome) { JSType type = getTypeIfRefinable(name, blindScope); if (type != null) { JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome); FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, name, restrictedType); return informed; } return blindScope; }', '* method of types to get the restricted type. */ public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) {'], ['if (merged != null) { return maybeRestrictTwoNames( blindScope, left, leftType, leftIsRefineable ? merged.typeA : null, right, rightType, rightIsRefineable ? merged.typeB : null); } return blindScope; }', '// creating new scope return maybeRestrictTwoNames( blindScope, left, leftType, leftIsRefineable ? restrictedLeftType : null, right, rightType, rightIsRefineable ? restrictedRightType : null); } return blindScope; }', '*/ private FlowScope maybeRestrictName( FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) { if (restrictedType != null && restrictedType != originalType) { FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, node, restrictedType); return informed;', '*/ private FlowScope maybeRestrictTwoNames( FlowScope blindScope, Node left, JSType originalLeftType, JSType restrictedLeftType, Node right, JSType originalRightType, JSType restrictedRightType) { boolean shouldRefineLeft = restrictedLeftType != null && restrictedLeftType != originalLeftType; boolean shouldRefineRight = restrictedRightType != null && restrictedRightType != originalRightType; if (shouldRefineLeft || shouldRefineRight) { FlowScope informed = blindScope.createChildFlowScope(); if (shouldRefineLeft) {', 'boolean outcome) { JSType type = getTypeIfRefinable(name, blindScope); if (type != null) { return maybeRestrictName( blindScope, name, type, type.getRestrictedTypeGivenToBooleanOutcome(outcome)); } return blindScope; }', '* method of types to get the restricted type. */ public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) {'], ['left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB);', 'left, leftIsRefineable, restrictedLeftType, right, rightIsRefineable, restrictedRightType);', 'if (restrictedType != null && !restrictedType.equals(originalType)) {', 'Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) { leftIsRefineable && restrictedLeftType != null; rightIsRefineable && restrictedRightType != null;', 'JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome); FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, name, restrictedType); return informed;', ''], ['left, leftType, leftIsRefineable ? merged.typeA : null, right, rightType, rightIsRefineable ? merged.typeB : null);', 'left, leftType, leftIsRefineable ? restrictedLeftType : null, right, rightType, rightIsRefineable ? restrictedRightType : null);', 'if (restrictedType != null && restrictedType != originalType) {', 'Node left, JSType originalLeftType, JSType restrictedLeftType, Node right, JSType originalRightType, JSType restrictedRightType) { restrictedLeftType != null && restrictedLeftType != originalLeftType; restrictedRightType != null && restrictedRightType != originalRightType;', 'return maybeRestrictName( blindScope, name, type, type.getRestrictedTypeGivenToBooleanOutcome(outcome));', 'if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); }'], 'a/src/com/google/javascript/rhino/jstype/JSType.java', 'b/src/com/google/javascript/rhino/jstype/JSType.java']
['Closure-168', 1, 1, 1, 1, ['data.get(t.getScopeRoot()).recordNonEmptyReturn(); } if (t.getScopeDepth() <= 2) { // The first-order function analyzer looks at two types of variables: // // 1) Local variables that are assigned in inner scopes ("escaped vars")'], ['data.get(t.getScopeRoot()).recordNonEmptyReturn(); } if (t.getScopeDepth() <= 1) { // The first-order function analyzer looks at two types of variables: // // 1) Local variables that are assigned in inner scopes ("escaped vars")'], ['if (t.getScopeDepth() <= 2) {'], ['if (t.getScopeDepth() <= 1) {'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-169', 21, 22, 22, 22, ["* @return True if our parameter spec is equal to {@code that}'s parameter * spec. */ boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) {", '// Both parameter lists give a type for this param, it should be equal if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, tolerateUnknowns)) { return false; } } else {', '} boolean checkArrowEquivalenceHelper( ArrowType that, boolean tolerateUnknowns) { // Please keep this method in sync with the hashCode() method below. if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return false; } return hasEqualParameters(that, tolerateUnknowns); } @Override eleted file mode 100644', "private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, false)) { newParamsNode = call.parameters; } else { // If the parameters are not equal, don't try to merge them.", '* have signatures, two interfaces are equal if their names match. */ boolean checkFunctionEquivalenceHelper( FunctionType that, boolean tolerateUnknowns) { if (isConstructor()) { if (that.isConstructor()) { return this == that;', '} return typeOfThis.checkEquivalenceHelper( that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns); } @Override', '} public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper(otherType.call, false); } /**', '* Checks if two types are equivalent. */ public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } /**', '* @see EquivalenceMethod */ public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } /**', '* unknowns</a> */ public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } /** * An equivalence visitor. */ boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; }', "boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { // If we're checking for invariance, the unknown type is invariant // with everyone. // If we're checking data flow, then two types are the same if they're // both unknown. return thisUnknown && thatUnknown;", ' if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType();', 'boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { // If one of the type parameters is unknown, but the other is not, // then we consider these the same for the purposes of data flow // and invariance. paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ?', 'JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) {', 'if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } // Relies on the fact that for the base {@link JSType}, only one', '} boolean checkRecordEquivalenceHelper( RecordType otherRecord, boolean tolerateUnknowns) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) {', '} for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), tolerateUnknowns)) { return false; } }', 'JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } }', " JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) { if (typeA.isPropertyTypeDeclared(property)) { // If one declared property isn't invariant, // then the whole record isn't covariant.", "// then the whole record isn't covariant. if (!propA.isSubtype(propB)) { return false; } } } }", '* and all alternates are equal. */ boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { return false; } } return true; } private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) { return true; } }'], ["* @return True if our parameter spec is equal to {@code that}'s parameter * spec. */ boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) {", '// Both parameter lists give a type for this param, it should be equal if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, eqMethod)) { return false; } } else {', '} boolean checkArrowEquivalenceHelper( ArrowType that, EquivalenceMethod eqMethod) { // Please keep this method in sync with the hashCode() method below. if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) { return false; } return hasEqualParameters(that, eqMethod); } @Override eleted file mode 100644', '/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * Google Inc. * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; /** * Represents different ways for comparing equality among types. * @author nicksantos@google.com (Nick Santos) */ enum EquivalenceMethod { /** * Indicates that the two types should behave exactly the same under * all type operations. * * Thus, {string} != {?} and {Unresolved} != {?} */ IDENTITY, /** * Indicates that the two types are almost exactly the same, and that a * data flow analysis algorithm comparing them should consider them equal. * * In traditional type inference, the types form a finite lattice, and this * ensures that type inference will terminate. * * In our type system, the unknown types do not obey the lattice rules. So * if we continue to perform inference over the unknown types, we may * never terminate. * * By treating all unknown types as equivalent for the purposes of data * flow analysis, we ensure that the algorithm will terminate. * * Thus, {string} != {?} and {Unresolved} ~= {?} */ DATA_FLOW, /** * Indicates that two types are invariant. * * In a type system without unknown types, this would be the same * as IDENTITY. But we always want to consider type A invariant with type B * if B is unknown. * * Thus, {string} ~= {?} and {Unresolved} ~= {?} */ INVARIANT }', "private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) { newParamsNode = call.parameters; } else { // If the parameters are not equal, don't try to merge them.", '* have signatures, two interfaces are equal if their names match. */ boolean checkFunctionEquivalenceHelper( FunctionType that, EquivalenceMethod eqMethod) { if (isConstructor()) { if (that.isConstructor()) { return this == that;', '} return typeOfThis.checkEquivalenceHelper( that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod); } @Override', '} public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper( otherType.call, EquivalenceMethod.IDENTITY); } /**', '* Checks if two types are equivalent. */ public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY); } /**', '* @see EquivalenceMethod */ public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT); } /**', '* unknowns</a> */ public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW); } /** * An equivalence visitor. */ boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) { if (this == that) { return true; }', "boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (eqMethod == EquivalenceMethod.INVARIANT) { // If we're checking for invariance, the unknown type is invariant // with everyone. return true; } else if (eqMethod == EquivalenceMethod.DATA_FLOW) { // If we're checking data flow, then two types are the same if they're // both unknown. return thisUnknown && thatUnknown;", ' if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), eqMethod); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), eqMethod); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), eqMethod); } ParameterizedType thisParamType = toMaybeParameterizedType();', 'boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), eqMethod); } else if (eqMethod == EquivalenceMethod.IDENTITY) { paramsMatch = false; } else { // If one of the type parameters is unknown, but the other is not, // then we consider these the same for the purposes of data flow // and invariance. paramsMatch = true; } JSType thisRootType = thisParamType == null ?', 'JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, eqMethod); } if (isNominalType() && that.isNominalType()) {', 'if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, eqMethod); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), eqMethod); } // Relies on the fact that for the base {@link JSType}, only one', '} boolean checkRecordEquivalenceHelper( RecordType otherRecord, EquivalenceMethod eqMethod) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) {', '} for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), eqMethod)) { return false; } }', 'JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && propType.isInvariant(altPropType)) { builder.addAlternate(alt); } }', " JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (typeA.isPropertyTypeDeclared(property)) { // If one declared property isn't invariant, // then the whole record isn't covariant.", "// then the whole record isn't covariant. if (!propA.isSubtype(propB)) { return false; } } }", '* and all alternates are equal. */ boolean checkUnionEquivalenceHelper( UnionType that, EquivalenceMethod eqMethod) { if (eqMethod == EquivalenceMethod.IDENTITY && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, eqMethod)) { return false; } } return true; } private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) { for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, eqMethod)) { return true; } }'], ['boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {', 'otherParamType, tolerateUnknowns)) {', 'ArrowType that, boolean tolerateUnknowns) { if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return hasEqualParameters(that, tolerateUnknowns);', '', 'if (call.hasEqualParameters(other.call, false)) {', 'FunctionType that, boolean tolerateUnknowns) {', 'that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);', 'return this.call.checkArrowEquivalenceHelper(otherType.call, false);', 'return checkEquivalenceHelper(that, false);', 'return checkEquivalenceHelper(that, false);', 'return !checkEquivalenceHelper(that, true); boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {', 'if (tolerateUnknowns) {', 'that.toMaybeUnionType(), tolerateUnknowns); that.toMaybeFunctionType(), tolerateUnknowns); that.toMaybeRecordType(), tolerateUnknowns);', 'thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { } else { paramsMatch = false;', 'thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);', 'that, tolerateUnknowns); tolerateUnknowns);', 'RecordType otherRecord, boolean tolerateUnknowns) {', 'properties.get(key), tolerateUnknowns)) {', '(propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {', 'if (!propA.isUnknownType() && !propB.isUnknownType()) {', '}', 'UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns if (!hasAlternate(alternate, tolerateUnknowns)) { private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {'], ['boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {', 'otherParamType, eqMethod)) {', 'ArrowType that, EquivalenceMethod eqMethod) { if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) { return hasEqualParameters(that, eqMethod);', '/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * Google Inc. * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; /** * Represents different ways for comparing equality among types. * @author nicksantos@google.com (Nick Santos) */ enum EquivalenceMethod { /** * Indicates that the two types should behave exactly the same under * all type operations. * * Thus, {string} != {?} and {Unresolved} != {?} */ IDENTITY, /** * Indicates that the two types are almost exactly the same, and that a * data flow analysis algorithm comparing them should consider them equal. * * In traditional type inference, the types form a finite lattice, and this * ensures that type inference will terminate. * * In our type system, the unknown types do not obey the lattice rules. So * if we continue to perform inference over the unknown types, we may * never terminate. * * By treating all unknown types as equivalent for the purposes of data * flow analysis, we ensure that the algorithm will terminate. * * Thus, {string} != {?} and {Unresolved} ~= {?} */ DATA_FLOW, /** * Indicates that two types are invariant. * * In a type system without unknown types, this would be the same * as IDENTITY. But we always want to consider type A invariant with type B * if B is unknown. * * Thus, {string} ~= {?} and {Unresolved} ~= {?} */ INVARIANT }', 'if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {', 'FunctionType that, EquivalenceMethod eqMethod) {', 'that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod);', 'return this.call.checkArrowEquivalenceHelper( otherType.call, EquivalenceMethod.IDENTITY);', 'return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);', 'return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);', 'return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW); boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {', 'if (eqMethod == EquivalenceMethod.INVARIANT) { return true; } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {', 'that.toMaybeUnionType(), eqMethod); that.toMaybeFunctionType(), eqMethod); that.toMaybeRecordType(), eqMethod);', 'thatParamType.getParameterType(), eqMethod); } else if (eqMethod == EquivalenceMethod.IDENTITY) { paramsMatch = false; } else {', 'thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);', 'that, eqMethod); eqMethod);', 'RecordType otherRecord, EquivalenceMethod eqMethod) {', 'properties.get(key), eqMethod)) {', 'propType.isInvariant(altPropType)) {', '', '', 'UnionType that, EquivalenceMethod eqMethod) { if (eqMethod == EquivalenceMethod.IDENTITY if (!hasAlternate(alternate, eqMethod)) { private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) { if (alternate.checkEquivalenceHelper(type, eqMethod)) {'], 'a/src/com/google/javascript/rhino/jstype/UnionType.java', 'b/src/com/google/javascript/rhino/jstype/UnionType.java']
['Closure-170', 1, 1, 1, 1, [" @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && n.getString().equals(varName) && // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. !(parent.isAssign() && (parent.getFirstChild() == n))) { // Don't count lhs of top-level assignment chain numUsesWithinCfgNode++; } } }; NodeTraversal.traverse(compiler, cfgNode, gatherCb);"], [" @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && n.getString().equals(varName)) { // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { // Don't count lhs of top-level assignment chain return; } else { numUsesWithinCfgNode++; } } } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; } }; NodeTraversal.traverse(compiler, cfgNode, gatherCb);"], ['if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) {'], ['if (n.isName() && n.getString().equals(varName)) { if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { return; } else { } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; }'], 'a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java', 'b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java']
['Closure-171', 2, 2, 2, 2, ['// See CodingConvention#getObjectLiteralCase and goog.object.reflect. // Ignore these types of literals. ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; }', '} // Prototype sets are always declared. boolean inferred = true; if (info != null) {'], ['// See CodingConvention#getObjectLiteralCase and goog.object.reflect. // Ignore these types of literals. ObjectType objectType = ObjectType.cast(type); if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) { return scope; }', '} // Prototype sets are always declared. if (qName != null && qName.endsWith(".prototype")) { return false; } boolean inferred = true; if (info != null) {'], ['if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) {', ''], ['if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {', 'if (qName != null && qName.endsWith(".prototype")) { return false; }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-172', 1, 1, 1, 1, [' // Prototypes of constructors and interfaces are always declared. if (qName != null && qName.endsWith(".prototype")) { return false; } boolean inferred = true;'], [' // Prototypes of constructors and interfaces are always declared. if (qName != null && qName.endsWith(".prototype")) { String className = qName.substring(0, qName.lastIndexOf(".prototype")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { return false; } } boolean inferred = true;'], [''], ['String className = qName.substring(0, qName.lastIndexOf(".prototype")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-173', 2, 2, 2, 2, ['// the IN_FOR_INIT_CLAUSE one. Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { // Assignments are the only right-associative binary operators addExpr(first, p, context); cc.addOp(opstr, true);', 'case Token.ARRAYLIT: return tryMinimizeArrayLiteral(node); default: return node; //Nothing changed } } private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall());'], ['// the IN_FOR_INIT_CLAUSE one. Context rhsContext = getContextForNoInOperator(context); if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { // Assignments are the only right-associative binary operators addExpr(first, p, context); cc.addOp(opstr, true);', 'case Token.ARRAYLIT: return tryMinimizeArrayLiteral(node); case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITXOR: case Token.BITAND: return tryRotateAssociativeOperator(node); default: return node; //Nothing changed } } private Node tryRotateAssociativeOperator(Node n) { if (!late) { return n; } Preconditions.checkArgument(NodeUtil.isAssociative(n.getType())); Node rhs = n.getLastChild(); if (n.getType() == rhs.getType()) { Node parent = n.getParent(); Node first = n.getFirstChild().detachFromParent(); Node second = rhs.getFirstChild().detachFromParent(); Node third = rhs.getLastChild().detachFromParent(); Node newLhs = new Node(n.getType(), first, second) .copyInformationFrom(n); Node newRoot = new Node(rhs.getType(), newLhs, third) .copyInformationFrom(rhs); parent.replaceChild(n, newRoot); reportCodeChange(); return newRoot; } return n; } private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall());'], ['if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {', ''], ['if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {', 'case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITXOR: case Token.BITAND: return tryRotateAssociativeOperator(node); private Node tryRotateAssociativeOperator(Node n) { if (!late) { return n; } Preconditions.checkArgument(NodeUtil.isAssociative(n.getType())); Node rhs = n.getLastChild(); if (n.getType() == rhs.getType()) { Node parent = n.getParent(); Node first = n.getFirstChild().detachFromParent(); Node second = rhs.getFirstChild().detachFromParent(); Node third = rhs.getLastChild().detachFromParent(); Node newLhs = new Node(n.getType(), first, second) .copyInformationFrom(n); Node newRoot = new Node(rhs.getType(), newLhs, third) .copyInformationFrom(rhs); parent.replaceChild(n, newRoot); reportCodeChange(); return newRoot; } return n; }'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-174', 7, 7, 7, 7, ['} private void parse(AbstractCompiler compiler) { try { ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(),', '} if (root == null || compiler.hasHaltingErrors()) { // Most passes try to report as many errors as possible, // so there may already be errors. We only care if there were // errors in the code we just parsed. // There was a parse error or IOException, so use a dummy block. root = IR.script(); } else {', 'if (nameNode.isName()) { result = IR.var(nameNode, value); result.setJSDocInfo(info); } else { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); } return result;', 'for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVarAssign = parent.isVar() && n.hasChildren(); if (isVarAssign && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVarAssign) { Node value = v.getInitialValue().detachFromParent(); String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name);', ' // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info. Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName,', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); parent.getParent().addChildBefore(newDecl, parent); // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;" v.getNameNode().addChildToFront('], ['} private void parse(AbstractCompiler compiler) { int startErrorCount = compiler.getErrorManager().getErrorCount(); try { ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(),', '} if (root == null || // Most passes try to report as many errors as possible, // so there may already be errors. We only care if there were // errors in the code we just parsed. (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) { // There was a parse error or IOException, so use a dummy block. root = IR.script(); } else {', 'if (nameNode.isName()) { result = IR.var(nameNode, value); result.setJSDocInfo(info); } else if (value != null) { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); } else { result = IR.exprResult(nameNode); result.getFirstChild().setJSDocInfo(info); } return result;', 'for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVar) { Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name);', ' // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info. if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName,', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); parent.getParent().addChildBefore(newDecl, parent); } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;" v.getNameNode().addChildToFront('], ['', 'if (root == null || compiler.hasHaltingErrors()) {', 'result = IR.exprResult(IR.assign(nameNode, value));', 'boolean isVarAssign = parent.isVar() && n.hasChildren(); if (isVarAssign && n.getFirstChild().isQualifiedName()) {', '} else if (isVarAssign) { Node value = v.getInitialValue().detachFromParent();', '', ''], ['int startErrorCount = compiler.getErrorManager().getErrorCount();', 'if (root == null || (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {', '} else if (value != null) { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); result = IR.exprResult(nameNode);', 'boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {', '} else if (isVar) { Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;', 'if (value != null || v.getJSDocInfo() != null) {', '}'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-175', 4, 4, 4, 4, ['private final boolean assumeStrictThis; private final boolean assumeMinimumCapture; private final Supplier<String> safeNameIdSupplier; /** * @param allowDecomposition Whether an effort should be made to break down', '} if (mode == InliningMode.DIRECT) { return canInlineReferenceDirectly(callNode, fnNode); } else { return canInlineReferenceAsStatementBlock( t, callNode, fnNode, needAliases);', '* </pre> */ private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '} } Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { if (fnParam != null) { if (cArg != null) { if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } fnParam = fnParam.getNext(); } // Limit the inlining if (cArg != null) { if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { return CanInlineResult.NO; } cArg = cArg.getNext(); } }'], ['private final boolean assumeStrictThis; private final boolean assumeMinimumCapture; private final Supplier<String> safeNameIdSupplier; private final Supplier<String> throwawayNameSupplier = new Supplier<String>() { private int nextId = 0; @Override public String get() { return String.valueOf(nextId++); } }; /** * @param allowDecomposition Whether an effort should be made to break down', '} if (mode == InliningMode.DIRECT) { return canInlineReferenceDirectly(callNode, fnNode, needAliases); } else { return canInlineReferenceAsStatementBlock( t, callNode, fnNode, needAliases);', '* </pre> */ private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode, Set<String> namesToAlias) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '} } Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap( fnNode, callNode, this.throwawayNameSupplier); boolean hasArgs = !args.isEmpty(); if (hasArgs) { // Limit the inlining Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias); FunctionArgumentInjector.maybeAddTempsForCallArguments( fnNode, args, allNamesToAlias, compiler.getCodingConvention()); if (!allNamesToAlias.isEmpty()) { return CanInlineResult.NO; } }'], ['', 'return canInlineReferenceDirectly(callNode, fnNode);', 'Node callNode, Node fnNode) { Node block = fnNode.getLastChild();', 'Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { if (fnParam != null) { if (cArg != null) { if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } fnParam = fnParam.getNext(); } if (cArg != null) { if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { } cArg = cArg.getNext();'], ['private final Supplier<String> throwawayNameSupplier = new Supplier<String>() { private int nextId = 0; @Override public String get() { return String.valueOf(nextId++); } };', 'return canInlineReferenceDirectly(callNode, fnNode, needAliases);', 'Node callNode, Node fnNode, Set<String> namesToAlias) {', 'Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap( fnNode, callNode, this.throwawayNameSupplier); boolean hasArgs = !args.isEmpty(); if (hasArgs) { Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias); FunctionArgumentInjector.maybeAddTempsForCallArguments( fnNode, args, allNamesToAlias, compiler.getCodingConvention()); if (!allNamesToAlias.isEmpty()) {'], 'a/src/com/google/javascript/jscomp/FunctionInjector.java', 'b/src/com/google/javascript/jscomp/FunctionInjector.java']
['Closure-176', 3, 3, 3, 3, ["case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); // When looking at VAR initializers for declared VARs, we tend // to use the declared type over the type it's being", '// sure we back-infer the <string> element constraint on // the left hand side, so we use the left hand side. boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred(); // Makes it easier to check for NPEs. // TODO(nicksantos): This might be a better check once we have // back-inference of object/array constraints. It will probably', ' if (isVarTypeBetter) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType();'], ["case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); JSType varType = var == null ? null : var.getType(); boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred(); // When looking at VAR initializers for declared VARs, we tend // to use the declared type over the type it's being", '// sure we back-infer the <string> element constraint on // the left hand side, so we use the left hand side. boolean isVarTypeBetter = isVarDeclaration && // Makes it easier to check for NPEs. !resultType.isNullType() && !resultType.isVoidType(); // TODO(nicksantos): This might be a better check once we have // back-inference of object/array constraints. It will probably', ' if (isVarTypeBetter) { redeclareSimpleVar(scope, left, varType); } else { redeclareSimpleVar(scope, left, resultType); } left.setJSType(resultType); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType();'], ['boolean isVarDeclaration = left.hasChildren();', 'boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();', 'left.setJSType(isVarDeclaration || leftType == null ? resultType : null);'], ['JSType varType = var == null ? null : var.getType(); boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred();', 'boolean isVarTypeBetter = isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType();', 'redeclareSimpleVar(scope, left, varType); } else { left.setJSType(resultType);'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['JxPath-1', 2, 2, 2, 2, ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'else if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return node instanceof Element; case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'else if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['return nodeType == Node.ELEMENT_NODE;', 'return node instanceof Element;'], ['return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;', 'return (node instanceof Element) || (node instanceof Document);'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-2', 4, 4, 4, 4, ['*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'if (result instanceof EvalContext) { return new ValueIterator((EvalContext) result); } return ValueUtils.iterate(result); }', 'if (result instanceof EvalContext) { return (EvalContext) result; } return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale());', 'throw new UnsupportedOperationException(); } } No newline at end of file }'], ['*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.NodeSet; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'if (result instanceof EvalContext) { return new ValueIterator((EvalContext) result); } if (result instanceof NodeSet) { return new ValueIterator(((NodeSet) result).getPointers().iterator()); } return ValueUtils.iterate(result); }', 'if (result instanceof EvalContext) { return (EvalContext) result; } if (result instanceof NodeSet) { return new PointerIterator(((NodeSet) result).getPointers().iterator(), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); } return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale());', 'throw new UnsupportedOperationException(); } } } No newline at end of file'], ['', '', '', '}'], ['import org.apache.commons.jxpath.NodeSet;', 'if (result instanceof NodeSet) { return new ValueIterator(((NodeSet) result).getPointers().iterator()); }', 'if (result instanceof NodeSet) { return new PointerIterator(((NodeSet) result).getPointers().iterator(), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); }', '}'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java']
['JxPath-3', 4, 4, 4, 4, ['*/ package org.apache.commons.jxpath.ri.model.beans; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathInvalidAccessException; import org.apache.commons.jxpath.ri.QName;', 'return newParent.createAttribute(context, getName()); } else { // Consider these two use cases: // 1. The parent pointer of NullPropertyPointer is // a PropertyOwnerPointer other than NullPointer. When we call', 'return pointer; } else { if (newParent instanceof PropertyOwnerPointer) { PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; newParent = pop.getPropertyPointer();', '} return string; } No newline at end of file }'], ['*/ package org.apache.commons.jxpath.ri.model.beans; import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.JXPathAbstractFactoryException; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathInvalidAccessException; import org.apache.commons.jxpath.ri.QName;', 'return newParent.createAttribute(context, getName()); } else { if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); } // Consider these two use cases: // 1. The parent pointer of NullPropertyPointer is // a PropertyOwnerPointer other than NullPointer. When we call', 'return pointer; } else { if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); } if (newParent instanceof PropertyOwnerPointer) { PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; newParent = pop.getPropertyPointer();', '} return string; } private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) { return new JXPathAbstractFactoryException("Factory " + factory + " reported success creating object for path: " + asPath() + " but object was null. Terminating to avoid stack recursion."); } } No newline at end of file'], ['', '', '', '}'], ['import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.JXPathAbstractFactoryException;', 'if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); }', 'if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); }', ' private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) { return new JXPathAbstractFactoryException("Factory " + factory + " reported success creating object for path: " + asPath() + " but object was null. Terminating to avoid stack recursion."); } }'], 'a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java']
['JxPath-4', 7, 7, 7, 7, [': current.toUpperCase().startsWith(lang.toUpperCase()); } protected String getLanguage() { Node n = node; while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; String attr = e.getAttribute("xml:lang"); if (attr != null && !attr.equals("")) { return attr; }', 'return null; } /** * Sets contents of the node to the specified value. If the value is', '} public Object getValue() { return stringValue(node); } private String stringValue(Node node) { int nodeType = node.getNodeType(); if (nodeType == Node.COMMENT_NODE) { String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); } if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { String text = node.getNodeValue(); return text == null ? "" : text.trim(); } if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { String text = ((ProcessingInstruction) node).getData(); return text == null ? "" : text.trim(); } NodeList list = node.getChildNodes(); StringBuffer buf = new StringBuffer(16); for (int i = 0; i < list.getLength(); i++) { Node child = list.item(i); if (child.getNodeType() == Node.TEXT_NODE) { buf.append(child.getNodeValue()); } else { buf.append(stringValue(child)); } } return buf.toString().trim(); } /**', ' public Object getValue() { if (node instanceof Element) { return ((Element) node).getTextTrim(); } if (node instanceof Comment) { String text = ((Comment) node).getText();', '} return text; } if (node instanceof Text) { return ((Text) node).getTextTrim(); } if (node instanceof CDATA) { return ((CDATA) node).getTextTrim(); } if (node instanceof ProcessingInstruction) { String text = ((ProcessingInstruction) node).getData(); if (text != null) { text = text.trim(); } return text; } return null; } public void setValue(Object value) {', '} protected String getLanguage() { Object n = node; while (n != null) { if (n instanceof Element) { Element e = (Element) n; String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); if (attr != null && !attr.equals("")) { return attr; }', 'return factory; } No newline at end of file }'], [': current.toUpperCase().startsWith(lang.toUpperCase()); } protected static String findEnclosingAttribute(Node n, String attrName) { while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; String attr = e.getAttribute(attrName); if (attr != null && !attr.equals("")) { return attr; }', 'return null; } protected String getLanguage() { return findEnclosingAttribute(node, "xml:lang"); } /** * Sets contents of the node to the specified value. If the value is', '} public Object getValue() { if (node.getNodeType() == Node.COMMENT_NODE) { String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); } return stringValue(node); } private String stringValue(Node node) { int nodeType = node.getNodeType(); if (nodeType == Node.COMMENT_NODE) { return ""; } boolean trim = !"preserve".equals(findEnclosingAttribute(node, "xml:space")); if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { String text = node.getNodeValue(); return text == null ? "" : trim ? text.trim() : text; } if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { String text = ((ProcessingInstruction) node).getData(); return text == null ? "" : trim ? text.trim() : text; } NodeList list = node.getChildNodes(); StringBuffer buf = new StringBuffer(16); for (int i = 0; i < list.getLength(); i++) { Node child = list.item(i); buf.append(stringValue(child)); } return buf.toString(); } /**', ' public Object getValue() { if (node instanceof Element) { StringBuffer buf = new StringBuffer(); for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) { NodePointer ptr = children.getNodePointer(); if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) { buf.append(ptr.getValue()); } } return buf.toString(); } if (node instanceof Comment) { String text = ((Comment) node).getText();', '} return text; } String result = null; if (node instanceof Text) { result = ((Text) node).getText(); } if (node instanceof ProcessingInstruction) { result = ((ProcessingInstruction) node).getData(); } boolean trim = !"preserve".equals(findEnclosingAttribute(node, "space", Namespace.XML_NAMESPACE)); return result != null && trim ? result.trim() : result; } public void setValue(Object value) {', '} protected String getLanguage() { return findEnclosingAttribute(node, "lang", Namespace.XML_NAMESPACE); } protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) { while (n != null) { if (n instanceof Element) { Element e = (Element) n; String attr = e.getAttributeValue(attrName, ns); if (attr != null && !attr.equals("")) { return attr; }', 'return factory; } } No newline at end of file'], ['protected String getLanguage() { Node n = node; String attr = e.getAttribute("xml:lang");', '', 'String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); return text == null ? "" : text.trim(); return text == null ? "" : text.trim(); if (child.getNodeType() == Node.TEXT_NODE) { buf.append(child.getNodeValue()); } else { } return buf.toString().trim();', 'return ((Element) node).getTextTrim();', 'return ((Text) node).getTextTrim(); } if (node instanceof CDATA) { return ((CDATA) node).getTextTrim(); String text = ((ProcessingInstruction) node).getData(); if (text != null) { text = text.trim(); } return text; return null;', 'Object n = node; String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE);', '}'], ['protected static String findEnclosingAttribute(Node n, String attrName) { String attr = e.getAttribute(attrName);', 'protected String getLanguage() { return findEnclosingAttribute(node, "xml:lang"); }', 'if (node.getNodeType() == Node.COMMENT_NODE) { String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); } return ""; boolean trim = !"preserve".equals(findEnclosingAttribute(node, "xml:space")); return text == null ? "" : trim ? text.trim() : text; return text == null ? "" : trim ? text.trim() : text; return buf.toString();', 'StringBuffer buf = new StringBuffer(); for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) { NodePointer ptr = children.getNodePointer(); if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) { buf.append(ptr.getValue()); } } return buf.toString();', 'String result = null; result = ((Text) node).getText(); result = ((ProcessingInstruction) node).getData(); boolean trim = !"preserve".equals(findEnclosingAttribute(node, "space", Namespace.XML_NAMESPACE)); return result != null && trim ? result.trim() : result;', 'return findEnclosingAttribute(node, "lang", Namespace.XML_NAMESPACE); } protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) { String attr = e.getAttributeValue(attrName, ns);', '}'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-5', 1, 1, 1, 1, ['} if (depth1 == 1) { throw new JXPathException( "Cannot compare pointers that do not belong to the same tree: \'" + p1 + "\' and \'" + p2 + "\'"); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) {'], ['} if (depth1 == 1) { return 0; } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) {'], ['throw new JXPathException( "Cannot compare pointers that do not belong to the same tree: \'" + p1 + "\' and \'" + p2 + "\'");'], ['return 0;'], 'a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java']
['JxPath-6', 1, 1, 1, 1, ['// (l == null ? "null" : l.getClass().getName()) + " " + // (r == null ? "null" : r.getClass().getName())); if (l instanceof InitialContext || l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof SelfContext) { r = ((EvalContext) r).getSingleNodePointer(); }'], ['// (l == null ? "null" : l.getClass().getName()) + " " + // (r == null ? "null" : r.getClass().getName())); if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) { r = ((EvalContext) r).getSingleNodePointer(); }'], ['if (l instanceof InitialContext || l instanceof SelfContext) { if (r instanceof InitialContext || r instanceof SelfContext) {'], ['if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) {'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java']
['JxPath-7', 11, 11, 11, 11, ['*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&gt;". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l > r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&gt;=". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l >= r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&lt;". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l < r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&lt;=". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l <= r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Base implementation of Expression for the operations "&gt;", "&gt;=", "&lt;", "&lt;=". *', 'super(args); } protected final int getPrecedence() { return 3; }', 'return false; } }'], ['*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&gt;". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare > 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&gt;=". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare >= 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&lt;". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare < 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&lt;=". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare <= 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; import org.apache.commons.jxpath.ri.axes.InitialContext; import org.apache.commons.jxpath.ri.axes.SelfContext; /** * Base implementation of Expression for the operations "&gt;", "&gt;=", "&lt;", "&lt;=". *', 'super(args); } public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1] .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; } protected final int getPrecedence() { return 3; }', 'return false; } protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right) { left = reduce(left); right = reduce(right); if (left instanceof InitialContext) { ((InitialContext) left).reset(); } if (right instanceof InitialContext) { ((InitialContext) right).reset(); } if (left instanceof Iterator && right instanceof Iterator) { return findMatch((Iterator) left, (Iterator) right); } if (left instanceof Iterator) { return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } return evaluateCompare(compare(left, right)); } private Object reduce(Object o) { if (o instanceof SelfContext) { o = ((EvalContext) o).getSingleNodePointer(); } if (o instanceof Collection) { o = ((Collection) o).iterator(); } return o; } private boolean containsMatch(Iterator it, Object value) { while (it.hasNext()) { Object element = it.next(); if (evaluateCompare(compare(element, value))) { return true; } } return false; } private boolean findMatch(Iterator lit, Iterator rit) { HashSet left = new HashSet(); while (lit.hasNext()) { left.add(lit.next()); } while (rit.hasNext()) { if (containsMatch(left.iterator(), rit.next())) { return true; } } return false; } private int compare(Object l, Object r) { double ld = InfoSetUtil.doubleValue(l); double rd = InfoSetUtil.doubleValue(r); return ld == rd ? 0 : ld < rd ? -1 : 1; } }'], ['import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l > r ? Boolean.TRUE : Boolean.FALSE;', 'import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l >= r ? Boolean.TRUE : Boolean.FALSE;', 'import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l < r ? Boolean.TRUE : Boolean.FALSE;', 'import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l <= r ? Boolean.TRUE : Boolean.FALSE;', '', '', ''], ['', 'protected boolean evaluateCompare(int compare) { return compare > 0;', '', 'protected boolean evaluateCompare(int compare) { return compare >= 0;', '', 'protected boolean evaluateCompare(int compare) { return compare < 0;', '', 'protected boolean evaluateCompare(int compare) { return compare <= 0;', 'import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; import org.apache.commons.jxpath.ri.axes.InitialContext; import org.apache.commons.jxpath.ri.axes.SelfContext;', 'public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1] .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; }', 'protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right) { left = reduce(left); right = reduce(right); if (left instanceof InitialContext) { ((InitialContext) left).reset(); } if (right instanceof InitialContext) { ((InitialContext) right).reset(); } if (left instanceof Iterator && right instanceof Iterator) { return findMatch((Iterator) left, (Iterator) right); } if (left instanceof Iterator) { return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } return evaluateCompare(compare(left, right)); } private Object reduce(Object o) { if (o instanceof SelfContext) { o = ((EvalContext) o).getSingleNodePointer(); } if (o instanceof Collection) { o = ((Collection) o).iterator(); } return o; } private boolean containsMatch(Iterator it, Object value) { while (it.hasNext()) { Object element = it.next(); if (evaluateCompare(compare(element, value))) { return true; } } return false; } private boolean findMatch(Iterator lit, Iterator rit) { HashSet left = new HashSet(); while (lit.hasNext()) { left.add(lit.next()); } while (rit.hasNext()) { if (containsMatch(left.iterator(), rit.next())) { return true; } } return false; } private int compare(Object l, Object r) { double ld = InfoSetUtil.doubleValue(l); double rd = InfoSetUtil.doubleValue(r); return ld == rd ? 0 : ld < rd ? -1 : 1; }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-8', 1, 1, 1, 1, ['return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); double rd = InfoSetUtil.doubleValue(right); return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1); }'], ['return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(right); if (Double.isNaN(rd)) { return false; } return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1); }'], [''], ['if (Double.isNaN(ld)) { return false; } if (Double.isNaN(rd)) { return false; }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-9', 7, 7, 7, 7, ['* @version $Revision$ $Date$ */ public abstract class CoreOperationCompare extends CoreOperation { public CoreOperationCompare(Expression arg1, Expression arg2) { super(new Expression[] { arg1, arg2 }); } protected int getPrecedence() {', '} protected boolean equal(Object l, Object r) { if (l instanceof Pointer && r instanceof Pointer) { if (l.equals(r)) { return true; } } if (l instanceof Pointer) { l = ((Pointer) l).getValue(); }', 'r = ((Pointer) r).getValue(); } if (l == r) { return true; } if (l instanceof Boolean || r instanceof Boolean) { return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); } //if either side is NaN, no comparison returns true: if (l instanceof Number || r instanceof Number) { return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); } if (l instanceof String || r instanceof String) { return ( InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); } return l != null && l.equals(r); } }', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; /** * Implementation of Expression for the operation "=". *', 'super(arg1, arg2); } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() { return "="; }', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; /** * Implementation of Expression for the operation "!=". *', 'public class CoreOperationNotEqual extends CoreOperationCompare { public CoreOperationNotEqual(Expression arg1, Expression arg2) { super(arg1, arg2); } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE; } public String getSymbol() { return "!="; }'], ['* @version $Revision$ $Date$ */ public abstract class CoreOperationCompare extends CoreOperation { private boolean invert; public CoreOperationCompare(Expression arg1, Expression arg2) { this(arg1, arg2, false); } protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) { super(new Expression[] { arg1, arg2 }); this.invert = invert; } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; } protected int getPrecedence() {', '} protected boolean equal(Object l, Object r) { if (l instanceof Pointer) { l = ((Pointer) l).getValue(); }', 'r = ((Pointer) r).getValue(); } boolean result; if (l instanceof Boolean || r instanceof Boolean) { result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r); } else if (l instanceof Number || r instanceof Number) { //if either side is NaN, no comparison returns true: double ld = InfoSetUtil.doubleValue(l); if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(r); if (Double.isNaN(rd)) { return false; } result = ld == rd; } else { if (l instanceof String || r instanceof String) { l = InfoSetUtil.stringValue(l); r = InfoSetUtil.stringValue(r); } result = l == r || l != null && l.equals(r); } return result ^ invert; } }', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "=". *', 'super(arg1, arg2); } public String getSymbol() { return "="; }', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "!=". *', 'public class CoreOperationNotEqual extends CoreOperationCompare { public CoreOperationNotEqual(Expression arg1, Expression arg2) { super(arg1, arg2, true); } public String getSymbol() { return "!="; }'], ['', 'if (l instanceof Pointer && r instanceof Pointer) { if (l.equals(r)) { return true; } }', 'if (l == r) { return true; } return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); //if either side is NaN, no comparison returns true: if (l instanceof Number || r instanceof Number) { return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); return ( InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); return l != null && l.equals(r);', 'import org.apache.commons.jxpath.ri.EvalContext;', 'public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; }', 'import org.apache.commons.jxpath.ri.EvalContext;', 'super(arg1, arg2); public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE; }'], ['private boolean invert; this(arg1, arg2, false); } protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) { this.invert = invert; } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;', '', 'boolean result; result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r); } else if (l instanceof Number || r instanceof Number) { //if either side is NaN, no comparison returns true: double ld = InfoSetUtil.doubleValue(l); if (Double.isNaN(ld)) { return false; double rd = InfoSetUtil.doubleValue(r); if (Double.isNaN(rd)) { return false; result = ld == rd; } else { l = InfoSetUtil.stringValue(l); r = InfoSetUtil.stringValue(r); } result = l == r || l != null && l.equals(r); return result ^ invert;', '', '', '', 'super(arg1, arg2, true);'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java']
['JxPath-10', 1, 1, 1, 1, ['} public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1].computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; }'], ['} public final Object computeValue(EvalContext context) { return compute(args[0].compute(context), args[1].compute(context)) ? Boolean.TRUE : Boolean.FALSE; }'], ['return compute(args[0].computeValue(context), args[1].computeValue(context))'], ['return compute(args[0].compute(context), args[1].compute(context))'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-11', 5, 5, 5, 5, ['import java.util.ArrayList; import java.util.List; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'String testNS = null; if (testPrefix != null) { testNS = parent.getNamespaceURI(testPrefix); } if (testNS != null) {', 'import java.util.Collections; import java.util.List; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'ns = Namespace.XML_NAMESPACE; } else { ns = element.getNamespace(prefix); if (ns == null) { // TBD: no attributes attributes = Collections.EMPTY_LIST; return; } } } else {', 'this.position = position; return position >= 1 && position <= attributes.size(); } No newline at end of file }'], ['import java.util.ArrayList; import java.util.List; import org.apache.commons.jxpath.ri.NamespaceResolver; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'String testNS = null; if (testPrefix != null) { NamespaceResolver nsr = parent.getNamespaceResolver(); testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix); testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS; } if (testNS != null) {', 'import java.util.Collections; import java.util.List; import org.apache.commons.jxpath.ri.NamespaceResolver; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'ns = Namespace.XML_NAMESPACE; } else { NamespaceResolver nsr = parent.getNamespaceResolver(); if (nsr != null) { String uri = nsr.getNamespaceURI(prefix); if (uri != null) { ns = Namespace.getNamespace(prefix, uri); } } if (ns == null) { ns = element.getNamespace(prefix); if (ns == null) { // TBD: no attributes attributes = Collections.EMPTY_LIST; return; } } } } else {', 'this.position = position; return position >= 1 && position <= attributes.size(); } } No newline at end of file'], ['', 'testNS = parent.getNamespaceURI(testPrefix);', '', '', '}'], ['import org.apache.commons.jxpath.ri.NamespaceResolver;', 'NamespaceResolver nsr = parent.getNamespaceResolver(); testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix); testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS;', 'import org.apache.commons.jxpath.ri.NamespaceResolver;', 'NamespaceResolver nsr = parent.getNamespaceResolver(); if (nsr != null) { String uri = nsr.getNamespaceURI(prefix); if (uri != null) { ns = Namespace.getNamespace(prefix, uri); } } if (ns == null) { }', '}'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java']
['JxPath-12', 1, 1, 1, 1, ['|| testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS); } return false; }'], ['|| testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; }'], ['return equalStrings(namespaceURI, nodeNS);'], ['return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));'], 'a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java']
['JxPath-13', 11, 11, 11, 11, ['* @return prefix if found * @since JXPath 1.3 */ /** * Create a new NamespaceResolver.', '* @return namespace URI or null if the prefix is undefined. */ public synchronized String getNamespaceURI(String prefix) { /** * Given a prefix, returns an externally registered namespace URI.', '* @return namespace URI or null if the prefix is undefined. * @since JXPath 1.3 */ String uri = (String) namespaceMap.get(prefix); if (uri == null && pointer != null) { uri = pointer.getNamespaceURI(prefix); } if (uri == null && parent != null) { return parent.getNamespaceURI(prefix); } return uri; } /**', '* @return String prefix */ public synchronized String getPrefix(String namespaceURI) { /** * Get the nearest prefix found that matches an externally-registered namespace.', '* @return String prefix if found. * @since JXPath 1.3 */ if (reverseMap == null) { reverseMap = new HashMap(); NodeIterator ni = pointer.namespaceIterator(); if (ni != null) { for (int position = 1; ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { reverseMap.put(uri, prefix); } } } Iterator it = namespaceMap.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = (Map.Entry) it.next();', '} } String prefix = (String) reverseMap.get(namespaceURI); if (prefix == null && parent != null) { return parent.getPrefix(namespaceURI); } return prefix; } /**', '} } No newline at end of file }', 'import org.apache.commons.jxpath.JXPathException; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest;', 'private Map namespaces; private String defaultNamespace; private String id; public static final String XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";', '/* (non-Javadoc) * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver() */ public String getNamespaceURI(String prefix) { if (prefix == null || prefix.equals("")) {', 'Element element = (Element) node; String prefix = name.getPrefix(); if (prefix != null) { String ns = getNamespaceURI(prefix); if (ns == null) { throw new JXPathException( "Unknown namespace prefix: " + prefix);'], ['* @return prefix if found * @since JXPath 1.3 */ protected static String getPrefix(NodePointer pointer, String namespaceURI) { NodePointer currentPointer = pointer; while (currentPointer != null) { NodeIterator ni = currentPointer.namespaceIterator(); for (int position = 1; ni != null && ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); if (uri.equals(namespaceURI)) { String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { return prefix; } } } currentPointer = pointer.getParent(); } return null; } /** * Create a new NamespaceResolver.', '* @return namespace URI or null if the prefix is undefined. */ public synchronized String getNamespaceURI(String prefix) { String uri = getExternallyRegisteredNamespaceURI(prefix); return uri == null && pointer != null ? pointer.getNamespaceURI(prefix) : uri; } /** * Given a prefix, returns an externally registered namespace URI.', '* @return namespace URI or null if the prefix is undefined. * @since JXPath 1.3 */ protected synchronized String getExternallyRegisteredNamespaceURI( String prefix) { String uri = (String) namespaceMap.get(prefix); return uri == null && parent != null ? parent .getExternallyRegisteredNamespaceURI(prefix) : uri; } /**', '* @return String prefix */ public synchronized String getPrefix(String namespaceURI) { String prefix = getExternallyRegisteredPrefix(namespaceURI); return prefix == null && pointer != null ? getPrefix(pointer, namespaceURI) : prefix; } /** * Get the nearest prefix found that matches an externally-registered namespace.', '* @return String prefix if found. * @since JXPath 1.3 */ protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) { if (reverseMap == null) { reverseMap = new HashMap(); Iterator it = namespaceMap.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = (Map.Entry) it.next();', '} } String prefix = (String) reverseMap.get(namespaceURI); return prefix == null && parent != null ? parent .getExternallyRegisteredPrefix(namespaceURI) : prefix; } /**', '} } } No newline at end of file', 'import org.apache.commons.jxpath.JXPathException; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.NamespaceResolver; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest;', 'private Map namespaces; private String defaultNamespace; private String id; private NamespaceResolver localNamespaceResolver; public static final String XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";', '/* (non-Javadoc) * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver() */ public synchronized NamespaceResolver getNamespaceResolver() { if (localNamespaceResolver == null) { localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver()); localNamespaceResolver.setNamespaceContextPointer(this); } return localNamespaceResolver; } public String getNamespaceURI(String prefix) { if (prefix == null || prefix.equals("")) {', 'Element element = (Element) node; String prefix = name.getPrefix(); if (prefix != null) { String ns = null; NamespaceResolver nsr = getNamespaceResolver(); if (nsr != null) { ns = nsr.getNamespaceURI(prefix); } if (ns == null) { throw new JXPathException( "Unknown namespace prefix: " + prefix);'], ['', '', 'if (uri == null && pointer != null) { uri = pointer.getNamespaceURI(prefix); } if (uri == null && parent != null) { return parent.getNamespaceURI(prefix); } return uri;', '', 'NodeIterator ni = pointer.namespaceIterator(); if (ni != null) { for (int position = 1; ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { reverseMap.put(uri, prefix); } } }', 'if (prefix == null && parent != null) { return parent.getPrefix(namespaceURI); } return prefix;', '}', '', '', '', 'String ns = getNamespaceURI(prefix);'], ['protected static String getPrefix(NodePointer pointer, String namespaceURI) { NodePointer currentPointer = pointer; while (currentPointer != null) { NodeIterator ni = currentPointer.namespaceIterator(); for (int position = 1; ni != null && ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); if (uri.equals(namespaceURI)) { String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { return prefix; } } } currentPointer = pointer.getParent(); } return null; }', 'String uri = getExternallyRegisteredNamespaceURI(prefix); return uri == null && pointer != null ? pointer.getNamespaceURI(prefix) : uri; }', 'protected synchronized String getExternallyRegisteredNamespaceURI( String prefix) { return uri == null && parent != null ? parent .getExternallyRegisteredNamespaceURI(prefix) : uri;', 'String prefix = getExternallyRegisteredPrefix(namespaceURI); return prefix == null && pointer != null ? getPrefix(pointer, namespaceURI) : prefix; }', 'protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {', 'return prefix == null && parent != null ? parent .getExternallyRegisteredPrefix(namespaceURI) : prefix;', '}', 'import org.apache.commons.jxpath.ri.NamespaceResolver;', 'private NamespaceResolver localNamespaceResolver;', 'public synchronized NamespaceResolver getNamespaceResolver() { if (localNamespaceResolver == null) { localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver()); localNamespaceResolver.setNamespaceContextPointer(this); } return localNamespaceResolver; }', 'String ns = null; NamespaceResolver nsr = getNamespaceResolver(); if (nsr != null) { ns = nsr.getNamespaceURI(prefix); }'], 'a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java']
['JxPath-14', 1, 1, 1, 1, ['protected Object functionFloor(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); return new Double(Math.round(v)); }'], ['protected Object functionFloor(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.round(v)); }'], [''], ['if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java']
['JxPath-15', 2, 2, 2, 2, ['package org.apache.commons.jxpath.ri.axes; import java.util.ArrayList; import org.apache.commons.jxpath.BasicNodeSet; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'while (ctx.nextNode()) { NodePointer ptr = ctx.getCurrentNodePointer(); if (!pointers.contains(ptr)) { nodeSet.add(ptr); pointers.add(ptr); } } } } } return super.setPosition(position); } No newline at end of file }'], ['package org.apache.commons.jxpath.ri.axes; import java.util.ArrayList; import java.util.Iterator; import org.apache.commons.jxpath.BasicNodeSet; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'while (ctx.nextNode()) { NodePointer ptr = ctx.getCurrentNodePointer(); if (!pointers.contains(ptr)) { pointers.add(ptr); } } } } sortPointers(pointers); for (Iterator it = pointers.iterator(); it.hasNext();) { nodeSet.add((Pointer) it.next()); } } return super.setPosition(position); } } No newline at end of file'], ['', 'nodeSet.add(ptr); }'], ['import java.util.Iterator; import org.apache.commons.jxpath.Pointer;', 'sortPointers(pointers); for (Iterator it = pointers.iterator(); it.hasNext();) { nodeSet.add((Pointer) it.next()); } }'], 'a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java', 'b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java']
['JxPath-16', 2, 2, 2, 2, ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return true; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return true; case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;', 'return (node instanceof Element) || (node instanceof Document);'], ['return true;', 'return true;'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-17', 5, 5, 5, 5, ['if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { String testPrefix = name.getPrefix(); if (equalStrings(testPrefix, nodePrefix)) { return true; } String testNS = null; if (testPrefix != null) { testNS = parent.getNamespaceURI(testPrefix); } String nodeNS = null; if (nodePrefix != null) { nodeNS = parent.getNamespaceURI(nodePrefix); } return equalStrings(testNS, nodeNS); } return false; }', 'this.position = position; return position >= 1 && position <= attributes.size(); } No newline at end of file }', 'String lname = name.getName(); if (!lname.equals("*")) { attributes = new ArrayList(); if (ns != null) { Attribute attr = element.getAttribute(lname, ns); if (attr != null) { attributes.add(attr); } } } else {', 'List allAttributes = element.getAttributes(); for (int i = 0; i < allAttributes.size(); i++) { Attribute attr = (Attribute) allAttributes.get(i); if (attr.getNamespace().equals(ns)) { attributes.add(attr); } }', 'this.position = position; return position >= 1 && position <= attributes.size(); } No newline at end of file }'], ['if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { String testPrefix = name.getPrefix(); if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) { return true; } if (nodePrefix == null) { return false; } return equalStrings(parent.getNamespaceURI(testPrefix), parent .getNamespaceURI(nodePrefix)); } return false; }', 'this.position = position; return position >= 1 && position <= attributes.size(); } } No newline at end of file', 'String lname = name.getName(); if (!lname.equals("*")) { attributes = new ArrayList(); Attribute attr = element.getAttribute(lname, ns); if (attr != null) { attributes.add(attr); } } else {', 'List allAttributes = element.getAttributes(); for (int i = 0; i < allAttributes.size(); i++) { Attribute attr = (Attribute) allAttributes.get(i); if (ns == Namespace.NO_NAMESPACE || attr.getNamespace().equals(ns)) { attributes.add(attr); } }', 'this.position = position; return position >= 1 && position <= attributes.size(); } } No newline at end of file'], ['if (equalStrings(testPrefix, nodePrefix)) { String testNS = null; if (testPrefix != null) { testNS = parent.getNamespaceURI(testPrefix); String nodeNS = null; if (nodePrefix != null) { nodeNS = parent.getNamespaceURI(nodePrefix); } return equalStrings(testNS, nodeNS);', '}', 'if (ns != null) { }', 'if (attr.getNamespace().equals(ns)) {', '}'], ['if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) { if (nodePrefix == null) { return false; return equalStrings(parent.getNamespaceURI(testPrefix), parent .getNamespaceURI(nodePrefix));', '}', '', 'if (ns == Namespace.NO_NAMESPACE || attr.getNamespace().equals(ns)) {', '}'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java']
['JxPath-18', 4, 4, 4, 4, ['*/ package org.apache.commons.jxpath.ri.axes; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', '* @version $Revision$ $Date$ */ public class AttributeContext extends EvalContext { private NodeTest nodeTest; private boolean setStarted = false;', 'super.setPosition(getCurrentPosition() + 1); if (!setStarted) { setStarted = true; if (!(nodeTest instanceof NodeNameTest)) { return false; } QName name = ((NodeNameTest) nodeTest).getNodeName(); iterator = parentContext.getCurrentNodePointer().attributeIterator(name); } if (iterator == null) { return false;', 'currentNodePointer = iterator.getNodePointer(); return true; } No newline at end of file }'], ['*/ package org.apache.commons.jxpath.ri.axes; import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest; import org.apache.commons.jxpath.ri.compiler.NodeTypeTest; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', '* @version $Revision$ $Date$ */ public class AttributeContext extends EvalContext { private static final NodeNameTest WILDCARD_TEST = new NodeNameTest(new QName(null, "*")); private NodeTest nodeTest; private boolean setStarted = false;', 'super.setPosition(getCurrentPosition() + 1); if (!setStarted) { setStarted = true; NodeNameTest nodeNameTest = null; if (nodeTest instanceof NodeTypeTest) { if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { nodeNameTest = WILDCARD_TEST; } } else if (nodeTest instanceof NodeNameTest) { nodeNameTest = (NodeNameTest) nodeTest; } if (nodeNameTest == null) { return false; } iterator = parentContext.getCurrentNodePointer().attributeIterator( nodeNameTest.getNodeName()); } if (iterator == null) { return false;', 'currentNodePointer = iterator.getNodePointer(); return true; } } No newline at end of file'], ['', '', 'if (!(nodeTest instanceof NodeNameTest)) { QName name = ((NodeNameTest) nodeTest).getNodeName(); iterator = parentContext.getCurrentNodePointer().attributeIterator(name);', '}'], ['import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;', 'private static final NodeNameTest WILDCARD_TEST = new NodeNameTest(new QName(null, "*"));', 'NodeNameTest nodeNameTest = null; if (nodeTest instanceof NodeTypeTest) { if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { nodeNameTest = WILDCARD_TEST; } } else if (nodeTest instanceof NodeNameTest) { nodeNameTest = (NodeNameTest) nodeTest; } if (nodeNameTest == null) { iterator = parentContext.getCurrentNodePointer().attributeIterator( nodeNameTest.getNodeName());', '}'], 'a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java', 'b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java']
['JxPath-19', 3, 3, 3, 3, ['int count = 1; Node n = node.getPreviousSibling(); while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE) { String nm = n.getNodeName(); if (nm.equals(node.getNodeName())) { count++; } } n = n.getPreviousSibling(); } return count; } /** * Get relative position of this among all siblings.', 'String name = ((Element) node).getQualifiedName(); for (int i = 0; i < children.size(); i++) { Object child = children.get(i); if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) { count++; } if (child == node) {', 'return 1; } /** * Get relative position of this among all siblings.'], ['int count = 1; Node n = node.getPreviousSibling(); while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) { count++; } n = n.getPreviousSibling(); } return count; } private boolean matchesQName(Node n) { if (getNamespaceURI() != null) { return equalStrings(getNamespaceURI(n), getNamespaceURI()) && equalStrings(node.getLocalName(), n.getLocalName()); } return equalStrings(node.getNodeName(), n.getNodeName()); } /** * Get relative position of this among all siblings.', 'String name = ((Element) node).getQualifiedName(); for (int i = 0; i < children.size(); i++) { Object child = children.get(i); if (child instanceof Element && matchesQName(((Element) child))) { count++; } if (child == node) {', 'return 1; } private boolean matchesQName(Element element) { if (getNamespaceURI() != null) { String ns = getNamespaceURI(element); if (ns == null || !ns.equals(getNamespaceURI())) { return false; } } return element.getName().equals(((Element) node).getName()); } /** * Get relative position of this among all siblings.'], ['if (n.getNodeType() == Node.ELEMENT_NODE) { String nm = n.getNodeName(); if (nm.equals(node.getNodeName())) { }', 'if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {', ''], ['if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) { private boolean matchesQName(Node n) { if (getNamespaceURI() != null) { return equalStrings(getNamespaceURI(n), getNamespaceURI()) && equalStrings(node.getLocalName(), n.getLocalName()); } return equalStrings(node.getNodeName(), n.getNodeName()); }', 'if (child instanceof Element && matchesQName(((Element) child))) {', 'private boolean matchesQName(Element element) { if (getNamespaceURI() != null) { String ns = getNamespaceURI(element); if (ns == null || !ns.equals(getNamespaceURI())) { return false; } } return element.getName().equals(((Element) node).getName()); }'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-20', 2, 2, 2, 2, ['return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); if (Double.isNaN(ld)) {', '* @param value to look for * @return whether a match was found */ /** * Learn whether there is an intersection between two Iterators.'], ['return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch(left, (Iterator) right); } double ld = InfoSetUtil.doubleValue(left); if (Double.isNaN(ld)) {', '* @param value to look for * @return whether a match was found */ private boolean containsMatch(Object value, Iterator it) { while (it.hasNext()) { Object element = it.next(); if (compute(value, element)) { return true; } } return false; } /** * Learn whether there is an intersection between two Iterators.'], ['return containsMatch((Iterator) right, left);', ''], ['return containsMatch(left, (Iterator) right);', 'private boolean containsMatch(Object value, Iterator it) { while (it.hasNext()) { Object element = it.next(); if (compute(value, element)) { return true; } } return false; }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-21', 1, 1, 1, 1, ['* @return int length */ public int getLength() { return ValueUtils.getLength(getBaseValue()); } /**'], ['* @return int length */ public int getLength() { Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue); } /**'], ['return ValueUtils.getLength(getBaseValue());'], ['Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue);'], 'a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java']
['JxPath-22', 1, 1, 1, 1, ['if (aNode.getNodeType() == Node.ELEMENT_NODE) { Attr attr = ((Element) aNode).getAttributeNode(qname); if (attr != null) { return attr.getValue(); } } aNode = aNode.getParentNode(); } return null; } return uri; } public Object getValue() {'], ['if (aNode.getNodeType() == Node.ELEMENT_NODE) { Attr attr = ((Element) aNode).getAttributeNode(qname); if (attr != null) { uri = attr.getValue(); break; } } aNode = aNode.getParentNode(); } } return "".equals(uri) ? null : uri; } public Object getValue() {'], ['return attr.getValue(); return null; return uri;'], ['uri = attr.getValue(); break; return "".equals(uri) ? null : uri;'], 'a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java']
['Time-1', 2, 2, 2, 2, ['DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " +', '* @return zero always */ public int compareTo(DurationField durationField) { if (durationField.isSupported()) { return 1; } return 0; }'], ['DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { if (loopUnitField.isSupported() == false) { if (lastUnitField.isSupported()) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else { throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); } } int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " +', '* @return zero always */ public int compareTo(DurationField durationField) { return 0; }'], ['} else if (compare == 0) {', 'if (durationField.isSupported()) { return 1; }'], ['if (loopUnitField.isSupported() == false) { if (lastUnitField.isSupported()) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else { throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); } } } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {', ''], 'a/src/main/java/org/joda/time/field/UnsupportedDurationField.java', 'b/src/main/java/org/joda/time/field/UnsupportedDurationField.java']
['Time-2', 3, 3, 3, 3, ['DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) {', 'if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) {', '* @return zero always */ public int compareTo(DurationField durationField) { return 0; }'], ['DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) {', 'if (compare > 0) { break; } else if (compare == 0) { if (fieldType.getRangeDurationType() == null) { break; } DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) {', '* @return zero always */ public int compareTo(DurationField durationField) { if (durationField.isSupported()) { return 1; } return 0; }'], ['if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {', '', ''], ['if (compare < 0) {', 'if (fieldType.getRangeDurationType() == null) { break; }', 'if (durationField.isSupported()) { return 1; }'], 'a/src/main/java/org/joda/time/field/UnsupportedDurationField.java', 'b/src/main/java/org/joda/time/field/UnsupportedDurationField.java']
['Time-3', 10, 10, 10, 10, ['if (type == null) { throw new IllegalArgumentException("Field must not be null"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } //-----------------------------------------------------------------------'], ['if (type == null) { throw new IllegalArgumentException("Field must not be null"); } if (amount != 0) { setMillis(type.getField(getChronology()).add(getMillis(), amount)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addYears(final int years) { if (years != 0) { setMillis(getChronology().years().add(getMillis(), years)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeekyears(final int weekyears) { if (weekyears != 0) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMonths(final int months) { if (months != 0) { setMillis(getChronology().months().add(getMillis(), months)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeeks(final int weeks) { if (weeks != 0) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addDays(final int days) { if (days != 0) { setMillis(getChronology().days().add(getMillis(), days)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addHours(final int hours) { if (hours != 0) { setMillis(getChronology().hours().add(getMillis(), hours)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMinutes(final int minutes) { if (minutes != 0) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addSeconds(final int seconds) { if (seconds != 0) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMillis(final int millis) { if (millis != 0) { setMillis(getChronology().millis().add(getMillis(), millis)); } } //-----------------------------------------------------------------------'], ['', '', '', '', '', '', '', '', '', ''], ['if (amount != 0) { }', 'if (years != 0) { }', 'if (weekyears != 0) { }', 'if (months != 0) { }', 'if (weeks != 0) { }', 'if (days != 0) { }', 'if (hours != 0) { }', 'if (minutes != 0) { }', 'if (seconds != 0) { }', 'if (millis != 0) { }'], 'a/src/main/java/org/joda/time/MutableDateTime.java', 'b/src/main/java/org/joda/time/MutableDateTime.java']
['Time-4', 1, 1, 1, 1, ["System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe Partial newPartial = new Partial(iChronology, newTypes, newValues); iChronology.validate(newPartial, newValues); return newPartial; }"], ["System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; }"], ['Partial newPartial = new Partial(iChronology, newTypes, newValues);'], ['Partial newPartial = new Partial(newTypes, newValues, iChronology);'], 'a/src/main/java/org/joda/time/Partial.java', 'b/src/main/java/org/joda/time/Partial.java']
['Time-5', 1, 1, 1, 1, ['int years = getYears(); int months = getMonths(); if (years != 0 || months != 0) { years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months); } } return result;'], ['int years = getYears(); int months = getMonths(); if (years != 0 || months != 0) { long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); } if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); } } return result;'], ['years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); if (months != 0) { result = result.withMonths(months);'], ['long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString());'], 'a/src/main/java/org/joda/time/Period.java', 'b/src/main/java/org/joda/time/Period.java']
['Time-6', 3, 3, 3, 3, ['cutoverInstant = DEFAULT_CUTOVER; } else { cutoverInstant = gregorianCutover.toInstant(); } GJChronology chrono;', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } }', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } }'], ['cutoverInstant = DEFAULT_CUTOVER; } else { cutoverInstant = gregorianCutover.toInstant(); LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); if (cutoverDate.getYear() <= 0) { throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); } } GJChronology chrono;', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } } instant = gregorianToJulian(instant); } }', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } } instant = gregorianToJulian(instant); } }'], ['', '', ''], ['LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); if (cutoverDate.getYear() <= 0) { throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); }', 'if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } }', 'if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } }'], 'a/src/main/java/org/joda/time/chrono/GJChronology.java', 'b/src/main/java/org/joda/time/chrono/GJChronology.java']
['Time-7', 1, 1, 1, 1, [' long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear);'], [' long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear);'], ['int defaultYear = chrono.year().get(instantLocal);'], ['int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);'], 'a/src/main/java/org/joda/time/format/DateTimeFormatter.java', 'b/src/main/java/org/joda/time/format/DateTimeFormatter.java']
['Time-8', 1, 1, 1, 1, ['if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; }'], ['if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - Math.abs(minutesOffset); } else { minutesOffset = hoursInMinutes + minutesOffset; }'], ['if (minutesOffset < 0 || minutesOffset > 59) { minutesOffset = hoursInMinutes - minutesOffset;'], ['if (minutesOffset < -59 || minutesOffset > 59) { if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); } minutesOffset = hoursInMinutes - Math.abs(minutesOffset);'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-9', 3, 3, 3, 3, ['/** The time zone for Universal Coordinated Time */ public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0); /** Maximum offset. */ /** The instance that is providing time zones. */ private static Provider cProvider;', 'if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) {', '* @return the DateTimeZone object for the offset */ public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); }'], ['/** The time zone for Universal Coordinated Time */ public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0); /** Maximum offset. */ private static final int MAX_MILLIS = (86400 * 1000) - 1; /** The instance that is providing time zones. */ private static Provider cProvider;', 'if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) {', '* @return the DateTimeZone object for the offset */ public static DateTimeZone forOffsetMillis(int millisOffset) { if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); } String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); }'], ['', 'int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);', ''], ['private static final int MAX_MILLIS = (86400 * 1000) - 1;', 'if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } int hoursInMinutes = hoursOffset * 60; minutesOffset = hoursInMinutes - minutesOffset; minutesOffset = hoursInMinutes + minutesOffset;', 'if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); }'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-10', 2, 2, 2, 2, ['/** Serialization version. */ private static final long serialVersionUID = 9386874258972L; /** The start of 1972. */ /** The period in the units of this period. */ private volatile int iPeriod;', 'throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); } Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L)); return values[0]; }'], ['/** Serialization version. */ private static final long serialVersionUID = 9386874258972L; /** The start of 1972. */ private static final long START_1972 = 2L * 365L * 86400L * 1000L; /** The period in the units of this period. */ private volatile int iPeriod;', 'throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); } Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972)); return values[0]; }'], ['', 'int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));'], ['private static final long START_1972 = 2L * 365L * 86400L * 1000L;', 'int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));'], 'a/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java', 'b/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java']
['Time-11', 1, 1, 1, 1, [' static Chronology cLenientISO; static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } /** * Gets a flag indicating that verbose logging is required.'], [' static Chronology cLenientISO; static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } }; /** * Gets a flag indicating that verbose logging is required.'], ['static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }'], ['static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } };'], 'a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java', 'b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java']
['Time-12', 4, 4, 4, 4, ['if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) );', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } // handle years in era BC return new LocalDate( date.getYear() + 1900, date.getMonth() + 1,', 'if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY),', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } // handle years in era BC return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,'], ['if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) );', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } if (date.getTime() < 0) { // handle years in era BC GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1,', 'if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY),', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } if (date.getTime() < 0) { // handle years in era BC GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,'], ['yearOfEra,', '', 'yearOfEra,', ''], ['int era = calendar.get(Calendar.ERA); (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),', 'if (date.getTime() < 0) { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); }', 'int era = calendar.get(Calendar.ERA); (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),', 'if (date.getTime() < 0) { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); }'], 'a/src/main/java/org/joda/time/LocalDateTime.java', 'b/src/main/java/org/joda/time/LocalDateTime.java']
['Time-13', 3, 3, 3, 3, ['if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative sum = Math.max(sum, 4); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS &&', 'if (iPrefix != null) { iPrefix.printTo(buf, value); } int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value);', "if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"], ['if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS &&', 'if (iPrefix != null) { iPrefix.printTo(buf, value); } int bufLen = buf.length(); int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value);', "if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { buf.insert(bufLen, '-'); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"], ['sum = Math.max(sum, 4);', '', ''], ['sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));', 'int bufLen = buf.length();', "if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { buf.insert(bufLen, '-'); }"], 'a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java', 'b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java']
['Time-14', 1, 1, 1, 1, ['if (valueToAdd == 0) { return values; } // month is largest field and being added to, such as month-day if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {'], ['if (valueToAdd == 0) { return values; } if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); } if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {'], [''], ['if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); }'], 'a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java', 'b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java']
['Time-15', 1, 1, 1, 1, ['public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: return -val1; case 0: return 0L;'], ['public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: if (val1 == Long.MIN_VALUE) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return -val1; case 0: return 0L;'], [''], ['if (val1 == Long.MIN_VALUE) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); }'], 'a/src/main/java/org/joda/time/field/FieldUtils.java', 'b/src/main/java/org/joda/time/field/FieldUtils.java']
['Time-16', 1, 1, 1, 1, ['chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {'], ['chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal)); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {'], ['instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);'], ['instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));'], 'a/src/main/java/org/joda/time/format/DateTimeFormatter.java', 'b/src/main/java/org/joda/time/format/DateTimeFormatter.java']
['Time-17', 1, 1, 1, 1, ['// a bit messy, but will work in all non-pathological cases // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore); // calculate result // currently in later offset // currently in earlier offset } // System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));'], ['// a bit messy, but will work in all non-pathological cases // evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } // calculate result long afterStart = instant - overlapStart; if (afterStart >= diff) { // currently in later offset return earlierOrLater ? instant : instant - diff; } else { // currently in earlier offset return earlierOrLater ? instant + diff : instant; } } // System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));'], ['long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);'], ['long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; }'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-18', 1, 1, 1, 1, [" // Assume date is Gregorian. long instant; instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant < iCutoverMillis) { // Maybe it's Julian. instant = iJulianChronology.getDateTimeMillis"], [" // Assume date is Gregorian. long instant; try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } } if (instant < iCutoverMillis) { // Maybe it's Julian. instant = iJulianChronology.getDateTimeMillis"], [''], ['try { } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } }'], 'a/src/main/java/org/joda/time/chrono/GJChronology.java', 'b/src/main/java/org/joda/time/chrono/GJChronology.java']
['Time-19', 1, 1, 1, 1, ['return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);'], ['return offsetLocal; } } } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);'], ['} else if (offsetLocal > 0) {'], ['} else if (offsetLocal >= 0) {'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-20', 1, 1, 1, 1, [' public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); for (String id : ALL_IDS) { if (str.startsWith(id)) { bucket.setZone(DateTimeZone.forID(id)); return position + id.length(); } } return ~position; } }'], [' public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { if (best == null || id.length() > best.length()) { best = id; } } } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); } return ~position; } }'], ['bucket.setZone(DateTimeZone.forID(id)); return position + id.length();'], ['String best = null; if (best == null || id.length() > best.length()) { best = id; } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); }'], 'a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java', 'b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java']
['Time-21', 1, 1, 1, 1, ['if (byNameKeyCache == null) { byIdCache.put(id, byNameKeyCache = createCache()); String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings; byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending "-Summer", cf ZoneInfoCompiler if (setLoc[2].equals(setLoc[4])) { byNameKeyCache.put(setLoc[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); } else { byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); } break; } } }'], ['if (byNameKeyCache == null) { byIdCache.put(id, byNameKeyCache = createCache()); String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); String[] setEn = null; for (String[] strings : zoneStringsEn) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setEn = strings; break; } } String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings; break; } } if (setEn != null && setLoc != null) { byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending "-Summer", cf ZoneInfoCompiler if (setEn[2].equals(setEn[4])) { byNameKeyCache.put(setEn[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); } else { byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]}); } } }'], ['byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); if (setLoc[2].equals(setLoc[4])) { byNameKeyCache.put(setLoc[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); } break;'], ['String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); String[] setEn = null; for (String[] strings : zoneStringsEn) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setEn = strings; break; } } break; } } if (setEn != null && setLoc != null) { byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]}); if (setEn[2].equals(setEn[4])) { byNameKeyCache.put(setEn[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});'], 'a/src/main/java/org/joda/time/tz/DefaultNameProvider.java', 'b/src/main/java/org/joda/time/tz/DefaultNameProvider.java']
['Time-22', 1, 1, 1, 1, ['* @param duration the duration, in milliseconds */ protected BasePeriod(long duration) { this(duration, null, null); // bug [3264409] } /**'], ['* @param duration the duration, in milliseconds */ protected BasePeriod(long duration) { super(); // bug [3264409] iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4); } /**'], ['this(duration, null, null);'], ['super(); iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4);'], 'a/src/main/java/org/joda/time/base/BasePeriod.java', 'b/src/main/java/org/joda/time/base/BasePeriod.java']
['Time-23', 2, 2, 2, 2, ['// Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put("GMT", "UTC"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu"); // JDK 1.1 compatible map.put("AST", "America/Anchorage");', 'map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York"); // JDK 1.1 compatible map.put("IET", "America/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("WET", "Europe/London"); map.put("ECT", "Europe/Paris"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EET", "Europe/Bucharest"); map.put("EAT", "Africa/Addis_Ababa"); map.put("MET", "Asia/Tehran"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Calcutta"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Saigon"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin");'], ['// Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put("GMT", "UTC"); map.put("WET", "WET"); map.put("CET", "CET"); map.put("MET", "CET"); map.put("ECT", "CET"); map.put("EET", "EET"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu"); // JDK 1.1 compatible map.put("AST", "America/Anchorage");', 'map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York"); // JDK 1.1 compatible map.put("IET", "America/Indiana/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Argentina/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EAT", "Africa/Addis_Ababa"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Kolkata"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Ho_Chi_Minh"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin");'], ['', 'map.put("IET", "America/Indianapolis"); map.put("AGT", "America/Buenos_Aires"); map.put("WET", "Europe/London"); map.put("ECT", "Europe/Paris"); map.put("EET", "Europe/Bucharest"); map.put("MET", "Asia/Tehran"); map.put("IST", "Asia/Calcutta"); map.put("VST", "Asia/Saigon");'], ['map.put("WET", "WET"); map.put("CET", "CET"); map.put("MET", "CET"); map.put("ECT", "CET"); map.put("EET", "EET");', 'map.put("IET", "America/Indiana/Indianapolis"); map.put("AGT", "America/Argentina/Buenos_Aires"); map.put("IST", "Asia/Kolkata"); map.put("VST", "Asia/Ho_Chi_Minh");'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-24', 1, 1, 1, 1, ['for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage("Cannot parse \\"" + text + \'"\');'], ['for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage("Cannot parse \\"" + text + \'"\');'], [''], ['if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } }'], 'a/src/main/java/org/joda/time/format/DateTimeParserBucket.java', 'b/src/main/java/org/joda/time/format/DateTimeParserBucket.java']
['Time-25', 1, 1, 1, 1, ['return offsetLocal; } } } return offsetAdjusted; }'], ['return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }'], [''], ['} else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } }'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-26', 8, 8, 8, 8, ['* @throws IllegalArgumentException if the zone has no equivalent local time * @since 2.0 */ /** * Converts a local instant to a standard UTC instant with the same', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), "Illegal instant due to time zone offset transition: " +', '// cannot verify that new value stuck because set may be lenient long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) {', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } }', 'long localInstant = iBase.getZone().convertUTCToLocal(instant); long difference = FieldUtils.safeSubtract(value, get(instant)); localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); return iBase.getZone().convertLocalToUTC(localInstant, false); } }'], ['* @throws IllegalArgumentException if the zone has no equivalent local time * @since 2.0 */ public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } /** * Converts a local instant to a standard UTC instant with the same', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false, instant); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false, instant); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false, instant); } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false, instant); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), "Illegal instant due to time zone offset transition: " +', '// cannot verify that new value stuck because set may be lenient long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false, instant); } public int getDifference(long minuendInstant, long subtrahendInstant) {', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false, instant); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false, instant); } }', 'long localInstant = iBase.getZone().convertUTCToLocal(instant); long difference = FieldUtils.safeSubtract(value, get(instant)); localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); return iBase.getZone().convertLocalToUTC(localInstant, false, instant); } }'], ['', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false); long result = iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iBase.getZone().convertLocalToUTC(localInstant, false);'], ['public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); }', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant); long result = iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iBase.getZone().convertLocalToUTC(localInstant, false, instant);'], 'a/src/main/java/org/joda/time/field/LenientDateTimeField.java', 'b/src/main/java/org/joda/time/field/LenientDateTimeField.java']
['Time-27', 1, 1, 1, 1, ['int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); } Object[] comp = createComposite(elementPairs); if (notPrinter) {'], ['int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); } } Object[] comp = createComposite(elementPairs); if (notPrinter) {'], [''], ['if (sep.iAfterParser == null && sep.iAfterPrinter == null) { }'], 'a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java', 'b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java']
['JacksonCore-1', 3, 3, 3, 3, [' public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException { return new BigDecimal(numStr); } public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {', 'public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException { return new BigDecimal(buffer, offset, len); } }', "return NumberInput.parseBigDecimal(_resultArray); } // Or a shared buffer? if (_inputStart >= 0) { return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen); } // Or if not, just a single buffer (the usual case) if (_segmentSize == 0) { return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize); } // If not, let's just get it aggregated..."], [' public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException { try { return new BigDecimal(numStr); } catch (NumberFormatException e) { throw _badBigDecimal(numStr); } } public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {', 'public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException { try { return new BigDecimal(buffer, offset, len); } catch (NumberFormatException e) { throw _badBigDecimal(new String(buffer, offset, len)); } } private static NumberFormatException _badBigDecimal(String str) { return new NumberFormatException("Value \\""+str+"\\" can not be represented as BigDecimal"); } }', "return NumberInput.parseBigDecimal(_resultArray); } // Or a shared buffer? if ((_inputStart >= 0) && (_inputBuffer != null)) { return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen); } // Or if not, just a single buffer (the usual case) if ((_segmentSize == 0) && (_currentSegment != null)) { return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize); } // If not, let's just get it aggregated..."], ['', '', 'if (_inputStart >= 0) { if (_segmentSize == 0) {'], ['try { } catch (NumberFormatException e) { throw _badBigDecimal(numStr); }', 'try { } catch (NumberFormatException e) { throw _badBigDecimal(new String(buffer, offset, len)); } private static NumberFormatException _badBigDecimal(String str) { return new NumberFormatException("Value \\""+str+"\\" can not be represented as BigDecimal"); }', 'if ((_inputStart >= 0) && (_inputBuffer != null)) { if ((_segmentSize == 0) && (_currentSegment != null)) {'], 'a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java', 'b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java']
['JacksonCore-2', 8, 8, 8, 8, ['--ptr; // need to push back following separator _inputPtr = ptr; // As per #105, need separating space between root values; check here int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen);', '// Ok; unless we hit end-of-input, need to push last char read back if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); // And there we have it!', '* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ // caller had pushed it back, before calling; reset /* /**********************************************************', '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here // And there we have it! return resetInt(negative, intLen);', '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here // And there we have it! return resetInt(negative, intPartLength);', 'if (!eof) { --_inputPtr; // As per #105, need separating space between root values; check here } _textBuffer.setCurrentLength(outPtr);', '* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ // caller had pushed it back, before calling; reset // TODO? Handle UTF-8 char decoding for error reporting /* /**********************************************************', '} break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } }'], ['--ptr; // need to push back following separator _inputPtr = ptr; // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen);', '// Ok; unless we hit end-of-input, need to push last char read back if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); // And there we have it!', "* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ private final void _verifyRootSpace(int ch) throws IOException { // caller had pushed it back, before calling; reset ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } /* /**********************************************************", '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(c); } // And there we have it! return resetInt(negative, intLen);', '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } // And there we have it! return resetInt(negative, intPartLength);', 'if (!eof) { --_inputPtr; // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr);', "* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ private final void _verifyRootSpace(int ch) throws IOException { // caller had pushed it back, before calling; reset ++_inputPtr; // TODO? Handle UTF-8 char decoding for error reporting switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } /* /**********************************************************", '} break; default: // e.g. -1 _reportInvalidChar(i); } }'], ['', '', '', '', '', '', '', 'if (i < 32) { _throwInvalidSpace(i); }'], ['if (_parsingContext.inRoot()) { _verifyRootSpace(ch); }', 'if (_parsingContext.inRoot()) { _verifyRootSpace(c); }', "private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }", 'if (_parsingContext.inRoot()) { _verifyRootSpace(c); }', 'if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); }', 'if (_parsingContext.inRoot()) { _verifyRootSpace(c); }', "private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }", ''], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-3', 1, 1, 1, 1, ['_inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = bufferRecyclable; }'], ['_inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _currInputRowStart = start; // If we have offset, need to omit that from byte offset, so: _currInputProcessed = -start; _bufferRecyclable = bufferRecyclable; }'], [''], ['_currInputRowStart = start; _currInputProcessed = -start;'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-4', 1, 1, 1, 1, ["final char[] curr = _currentSegment; // Let's grow by 50% by default final int len = curr.length; // but above intended maximum, slow to increase by 25% int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); return (_currentSegment = Arrays.copyOf(curr, newLen)); }"], ["final char[] curr = _currentSegment; // Let's grow by 50% by default final int len = curr.length; int newLen = len + (len >> 1); // but above intended maximum, slow to increase by 25% if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); } return (_currentSegment = Arrays.copyOf(curr, newLen)); }"], ['int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));'], ['int newLen = len + (len >> 1); if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); }'], 'a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java', 'b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java']
['JacksonCore-5', 1, 1, 1, 1, ["return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { return -1; }"], ["return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; }"], ['char c = str.charAt(i++);'], ['char c = str.charAt(i);'], 'a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java', 'b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java']
['JacksonCore-6', 1, 1, 1, 1, ["return -1; } // [core#176]: no leading zeroes allowed for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; }"], ["return -1; } // [core#176]: no leading zeroes allowed char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i); if (c > '9' || c < '0') { return -1; }"], ['for (int i = 0; i < len; ++i) { char c = str.charAt(i);'], ["char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i);"], 'a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java', 'b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java']
['JacksonCore-7', 1, 1, 1, 1, ['public int writeValue() { // Most likely, object: if (_type == TYPE_OBJECT) { _gotName = false; ++_index; return STATUS_OK_AFTER_COLON;'], ['public int writeValue() { // Most likely, object: if (_type == TYPE_OBJECT) { if (!_gotName) { return STATUS_EXPECT_NAME; } _gotName = false; ++_index; return STATUS_OK_AFTER_COLON;'], [''], ['if (!_gotName) { return STATUS_EXPECT_NAME; }'], 'a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java', 'b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java']
['JacksonCore-8', 1, 1, 1, 1, ['return (_resultArray = _resultString.toCharArray()); } // Nope; but does it fit in just one segment? if (!_hasSegments) return _currentSegment; // Nope, need to have/create a non-segmented array and return it return contentsAsArray(); }'], ['return (_resultArray = _resultString.toCharArray()); } // Nope; but does it fit in just one segment? if (!_hasSegments && _currentSegment != null) return _currentSegment; // Nope, need to have/create a non-segmented array and return it return contentsAsArray(); }'], ['if (!_hasSegments) return _currentSegment;'], ['if (!_hasSegments && _currentSegment != null) return _currentSegment;'], 'a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java', 'b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java']
['JacksonCore-9', 6, 6, 6, 6, ['if (_currToken == JsonToken.VALUE_STRING) { return getText(); } return getValueAsString(null); }', 'if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }'], ['if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return getValueAsString(null); }', 'if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(defValue); }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(defValue); }'], ['', '', '', '', '', ''], ['if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-10', 2, 2, 2, 2, ['/* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array, * since "long names" area follows. Instead, need to calculate from hash size. */ if (_spilloverEnd >= hashArea.length) { if (_failOnDoS) { _reportTooManyCollisions(); }', '* to work it out, but this is the simplest, fast and seems to do ok. */ hash += (hash >>> 16); // to xor hi- and low- 16-bits hash ^= (hash >>> 12); return hash; }'], ['/* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array, * since "long names" area follows. Instead, need to calculate from hash size. */ final int end = (_hashSize << 3); if (_spilloverEnd >= end) { if (_failOnDoS) { _reportTooManyCollisions(); }', '* to work it out, but this is the simplest, fast and seems to do ok. */ hash += (hash >>> 16); // to xor hi- and low- 16-bits hash ^= (hash << 3); // shuffle back a bit hash += (hash >>> 12); // and bit more return hash; }'], ['if (_spilloverEnd >= hashArea.length) {', 'hash ^= (hash >>> 12);'], ['final int end = (_hashSize << 3); if (_spilloverEnd >= end) {', 'hash ^= (hash << 3); // shuffle back a bit hash += (hash >>> 12); // and bit more'], 'a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java', 'b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java']
['JacksonCore-11', 1, 1, 1, 1, ['_hashShared = false; // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure // we rehash as needed, as need-rehash flag is not copied from parent } if (_needRehash) { rehash();'], ['_hashShared = false; // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure // we rehash as needed, as need-rehash flag is not copied from parent _verifyNeedForRehash(); } if (_needRehash) { rehash();'], [''], ['_verifyNeedForRehash();'], 'a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java', 'b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java']
['JacksonCore-12', 8, 8, 8, 8, ["if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); /* And should we now have a name? Always true for Object contexts, since * the intermediate 'expect-value' state is never retained.", 'boolean inObject = _parsingContext.inObject(); if (inObject) { // First, field name itself: String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } // Ok: we must have a value... what is it?', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { // when doing literal match, must consider escaping: char[] nameChars = sstr.asQuotedChars();', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; switch (i) { case \'"\':', '_parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); }', '_nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr()); }'], ["if (_parsingContext.expectComma()) { i = _skipComma(i); } /* And should we now have a name? Always true for Object contexts, since * the intermediate 'expect-value' state is never retained.", 'boolean inObject = _parsingContext.inObject(); if (inObject) { // First, field name itself: _updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } _updateLocation(); // Ok: we must have a value... what is it?', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return false; } _updateNameLocation(); if (i == INT_QUOTE) { // when doing literal match, must consider escaping: char[] nameChars = sstr.asQuotedChars();', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation(); switch (i) { case \'"\':', '_parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, -1L, _nameInputTotal, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, -1L, _tokenInputTotal, _tokenInputRow, getTokenColumnNr()); }', '_nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, getTokenColumnNr()); }'], ['_updateLocation();', '', '_updateLocation();', '_updateLocation();', '', '', '-1L, getTokenCharacterOffset(), getTokenLineNr(),', 'getTokenCharacterOffset(), -1L, getTokenLineNr(),'], ['', '_updateNameLocation(); _updateLocation();', '_updateLocation(); _updateNameLocation();', '_updateLocation(); _updateNameLocation(); _updateLocation();', '_updateLocation();', '_updateLocation();', 'if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, -1L, _nameInputTotal, _nameInputRow, _tokenInputCol); } -1L, _tokenInputTotal, _tokenInputRow,', '_tokenInputTotal, -1L, _tokenInputRow,'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-13', 1, 1, 1, 1, ['return this; } @Override protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {'], ['return this; } @Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; } @Override protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {'], [''], ['@Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; }'], 'a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java', 'b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java']
['JacksonCore-14', 1, 1, 1, 1, [' protected final void _verifyRelease(byte[] toRelease, byte[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException("Trying to release buffer not owned by the context"); } }'], [' protected final void _verifyRelease(byte[] toRelease, byte[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException("Trying to release buffer smaller than original"); } }'], ['if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } return new IllegalArgumentException("Trying to release buffer not owned by the context");'], ['if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } return new IllegalArgumentException("Trying to release buffer smaller than original");'], 'a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java', 'b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java']
['JacksonCore-15', 1, 1, 1, 1, ['//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken // check for no buffered context _exposedContext - null //If all the conditions matches then check for scalar / non-scalar property //if not scalar and ended successfully, then return null //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null // Anything buffered? TokenFilterContext ctxt = _exposedContext;'], ['//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken // check for no buffered context _exposedContext - null //If all the conditions matches then check for scalar / non-scalar property if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ //if not scalar and ended successfully, then return null if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } } // Anything buffered? TokenFilterContext ctxt = _exposedContext;'], [''], ['if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } }'], 'a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java', 'b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java']
['JacksonCore-16', 3, 3, 3, 3, ['* * @since 2.8 */ /* *******************************************************', 'protected JsonParserSequence(JsonParser[] parsers) { super(parsers[0]); _parsers = parsers; _nextParser = 1; }', '} @Override public JsonToken nextToken() throws IOException, JsonParseException { JsonToken t = delegate.nextToken(); if (t != null) return t; while (switchToNext()) { t = delegate.nextToken(); if (t != null) return t; } return null; } /*'], ['* * @since 2.8 */ protected boolean _suppressNextToken; /* *******************************************************', 'protected JsonParserSequence(JsonParser[] parsers) { super(parsers[0]); _suppressNextToken = delegate.hasCurrentToken(); _parsers = parsers; _nextParser = 1; }', '} @Override public JsonToken nextToken() throws IOException { if (delegate == null) { return null; } if (_suppressNextToken) { _suppressNextToken = false; return delegate.currentToken(); } JsonToken t = delegate.nextToken(); while ((t == null) && switchToNext()) { t = delegate.hasCurrentToken() ? delegate.currentToken() : delegate.nextToken(); } return t; } /*'], ['', '', 'public JsonToken nextToken() throws IOException, JsonParseException if (t != null) return t; while (switchToNext()) { t = delegate.nextToken(); if (t != null) return t; return null;'], ['protected boolean _suppressNextToken;', '_suppressNextToken = delegate.hasCurrentToken();', 'public JsonToken nextToken() throws IOException if (delegate == null) { return null; } if (_suppressNextToken) { _suppressNextToken = false; return delegate.currentToken(); } while ((t == null) && switchToNext()) { t = delegate.hasCurrentToken() ? delegate.currentToken() : delegate.nextToken(); return t;'], 'a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java', 'b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java']
['JacksonCore-17', 3, 3, 3, 3, ["final char[] buf = _charBuffer; // minor optimization: see if we can just get and copy // If not, need segmented approach. For speed, let's also use input buffer // size that is guaranteed to fit in output buffer; each char can expand to // at most 3 bytes, so at most 1/3 of buffer size. while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); // If this is NOT the last segment and if the last character looks like // split surrogate second half, drop it offset += len2; len -= len2; }", '* * @since 2.8.2 */ /* /**********************************************************', 'if (ch <= SURR2_LAST) { // yes, outside of BMP // Do we have second part? if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError("Split surrogate on writeRaw() input (last character)"); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1;'], ["final char[] buf = _charBuffer; // minor optimization: see if we can just get and copy if (len <= buf.length) { text.getChars(offset, offset+len, buf, 0); _writeRawSegment(buf, 0, len); return; } // If not, need segmented approach. For speed, let's also use input buffer // size that is guaranteed to fit in output buffer; each char can expand to // at most 3 bytes, so at most 1/3 of buffer size. final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16 final int maxBytes = maxChunk * 3; while (len > 0) { int len2 = Math.min(maxChunk, len); text.getChars(offset, offset+len2, buf, 0); if ((_outputTail + maxBytes) > _outputEnd) { _flushBuffer(); } // If this is NOT the last segment and if the last character looks like // split surrogate second half, drop it if (len > 0) { char ch = buf[len2-1]; if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) { --len2; } } _writeRawSegment(buf, 0, len2); offset += len2; len -= len2; }", '* * @since 2.8.2 */ private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException { main_loop: while (offset < end) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= end) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, end); } } } /* /**********************************************************', 'if (ch <= SURR2_LAST) { // yes, outside of BMP // Do we have second part? if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(String.format( "Split surrogate on writeRaw() input (last character): first character 0x%4x", ch)); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1;'], ['int len2 = Math.min(buf.length, len); writeRaw(buf, 0, len2);', '', '_reportError("Split surrogate on writeRaw() input (last character)");'], ['if (len <= buf.length) { text.getChars(offset, offset+len, buf, 0); _writeRawSegment(buf, 0, len); return; } final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16 final int maxBytes = maxChunk * 3; int len2 = Math.min(maxChunk, len); if ((_outputTail + maxBytes) > _outputEnd) { _flushBuffer(); } if (len > 0) { char ch = buf[len2-1]; if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) { --len2; } } _writeRawSegment(buf, 0, len2);', 'private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException { main_loop: while (offset < end) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= end) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, end); } } }', '_reportError(String.format( "Split surrogate on writeRaw() input (last character): first character 0x%4x", ch));'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java']
['JacksonCore-18', 4, 4, 4, 4, ['* * @since 2.7.7 */ /* /**********************************************************', '* @since 2.7.7 */ protected String _asString(BigDecimal value) throws IOException { // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector return value.toString(); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(_asString(value)); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { writeRaw(value.toPlainString()); } else { writeRaw(_asString(value)); }'], ['* * @since 2.7.7 */ protected final static int MAX_BIG_DECIMAL_SCALE = 9999; /* /**********************************************************', '* @since 2.7.7 */ protected String _asString(BigDecimal value) throws IOException { if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector int scale = value.scale(); if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) { _reportError(String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE)); } return value.toPlainString(); } return value.toString(); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(_asString(value)); } else { writeRaw(_asString(value)); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(_asString(value)); } else { writeRaw(_asString(value)); }'], ['', '', 'String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString());', 'String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { writeRaw(value.toPlainString());'], ['protected final static int MAX_BIG_DECIMAL_SCALE = 9999;', 'if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { int scale = value.scale(); if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) { _reportError(String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE)); } return value.toPlainString(); }', '_writeQuotedRaw(_asString(value));', '_writeQuotedRaw(_asString(value));'], 'a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java', 'b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java']
['JacksonCore-19', 2, 2, 2, 2, ["int fractLen = 0; // And then see if we get other parts if (c == '.') { // yes, fraction outBuf[outPtr++] = c; fract_loop:", ' // And then see if we get other parts if (c == INT_PERIOD) { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop:'], ["int fractLen = 0; // And then see if we get other parts if (c == '.') { // yes, fraction if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; fract_loop:", ' // And then see if we get other parts if (c == INT_PERIOD) { // yes, fraction if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; fract_loop:'], ['', ''], ['if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }', 'if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-20', 1, 1, 1, 1, ['*/ public void writeEmbeddedObject(Object object) throws IOException { // 01-Sep-2016, tatu: As per [core#318], handle small number of cases throw new JsonGenerationException("No native support for writing embedded objects", this); }'], ['*/ public void writeEmbeddedObject(Object object) throws IOException { // 01-Sep-2016, tatu: As per [core#318], handle small number of cases if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException("No native support for writing embedded objects of type " +object.getClass().getName(), this); }'], ['throw new JsonGenerationException("No native support for writing embedded objects",'], ['if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException("No native support for writing embedded objects of type " +object.getClass().getName(),'], 'a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java', 'b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java']
['JacksonCore-21', 2, 2, 2, 2, ['// If all the conditions matches then check for scalar / non-scalar property if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) { //if not scalar and ended successfully, and !includePath, then return null if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null);', 'if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } } } // Anything buffered?'], ['// If all the conditions matches then check for scalar / non-scalar property if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) { //if not scalar and ended successfully, and !includePath, then return null if (!_includePath) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null);', 'if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } } } } // Anything buffered?'], ['', ''], ['if (!_includePath) {', '}'], 'a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java', 'b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java']
['JacksonCore-22', 7, 7, 7, 7, ['} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } // Otherwise not included (leaves must be explicitly included)', '} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } // if (_includeImmediateParent) { ...', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } // Otherwise not included (leaves must be explicitly included)', 'continue main_loop; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { return _nextBuffered(buffRoot); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return _nextBuffered(buffRoot); } } // Otherwise not included (leaves must be explicitly included)', '} } @Override public JsonToken nextValue() throws IOException {'], ['} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_verifyAllowedMatches() && _includePath) { return (_currToken = t); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { if (_verifyAllowedMatches()) { return (_currToken = t); } } } // Otherwise not included (leaves must be explicitly included)', '} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_verifyAllowedMatches() && _includePath) { return (_currToken = t); } // if (_includeImmediateParent) { ...', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { if (_verifyAllowedMatches()) { return (_currToken = t); } } } // Otherwise not included (leaves must be explicitly included)', 'continue main_loop; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) { return _nextBuffered(buffRoot); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { if (_verifyAllowedMatches()) { return _nextBuffered(buffRoot); } } } // Otherwise not included (leaves must be explicitly included)', '} } private final boolean _verifyAllowedMatches() throws IOException { if (_matchCount == 0 || _allowMultipleMatches) { ++_matchCount; return true; } return false; } @Override public JsonToken nextValue() throws IOException {'], ['if (_includePath) {', '', 'if (_includePath) {', '', 'if (f == TokenFilter.INCLUDE_ALL) {', '', ''], ['if (_verifyAllowedMatches() && _includePath) {', 'if (_verifyAllowedMatches()) { }', 'if (_verifyAllowedMatches() && _includePath) {', 'if (_verifyAllowedMatches()) { }', 'if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {', 'if (_verifyAllowedMatches()) { }', 'private final boolean _verifyAllowedMatches() throws IOException { if (_matchCount == 0 || _allowMultipleMatches) { ++_matchCount; return true; } return false; }'], 'a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java', 'b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java']
['JacksonCore-23', 1, 1, 1, 1, [' @Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }'], [' @Override public DefaultPrettyPrinter createInstance() { if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException("Failed `createInstance()`: "+getClass().getName() +" does not override method; it has to"); } return new DefaultPrettyPrinter(this); }'], [''], ['if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException("Failed `createInstance()`: "+getClass().getName() +" does not override method; it has to"); }'], 'a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java', 'b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java']
['JacksonCore-24', 4, 4, 4, 4, ['// @since 2.9.8 protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException { final String numDesc = _longIntegerDesc(rawNum); _reportError("Numeric value (%s) out of range of %s", numDesc, (expType == NR_LONG) ? "long" : "int"); } /*', '// Let\'s verify it\'s lossless conversion by simple roundtrip int result = (int) _numberLong; if (((long) result) != _numberLong) { _reportError("Numeric value ("+getText()+") out of range of int"); } _numberInt = result; } else if ((_numTypesValid & NR_BIGINT) != 0) {', ' // @since 2.10 protected void reportOverflowInt(String numDesc) throws IOException { _reportError(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE)); } // @since 2.10 /** * Method called to throw an exception for integral (not floating point) input', ' // @since 2.10 protected void reportOverflowLong(String numDesc) throws IOException { _reportError(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE)); } // @since 2.10 /** * @since 2.10'], ['// @since 2.9.8 protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException { if (expType == NR_INT) { reportOverflowInt(rawNum); } else { reportOverflowLong(rawNum); } } /*', "// Let's verify it's lossless conversion by simple roundtrip int result = (int) _numberLong; if (((long) result) != _numberLong) { reportOverflowInt(getText(), currentToken()); } _numberInt = result; } else if ((_numTypesValid & NR_BIGINT) != 0) {", ' // @since 2.10 protected void reportOverflowInt(String numDesc) throws IOException { reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT); } // @since 2.10 protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE), inputType, Integer.TYPE); } /** * Method called to throw an exception for integral (not floating point) input', ' // @since 2.10 protected void reportOverflowLong(String numDesc) throws IOException { reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT); } // @since 2.10 protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE), inputType, Long.TYPE); } /** * @since 2.10'], ['final String numDesc = _longIntegerDesc(rawNum); _reportError("Numeric value (%s) out of range of %s", numDesc, (expType == NR_LONG) ? "long" : "int");', '_reportError("Numeric value ("+getText()+") out of range of int");', '_reportError(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));', '_reportError(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));'], ['if (expType == NR_INT) { reportOverflowInt(rawNum); } else { reportOverflowLong(rawNum); }', 'reportOverflowInt(getText(), currentToken());', 'reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT); protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE), inputType, Integer.TYPE); }', 'reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT); protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE), inputType, Long.TYPE); }'], 'a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java', 'b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java']
['JacksonCore-25', 1, 1, 1, 1, ['} char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) { break; }'], ['} char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i < maxCode) { if (codes[i] != 0) { break; }'], ['if (i <= maxCode) {'], ['if (i < maxCode) {'], 'a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java']
['JacksonCore-26', 1, 1, 1, 1, ['_currInputRowStart = start - (_inputEnd - _currInputRowStart); // And then update buffer settings _inputBuffer = buf; _inputPtr = start; _inputEnd = end;'], ['_currInputRowStart = start - (_inputEnd - _currInputRowStart); // And then update buffer settings _currBufferStart = start; _inputBuffer = buf; _inputPtr = start; _inputEnd = end;'], [''], ['_currBufferStart = start;'], 'a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java']
['Codec-1', 3, 3, 3, 3, ['} // 1. Convert to lowercase txt = txt.toLowerCase(); // 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", "");', '} // single character is itself if (txt.length() == 1) { return txt.toUpperCase() ; } char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;', '} } if (count == len) { return str.toUpperCase(); } return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH); }'], ['} // 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); // 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", "");', '} // single character is itself if (txt.length() == 1) { return txt.toUpperCase(java.util.Locale.ENGLISH) ; } char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;', '} } if (count == len) { return str.toUpperCase(java.util.Locale.ENGLISH); } return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH); }'], ['txt = txt.toLowerCase();', 'return txt.toUpperCase() ;', 'return str.toUpperCase();'], ['txt = txt.toLowerCase(java.util.Locale.ENGLISH);', 'return txt.toUpperCase(java.util.Locale.ENGLISH) ;', 'return str.toUpperCase(java.util.Locale.ENGLISH);'], 'a/src/java/org/apache/commons/codec/language/SoundexUtils.java', 'b/src/java/org/apache/commons/codec/language/SoundexUtils.java']
['Codec-2', 1, 1, 1, 1, ['} break; } if (lineLength > 0) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; }'], ['} break; } if (lineLength > 0 && pos > 0) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; }'], ['if (lineLength > 0) {'], ['if (lineLength > 0 && pos > 0) {'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-3', 1, 1, 1, 1, ['if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { //-- obvious germanic --// result.append(\'K\'); } else if (contains(value, index + 1, 4, "IER")) { result.append(\'J\'); } else { result.append(\'J\', \'K\');'], ['if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { //-- obvious germanic --// result.append(\'K\'); } else if (contains(value, index + 1, 3, "IER")) { result.append(\'J\'); } else { result.append(\'J\', \'K\');'], ['} else if (contains(value, index + 1, 4, "IER")) {'], ['} else if (contains(value, index + 1, 3, "IER")) {'], 'a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java', 'b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java']
['Codec-4', 1, 1, 1, 1, ['* </p> */ public Base64() { this(false); } /**'], ['* </p> */ public Base64() { this(0); } /**'], ['this(false);'], ['this(0);'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-5', 1, 1, 1, 1, ["// EOF (-1) and first time '=' character is encountered in stream. // This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { x = x << 6; switch (modulus) {"], ["// EOF (-1) and first time '=' character is encountered in stream. // This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); } x = x << 6; switch (modulus) {"], [''], ['if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); }'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-6', 3, 3, 3, 3, ['} else if (len == 0) { return 0; } else { /* Rationale for while-loop on (readLen == 0): -----', '----- This is a fix for CODEC-101 */ if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);', 'base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } }'], ['} else if (len == 0) { return 0; } else { int readLen = 0; /* Rationale for while-loop on (readLen == 0): -----', '----- This is a fix for CODEC-101 */ while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);', 'base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } }'], ['', '', 'return base64.readResults(b, offset, len);'], ['int readLen = 0;', 'while (readLen == 0) {', 'readLen = base64.readResults(b, offset, len); } return readLen;'], 'a/src/java/org/apache/commons/codec/binary/Base64InputStream.java', 'b/src/java/org/apache/commons/codec/binary/Base64InputStream.java']
['Codec-7', 1, 1, 1, 1, ['* @since 1.4 */ public static String encodeBase64String(byte[] binaryData) { return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); } /**'], ['* @since 1.4 */ public static String encodeBase64String(byte[] binaryData) { return StringUtils.newStringUtf8(encodeBase64(binaryData, false)); } /**'], ['return StringUtils.newStringUtf8(encodeBase64(binaryData, true));'], ['return StringUtils.newStringUtf8(encodeBase64(binaryData, false));'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-8', 2, 2, 2, 2, ['return eof ? -1 : 0; } void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } } /** * <p> * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with', 'if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else {'], ['return eof ? -1 : 0; } /** * <p> * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with', 'if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { base64.encode(buf, 0, c); } else {'], ['void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } }', 'if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); }'], ['', ''], 'a/src/java/org/apache/commons/codec/binary/Base64InputStream.java', 'b/src/java/org/apache/commons/codec/binary/Base64InputStream.java']
['Codec-9', 1, 1, 1, 1, ['return binaryData; } long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len +'], ['return binaryData; } long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len +'], ['long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);'], ['long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-10', 1, 1, 1, 1, ['txt = txt.replaceAll("^gn", "2n"); // End txt = txt.replaceAll("^mb", "m2"); // 4. Handle replacements txt = txt.replaceAll("cq", "2q");'], ['txt = txt.replaceAll("^gn", "2n"); // End txt = txt.replaceAll("mb$", "m2"); // 4. Handle replacements txt = txt.replaceAll("cq", "2q");'], ['txt = txt.replaceAll("^mb", "m2");'], ['txt = txt.replaceAll("mb$", "m2");'], 'a/src/java/org/apache/commons/codec/language/Caverphone.java', 'b/src/java/org/apache/commons/codec/language/Caverphone.java']
['Codec-11', 7, 7, 7, 7, [' private static final byte SPACE = 32; /** Safe line length for quoted printable encoded text. */ // Static initializer for printable chars collection static {', '* the buffer to write to * @return The number of bytes written to the <code>buffer</code> */ private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); } /**', '* the byte array * @return the unsigned octet at position <code>index</code> from the array */ /** * Write a byte to the buffer.', '* the buffer to write to * @return the number of bytes that have been written to the buffer */ /** * Checks whether the given byte is whitespace.', '* byte to be checked * @return <code>true</code> if the byte is either a space or tab character */ /** * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.', "printable = PRINTABLE_CHARS; } ByteArrayOutputStream buffer = new ByteArrayOutputStream(); // encode up to buffer.length - 3, the last three octets will be treated // separately for simplification of note #3 // up to this length it is safe to add any byte, encoded or not for (byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { // rule #3: whitespace at the end of a line *must* be encoded // rule #5: soft line break encodeQuotedPrintable(b, buffer); } } // rule #3: whitespace at the end of a line *must* be encoded // if we would do a soft break line after this octet, encode whitespace // note #3: '=' *must not* be the ultimate or penultimate character // simplification: if < 6 bytes left, do a soft line break as we may need // exactly 6 bytes space for the last 2 bytes // rule #3: trailing whitespace shall be encoded return buffer.toByteArray(); }", 'if (b == ESCAPE_CHAR) { try { // if the next octet is a CR we have found a soft line break int u = Utils.digit16(bytes[++i]); int l = Utils.digit16(bytes[++i]); buffer.write((char) ((u << 4) + l)); } catch (ArrayIndexOutOfBoundsException e) { throw new DecoderException("Invalid quoted-printable encoding", e); } } else { // every other octet is appended except for CR & LF buffer.write(b); }'], [' private static final byte SPACE = 32; private static final byte CR = 13; private static final byte LF = 10; /** Safe line length for quoted printable encoded text. */ private static final int SAFE_LENGTH = 73; // Static initializer for printable chars collection static {', '* the buffer to write to * @return The number of bytes written to the <code>buffer</code> */ private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); return 3; } /**', '* the byte array * @return the unsigned octet at position <code>index</code> from the array */ private static int getUnsignedOctet(final int index, final byte[] bytes) { int b = bytes[index]; if (b < 0) { b = 256 + b; } return b; } /** * Write a byte to the buffer.', '* the buffer to write to * @return the number of bytes that have been written to the buffer */ private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer) { if (encode) { return encodeQuotedPrintable(b, buffer); } else { buffer.write(b); return 1; } } /** * Checks whether the given byte is whitespace.', '* byte to be checked * @return <code>true</code> if the byte is either a space or tab character */ private static boolean isWhitespace(final int b) { return b == SPACE || b == TAB; } /** * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.', "printable = PRINTABLE_CHARS; } ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int pos = 1; // encode up to buffer.length - 3, the last three octets will be treated // separately for simplification of note #3 for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { // up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { // rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); // rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } // rule #3: whitespace at the end of a line *must* be encoded // if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); // note #3: '=' *must not* be the ultimate or penultimate character // simplification: if < 6 bytes left, do a soft line break as we may need // exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); // rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } return buffer.toByteArray(); }", 'if (b == ESCAPE_CHAR) { try { // if the next octet is a CR we have found a soft line break if (bytes[++i] == CR) { continue; } int u = Utils.digit16(bytes[i]); int l = Utils.digit16(bytes[++i]); buffer.write((char) ((u << 4) + l)); } catch (ArrayIndexOutOfBoundsException e) { throw new DecoderException("Invalid quoted-printable encoding", e); } } else if (b != CR && b != LF) { // every other octet is appended except for CR & LF buffer.write(b); }'], ['', 'private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {', '', '', '', 'for (byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); encodeQuotedPrintable(b, buffer);', 'int u = Utils.digit16(bytes[++i]); } else {'], ['private static final byte CR = 13; private static final byte LF = 10; private static final int SAFE_LENGTH = 73;', 'private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { return 3;', 'private static int getUnsignedOctet(final int index, final byte[] bytes) { int b = bytes[index]; if (b < 0) { b = 256 + b; } return b; }', 'private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer) { if (encode) { return encodeQuotedPrintable(b, buffer); } else { buffer.write(b); return 1; } }', 'private static boolean isWhitespace(final int b) { return b == SPACE || b == TAB; }', 'int pos = 1; for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { pos += encodeByte(b, !printable.get(b), buffer); encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); }', 'if (bytes[++i] == CR) { continue; } int u = Utils.digit16(bytes[i]); } else if (b != CR && b != LF) {'], 'a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java', 'b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java']
['Codec-12', 2, 2, 2, 2, ['* * @throws IllegalArgumentException if the provided skip length is negative */ // skip in chunks of 512 bytes /** * {@inheritDoc}', '* @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance }'], ['* * @throws IllegalArgumentException if the provided skip length is negative */ @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length"); } // skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } /** * {@inheritDoc}', '* @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ public int available() throws IOException { // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance if (baseNCodec.eof) { return 0; } else { return 1; } } }'], ['', ''], ['@Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length"); } final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; }', 'public int available() throws IOException { if (baseNCodec.eof) { return 0; } else { return 1; } }'], 'a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java', 'b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java']
['Codec-13', 3, 4, 4, 4, ['* @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null} * @since 1.10 */ /** * Calls {@link String#getBytes(Charset)}', ' import org.apache.commons.codec.EncoderException; import org.apache.commons.codec.StringEncoder; /** * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence', '* {@code false} otherwise. */ public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) { return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate)); } /**'], ['package org.apache.commons.codec.binary; /** * <p> * Operations on {@link CharSequence} that are {@code null} safe. * </p> * <p> * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release). * </p> * * @see CharSequence * @since 1.10 */ public class CharSequenceUtils { /** * Green implementation of regionMatches. * * @param cs * the {@code CharSequence} to be processed * @param ignoreCase * whether or not to be case insensitive * @param thisStart * the index to start on the {@code cs} CharSequence * @param substring * the {@code CharSequence} to be looked for * @param start * the index to start on the {@code substring} CharSequence * @param length * character length of the region * @return whether the region matched */ static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { if (cs instanceof String && substring instanceof String) { return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); } int index1 = thisStart; int index2 = start; int tmpLen = length; while (tmpLen-- > 0) { char c1 = cs.charAt(index1++); char c2 = substring.charAt(index2++); if (c1 == c2) { continue; } if (!ignoreCase) { return false; } // The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } }', '* @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null} * @since 1.10 */ public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); } /** * Calls {@link String#getBytes(Charset)}', ' import org.apache.commons.codec.EncoderException; import org.apache.commons.codec.StringEncoder; import org.apache.commons.codec.binary.StringUtils; /** * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence', '* {@code false} otherwise. */ public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) { return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate)); } /**'], ['', '', '', 'return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));'], ['package org.apache.commons.codec.binary; /** * <p> * Operations on {@link CharSequence} that are {@code null} safe. * </p> * <p> * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release). * </p> * * @see CharSequence * @since 1.10 */ public class CharSequenceUtils { /** * Green implementation of regionMatches. * * @param cs * the {@code CharSequence} to be processed * @param ignoreCase * whether or not to be case insensitive * @param thisStart * the index to start on the {@code cs} CharSequence * @param substring * the {@code CharSequence} to be looked for * @param start * the index to start on the {@code substring} CharSequence * @param length * character length of the region * @return whether the region matched */ static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { if (cs instanceof String && substring instanceof String) { return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); } int index1 = thisStart; int index2 = start; int tmpLen = length; while (tmpLen-- > 0) { char c1 = cs.charAt(index1++); char c2 = substring.charAt(index2++); if (c1 == c2) { continue; } if (!ignoreCase) { return false; } // The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } }', 'public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); }', 'import org.apache.commons.codec.binary.StringUtils;', 'return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));'], 'a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java', 'b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java']
['Codec-14', 5, 8, 8, 8, [' private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class); private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/lang.txt"; static { for (final NameType s : NameType.values()) { Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s))); } }', 'import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeSet; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme;', 'return phonemeBuilder; } final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());', '// the phonemes map orders the phonemes only based on their text, but ignores the language set // when adding new phonemes, check for equal phonemes and merge their language set, otherwise // phonemes with the same text but different language set get lost phonemes.addAll(subBuilder.getPhonemes()); } return new PhonemeBuilder(phonemes); } /**', '* @param lang the language set to merge * @return a new Phoneme */ @Override public String toString() {'], [' private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class); private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/%s_lang.txt"; static { for (final NameType s : NameType.values()) { Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s))); } }', 'import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeMap; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme;', 'return phonemeBuilder; } final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());', '// the phonemes map orders the phonemes only based on their text, but ignores the language set // when adding new phonemes, check for equal phonemes and merge their language set, otherwise // phonemes with the same text but different language set get lost for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) { if (phonemes.containsKey(newPhoneme)) { final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme); final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages()); phonemes.put(mergedPhoneme, mergedPhoneme); } else { phonemes.put(newPhoneme, newPhoneme); } } } return new PhonemeBuilder(phonemes.keySet()); } /**', '* @param lang the language set to merge * @return a new Phoneme */ public Phoneme mergeWithLanguage(final LanguageSet lang) { return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang)); } @Override public String toString() {', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // ASHKENAZIC // 1. following are rules to accept the language // 1.1 Special letter combinations zh polish+russian+german+english true eau french true [aoeiuäöü]h german true ^vogel german, true vogel$ german true witz german true tz$ german+russian+english true ^tz russian+english true güe spanish true güi spanish true ghe romanian true ghi romanian true vici$ romanian true schi$ romanian true chsch german true tsch german true ssch german true sch$ german+russian true ^sch german+russian true ^rz polish true rz$ polish+german true [^aoeiuäöü]rz polish true rz[^aoeiuäöü] polish true cki$ polish true ska$ polish true cka$ polish true ue german+russian true ae german+russian+english true oe german+french+russian+english true th$ german true ^th german true th[^aoeiu] german true mann german true cz polish true cy polish true niew polish true stein german true heim$ german true heimer$ german true ii$ russian true iy$ russian true yy$ russian true yi$ russian true yj$ russian true ij$ russian true gaus$ russian true gauz$ russian true gauz$ russian true goltz$ russian true gol\'tz$ russian true golts$ russian true gol\'ts$ russian true ^goltz russian true ^gol\'tz russian true ^golts russian true ^gol\'ts russian true gendler$ russian true gejmer$ russian true gejm$ russian true geimer$ russian true geim$ russian true geymer russian true geym$ russian true gof$ russian true thal german true zweig german true ck$ german+english true c$ polish+romanian+hungarian true sz polish+hungarian true gue spanish+french true gui spanish+french true guy french true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian true ly hungarian+russian+polish true ny hungarian+russian+polish true ty hungarian+russian+polish true // 1.2 special characters â romanian+french true ă romanian true à french true ä german true á hungarian+spanish true ą polish true ć polish true ç french true ę polish true é french+hungarian+spanish true è french true ê french true í hungarian+spanish true î romanian+french true ł polish true ń polish true ñ spanish true ó polish+hungarian+spanish true ö german+hungarian true õ hungarian true ş romanian true ś polish true ţ romanian true ü german+hungarian true ù french true ű hungarian true ú hungarian+spanish true ź polish true ż polish true ß german true // Every Cyrillic word has at least one Cyrillic vowel (аёеоиуыэюя) а cyrillic true ё cyrillic true о cyrillic true е cyrillic true и cyrillic true у cyrillic true ы cyrillic true э cyrillic true ю cyrillic true я cyrillic true // Hebrew א hebrew true ב hebrew true ג ebrew true ד hebrew true ה hebrew true ו hebrew true ז hebrew true ח hebrew true ט hebrew true י hebrew true כ hebrew true ל hebrew true מ hebrew true נ hebrew true ס hebrew true ע hebrew true פ hebrew true צ hebrew true ק hebrew true ר hebrew true ש hebrew true ת hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew false o cyrillic+hebrew false e cyrillic+hebrew false i cyrillic+hebrew false y cyrillic+hebrew+romanian false u cyrillic+hebrew false v[^aoeiuäüö] german false // in german "v" can be found before a vowel only y[^aoeiu] german false // in german "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french false ou german false aj german+english+french false ej german+english+french false oj german+english+french false uj german+english+french false k romanian false v polish false ky polish false eu russian+polish false w french+romanian+spanish+hungarian+russian false kie french+spanish false gie french+romanian+spanish false q hungarian+polish+russian+romanian false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // GENERIC // 1. following are rules to accept the language // 1.1 Special letter combinations ^o’ english true ^o\' english true ^mc english true ^fitz english true ceau french+romanian true eau romanian true eau$ french true // mp: I\'ve added this eaux$ french true // mp: I\'ve added this ault$ french true oult$ french true eux$ french true eix$ french true glou$ greeklatin true uu dutch true tx spanish true witz german true tz$ german+russian+english true ^tz russian+english true poulos$ greeklatin true pulos$ greeklatin true iou greeklatin true sj$ dutch true ^sj dutch true güe spanish true güi spanish true ghe romanian+greeklatin true ghi romanian+greeklatin true escu$ romanian true esco$ romanian true vici$ romanian true schi$ romanian true ii$ russian true iy$ russian true yy$ russian true yi$ russian true ^rz polish true rz$ polish+german true [bcdfgklmnpstwz]rz polish true rz[bcdfghklmnpstw] polish true cki$ polish true ska$ polish true cka$ polish true ae german+russian+english true oe german+french+russian+english+dutch true th$ german+english true ^th german+english+greeklatin true mann german true cz polish true cy polish+greeklatin true niew polish true etti$ italian true eti$ italian true ati$ italian true ato$ italian true [aoei]no$ italian true [aoei]ni$ italian true esi$ italian true oli$ italian true field$ english true stein german true heim$ german true heimer$ german true thal german true zweig german true [aeou]h german true äh german true öh german true üh german true [ln]h[ao]$ portuguese true [ln]h[aou] portuguese+french+german+dutch+czech+spanish+turkish true chsch german true tsch german true sch$ german+russian true ^sch german+russian true ck$ german+english true c$ polish+romanian+hungarian+czech+turkish true sz polish+hungarian true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german+dutch true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian+french+greeklatin true guy french true gu[ei] spanish+french+portuguese true gu[ao] spanish+portuguese true gi[aou] italian+greeklatin true ly hungarian+russian+polish+greeklatin true ny hungarian+russian+polish+spanish+greeklatin true ty hungarian+russian+polish+greeklatin true // 1.2 special characters ć polish true ç french+spanish+portuguese+turkish true č czech true ď czech true ğ turkish true ł polish true ń polish true ñ spanish true ň czech true ř czech true ś polish true ş romanian+turkish true š czech true ţ romanian true ť czech true ź polish true ż polish true ß german true ä german true á hungarian+spanish+portuguese+czech+greeklatin true â romanian+french+portuguese true ă romanian true ą polish true à portuguese true ã portuguese true ę polish true é french+hungarian+czech+greeklatin true è french+spanish+italian true ê french true ě czech true ê french+portuguese true í hungarian+spanish+portuguese+czech+greeklatin true î romanian+french true ı turkish true ó polish+hungarian+spanish+italian+portuguese+czech+greeklatin true ö german+hungarian+turkish true ô french+portuguese true õ portuguese+hungarian true ò italian+spanish true ű hungarian true ú hungarian+spanish+portuguese+czech+greeklatin true ü german+hungarian+spanish+portuguese+turkish true ù french true ů czech true ý czech+greeklatin true // Every Cyrillic word has at least one Cyrillic vowel (аёеоиуыэюя) а cyrillic true ё cyrillic true о cyrillic true е cyrillic true и cyrillic true у cyrillic true ы cyrillic true э cyrillic true ю cyrillic true я cyrillic true // Every Greek word has at least one Greek vowel α greek true ε greek true η greek true ι greek true ο greek true υ greek true ω greek true // Arabic (only initial) ا arabic true // alif (isol + init) ب arabic true // ba\' ت arabic true // ta\' ث arabic true // tha\' ج arabic true // jim ح arabic true // h.a\' خ\' arabic true // kha\' د arabic true // dal (isol + init) ذ arabic true // dhal (isol + init) ر arabic true // ra\' (isol + init) ز arabic true // za\' (isol + init) س arabic true // sin ش arabic true // shin ص arabic true // s.ad ض arabic true // d.ad ط arabic true // t.a\' ظ arabic true // z.a\' ع arabic true // \'ayn غ arabic true // ghayn ف arabic true // fa\' ق arabic true // qaf ك arabic true // kaf ل arabic true // lam م arabic true // mim ن arabic true // nun ه arabic true // ha\' و arabic true // waw (isol + init) ي arabic true // ya\' آ arabic true // alif madda إ arabic true // alif + diacritic أ arabic true // alif + hamza ؤ arabic true // waw + hamza ئ arabic true // ya\' + hamza لا arabic true // ligature l+a // Hebrew א hebrew true ב hebrew true ג hebrew true ד hebrew true ה hebrew true ו hebrew true ז hebrew true ח hebrew true ט hebrew true י hebrew true כ hebrew true ל hebrew true מ hebrew true נ hebrew true ס hebrew true ע hebrew true פ hebrew true צ hebrew true ק hebrew true ר hebrew true ש hebrew true ת hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew+greek+arabic false o cyrillic+hebrew+greek+arabic false e cyrillic+hebrew+greek+arabic false i cyrillic+hebrew+greek+arabic false y cyrillic+hebrew+greek+arabic+romanian+dutch false u cyrillic+hebrew+greek+arabic false j italian false j[^aoeiuy] french+spanish+portuguese+greeklatin false g czech false k romanian+spanish+portuguese+french+italian false q hungarian+polish+russian+romanian+czech+dutch+turkish+greeklatin false v polish false w french+romanian+spanish+hungarian+russian+czech+turkish+greeklatin false x czech+hungarian+dutch+turkish false // polish excluded from the list dj spanish+turkish false v[^aoeiu] german false // in german, "v" can be found before a vowel only y[^aoeiu] german false // in german, "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french+turkish false ou german false a[eiou] turkish false // no diphthongs in Turkish ö[eaiou] turkish false ü[eaiou] turkish false e[aiou] turkish false i[aeou] turkish false o[aieu] turkish false u[aieo] turkish false aj german+english+french+dutch false ej german+english+french+dutch false oj german+english+french+dutch false uj german+english+french+dutch false eu russian+polish false ky polish false kie french+spanish+greeklatin false gie portuguese+romanian+spanish+greeklatin false ch[aou] italian false ch turkish false son$ german false sc[ei] french false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // SEPHARDIC // 1. following are rules to accept the language // 1.1 Special letter combinations eau french true ou french true gni italian+french true tx spanish true tj spanish true gy french true guy french true sh spanish+portuguese true // English, but no sign for /sh/ in these languages lh portuguese true nh portuguese true ny spanish true gue spanish+french true gui spanish+french true gia italian true gie italian true gio italian true giu italian true // 1.2 special characters ñ spanish true â portuguese+french true á portuguese+spanish true à portuguese true ã portuguese true ê french+portuguese true í portuguese+spanish true î french true ô french+portuguese true õ portuguese true ò italian+spanish true ú portuguese+spanish true ù french true ü portuguese+spanish true // Hebrew א hebrew true ב hebrew true ג hebrew true ד hebrew true ה hebrew true ו hebrew true ז hebrew true ח hebrew true ט hebrew true י hebrew true כ hebrew true ל hebrew true מ hebrew true נ hebrew true ס hebrew true ע hebrew true פ hebrew true צ hebrew true ק hebrew true ר hebrew true ש hebrew true ת hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a hebrew false o hebrew false e hebrew false i hebrew false y hebrew false u hebrew false kh spanish false gua italian false guo italian false ç italian false cha italian false cho italian false chu italian false j italian false dj spanish false sce french false sci french false ó french false è portuguese false'], ['private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/lang.txt"; Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));', 'import java.util.TreeSet;', 'final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);', 'phonemes.addAll(subBuilder.getPhonemes()); return new PhonemeBuilder(phonemes);', '', '', '', ''], ['private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/%s_lang.txt"; Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));', 'import java.util.TreeMap;', 'final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);', 'for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) { if (phonemes.containsKey(newPhoneme)) { final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme); final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages()); phonemes.put(mergedPhoneme, mergedPhoneme); } else { phonemes.put(newPhoneme, newPhoneme); } } return new PhonemeBuilder(phonemes.keySet());', 'public Phoneme mergeWithLanguage(final LanguageSet lang) { return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang)); }', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // ASHKENAZIC // 1. following are rules to accept the language // 1.1 Special letter combinations zh polish+russian+german+english true eau french true [aoeiuäöü]h german true ^vogel german, true vogel$ german true witz german true tz$ german+russian+english true ^tz russian+english true güe spanish true güi spanish true ghe romanian true ghi romanian true vici$ romanian true schi$ romanian true chsch german true tsch german true ssch german true sch$ german+russian true ^sch german+russian true ^rz polish true rz$ polish+german true [^aoeiuäöü]rz polish true rz[^aoeiuäöü] polish true cki$ polish true ska$ polish true cka$ polish true ue german+russian true ae german+russian+english true oe german+french+russian+english true th$ german true ^th german true th[^aoeiu] german true mann german true cz polish true cy polish true niew polish true stein german true heim$ german true heimer$ german true ii$ russian true iy$ russian true yy$ russian true yi$ russian true yj$ russian true ij$ russian true gaus$ russian true gauz$ russian true gauz$ russian true goltz$ russian true gol\'tz$ russian true golts$ russian true gol\'ts$ russian true ^goltz russian true ^gol\'tz russian true ^golts russian true ^gol\'ts russian true gendler$ russian true gejmer$ russian true gejm$ russian true geimer$ russian true geim$ russian true geymer russian true geym$ russian true gof$ russian true thal german true zweig german true ck$ german+english true c$ polish+romanian+hungarian true sz polish+hungarian true gue spanish+french true gui spanish+french true guy french true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian true ly hungarian+russian+polish true ny hungarian+russian+polish true ty hungarian+russian+polish true // 1.2 special characters â romanian+french true ă romanian true à french true ä german true á hungarian+spanish true ą polish true ć polish true ç french true ę polish true é french+hungarian+spanish true è french true ê french true í hungarian+spanish true î romanian+french true ł polish true ń polish true ñ spanish true ó polish+hungarian+spanish true ö german+hungarian true õ hungarian true ş romanian true ś polish true ţ romanian true ü german+hungarian true ù french true ű hungarian true ú hungarian+spanish true ź polish true ż polish true ß german true // Every Cyrillic word has at least one Cyrillic vowel (аёеоиуыэюя) а cyrillic true ё cyrillic true о cyrillic true е cyrillic true и cyrillic true у cyrillic true ы cyrillic true э cyrillic true ю cyrillic true я cyrillic true // Hebrew א hebrew true ב hebrew true ג ebrew true ד hebrew true ה hebrew true ו hebrew true ז hebrew true ח hebrew true ט hebrew true י hebrew true כ hebrew true ל hebrew true מ hebrew true נ hebrew true ס hebrew true ע hebrew true פ hebrew true צ hebrew true ק hebrew true ר hebrew true ש hebrew true ת hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew false o cyrillic+hebrew false e cyrillic+hebrew false i cyrillic+hebrew false y cyrillic+hebrew+romanian false u cyrillic+hebrew false v[^aoeiuäüö] german false // in german "v" can be found before a vowel only y[^aoeiu] german false // in german "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french false ou german false aj german+english+french false ej german+english+french false oj german+english+french false uj german+english+french false k romanian false v polish false ky polish false eu russian+polish false w french+romanian+spanish+hungarian+russian false kie french+spanish false gie french+romanian+spanish false q hungarian+polish+russian+romanian false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // GENERIC // 1. following are rules to accept the language // 1.1 Special letter combinations ^o’ english true ^o\' english true ^mc english true ^fitz english true ceau french+romanian true eau romanian true eau$ french true // mp: I\'ve added this eaux$ french true // mp: I\'ve added this ault$ french true oult$ french true eux$ french true eix$ french true glou$ greeklatin true uu dutch true tx spanish true witz german true tz$ german+russian+english true ^tz russian+english true poulos$ greeklatin true pulos$ greeklatin true iou greeklatin true sj$ dutch true ^sj dutch true güe spanish true güi spanish true ghe romanian+greeklatin true ghi romanian+greeklatin true escu$ romanian true esco$ romanian true vici$ romanian true schi$ romanian true ii$ russian true iy$ russian true yy$ russian true yi$ russian true ^rz polish true rz$ polish+german true [bcdfgklmnpstwz]rz polish true rz[bcdfghklmnpstw] polish true cki$ polish true ska$ polish true cka$ polish true ae german+russian+english true oe german+french+russian+english+dutch true th$ german+english true ^th german+english+greeklatin true mann german true cz polish true cy polish+greeklatin true niew polish true etti$ italian true eti$ italian true ati$ italian true ato$ italian true [aoei]no$ italian true [aoei]ni$ italian true esi$ italian true oli$ italian true field$ english true stein german true heim$ german true heimer$ german true thal german true zweig german true [aeou]h german true äh german true öh german true üh german true [ln]h[ao]$ portuguese true [ln]h[aou] portuguese+french+german+dutch+czech+spanish+turkish true chsch german true tsch german true sch$ german+russian true ^sch german+russian true ck$ german+english true c$ polish+romanian+hungarian+czech+turkish true sz polish+hungarian true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german+dutch true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian+french+greeklatin true guy french true gu[ei] spanish+french+portuguese true gu[ao] spanish+portuguese true gi[aou] italian+greeklatin true ly hungarian+russian+polish+greeklatin true ny hungarian+russian+polish+spanish+greeklatin true ty hungarian+russian+polish+greeklatin true // 1.2 special characters ć polish true ç french+spanish+portuguese+turkish true č czech true ď czech true ğ turkish true ł polish true ń polish true ñ spanish true ň czech true ř czech true ś polish true ş romanian+turkish true š czech true ţ romanian true ť czech true ź polish true ż polish true ß german true ä german true á hungarian+spanish+portuguese+czech+greeklatin true â romanian+french+portuguese true ă romanian true ą polish true à portuguese true ã portuguese true ę polish true é french+hungarian+czech+greeklatin true è french+spanish+italian true ê french true ě czech true ê french+portuguese true í hungarian+spanish+portuguese+czech+greeklatin true î romanian+french true ı turkish true ó polish+hungarian+spanish+italian+portuguese+czech+greeklatin true ö german+hungarian+turkish true ô french+portuguese true õ portuguese+hungarian true ò italian+spanish true ű hungarian true ú hungarian+spanish+portuguese+czech+greeklatin true ü german+hungarian+spanish+portuguese+turkish true ù french true ů czech true ý czech+greeklatin true // Every Cyrillic word has at least one Cyrillic vowel (аёеоиуыэюя) а cyrillic true ё cyrillic true о cyrillic true е cyrillic true и cyrillic true у cyrillic true ы cyrillic true э cyrillic true ю cyrillic true я cyrillic true // Every Greek word has at least one Greek vowel α greek true ε greek true η greek true ι greek true ο greek true υ greek true ω greek true // Arabic (only initial) ا arabic true // alif (isol + init) ب arabic true // ba\' ت arabic true // ta\' ث arabic true // tha\' ج arabic true // jim ح arabic true // h.a\' خ\' arabic true // kha\' د arabic true // dal (isol + init) ذ arabic true // dhal (isol + init) ر arabic true // ra\' (isol + init) ز arabic true // za\' (isol + init) س arabic true // sin ش arabic true // shin ص arabic true // s.ad ض arabic true // d.ad ط arabic true // t.a\' ظ arabic true // z.a\' ع arabic true // \'ayn غ arabic true // ghayn ف arabic true // fa\' ق arabic true // qaf ك arabic true // kaf ل arabic true // lam م arabic true // mim ن arabic true // nun ه arabic true // ha\' و arabic true // waw (isol + init) ي arabic true // ya\' آ arabic true // alif madda إ arabic true // alif + diacritic أ arabic true // alif + hamza ؤ arabic true // waw + hamza ئ arabic true // ya\' + hamza لا arabic true // ligature l+a // Hebrew א hebrew true ב hebrew true ג hebrew true ד hebrew true ה hebrew true ו hebrew true ז hebrew true ח hebrew true ט hebrew true י hebrew true כ hebrew true ל hebrew true מ hebrew true נ hebrew true ס hebrew true ע hebrew true פ hebrew true צ hebrew true ק hebrew true ר hebrew true ש hebrew true ת hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew+greek+arabic false o cyrillic+hebrew+greek+arabic false e cyrillic+hebrew+greek+arabic false i cyrillic+hebrew+greek+arabic false y cyrillic+hebrew+greek+arabic+romanian+dutch false u cyrillic+hebrew+greek+arabic false j italian false j[^aoeiuy] french+spanish+portuguese+greeklatin false g czech false k romanian+spanish+portuguese+french+italian false q hungarian+polish+russian+romanian+czech+dutch+turkish+greeklatin false v polish false w french+romanian+spanish+hungarian+russian+czech+turkish+greeklatin false x czech+hungarian+dutch+turkish false // polish excluded from the list dj spanish+turkish false v[^aoeiu] german false // in german, "v" can be found before a vowel only y[^aoeiu] german false // in german, "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french+turkish false ou german false a[eiou] turkish false // no diphthongs in Turkish ö[eaiou] turkish false ü[eaiou] turkish false e[aiou] turkish false i[aeou] turkish false o[aieu] turkish false u[aieo] turkish false aj german+english+french+dutch false ej german+english+french+dutch false oj german+english+french+dutch false uj german+english+french+dutch false eu russian+polish false ky polish false kie french+spanish+greeklatin false gie portuguese+romanian+spanish+greeklatin false ch[aou] italian false ch turkish false son$ german false sc[ei] french false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // SEPHARDIC // 1. following are rules to accept the language // 1.1 Special letter combinations eau french true ou french true gni italian+french true tx spanish true tj spanish true gy french true guy french true sh spanish+portuguese true // English, but no sign for /sh/ in these languages lh portuguese true nh portuguese true ny spanish true gue spanish+french true gui spanish+french true gia italian true gie italian true gio italian true giu italian true // 1.2 special characters ñ spanish true â portuguese+french true á portuguese+spanish true à portuguese true ã portuguese true ê french+portuguese true í portuguese+spanish true î french true ô french+portuguese true õ portuguese true ò italian+spanish true ú portuguese+spanish true ù french true ü portuguese+spanish true // Hebrew א hebrew true ב hebrew true ג hebrew true ד hebrew true ה hebrew true ו hebrew true ז hebrew true ח hebrew true ט hebrew true י hebrew true כ hebrew true ל hebrew true מ hebrew true נ hebrew true ס hebrew true ע hebrew true פ hebrew true צ hebrew true ק hebrew true ר hebrew true ש hebrew true ת hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a hebrew false o hebrew false e hebrew false i hebrew false y hebrew false u hebrew false kh spanish false gua italian false guo italian false ç italian false cha italian false cho italian false chu italian false j italian false dj spanish false sce french false sci french false ó french false è portuguese false'], 'a/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\t2020-01-24 12:25:47.065255433 -0800', 'b/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\t1969-12-31 16:00:00.000000000 -0800']
['Codec-15', 1, 1, 1, 1, ["final char mappedChar = this.map(str.charAt(index)); // HW rule check if (index > 1 && mappedChar != '0') { final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) { return 0; } } } return mappedChar;"], ["final char mappedChar = this.map(str.charAt(index)); // HW rule check if (index > 1 && mappedChar != '0') { for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { return 0; } if ('H'!=prevChar && 'W'!=prevChar) { break; } } } return mappedChar;"], ["final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {"], ["for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { if ('H'!=prevChar && 'W'!=prevChar) { break; }"], 'a/src/main/java/org/apache/commons/codec/language/Soundex.java', 'b/src/main/java/org/apache/commons/codec/language/Soundex.java']
['Codec-16', 1, 1, 1, 1, ['-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7 -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O 25, 26, 27, 28, 29, 30, 31, 32, }; /**'], ['-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7 -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O 25, 26, 27, 28, 29, 30, 31, // 50-57 P-V }; /**'], ['25, 26, 27, 28, 29, 30, 31, 32,'], ['25, 26, 27, 28, 29, 30, 31, // 50-57 P-V'], 'a/src/main/java/org/apache/commons/codec/binary/Base32.java', 'b/src/main/java/org/apache/commons/codec/binary/Base32.java']
['Codec-17', 1, 1, 1, 1, ['* @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException */ public static String newStringIso8859_1(final byte[] bytes) { return new String(bytes, Charsets.ISO_8859_1); } /**'], ['* @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException */ public static String newStringIso8859_1(final byte[] bytes) { return newString(bytes, Charsets.ISO_8859_1); } /**'], ['return new String(bytes, Charsets.ISO_8859_1);'], ['return newString(bytes, Charsets.ISO_8859_1);'], 'a/src/main/java/org/apache/commons/codec/binary/StringUtils.java', 'b/src/main/java/org/apache/commons/codec/binary/StringUtils.java']
['Codec-18', 1, 1, 1, 1, ['if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); } /**'], ['if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); } /**'], ['return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));'], ['return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());'], 'a/src/main/java/org/apache/commons/codec/binary/StringUtils.java', 'b/src/main/java/org/apache/commons/codec/binary/StringUtils.java']
['Jsoup-1', 1, 1, 1, 1, [' for (Node node: toMove) { element.removeChild(node); body().appendChild(new TextNode(" ", "")); body().appendChild(node); } }'], [' for (Node node: toMove) { element.removeChild(node); body().prependChild(node); body().prependChild(new TextNode(" ", "")); } }'], ['body().appendChild(new TextNode(" ", "")); body().appendChild(node);'], ['body().prependChild(node); body().prependChild(new TextNode(" ", ""));'], 'a/src/main/java/org/jsoup/nodes/Document.java', 'b/src/main/java/org/jsoup/nodes/Document.java']
['Jsoup-2', 1, 1, 1, 1, ['if (tag.isData()) { String data = tq.chompTo("</" + tagName); tq.chompTo(">"); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)'], ['if (tag.isData()) { String data = tq.chompTo("</" + tagName); tq.chompTo(">"); popStackToClose(tag); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)'], [''], ['popStackToClose(tag);'], 'a/src/main/java/org/jsoup/parser/Parser.java', 'b/src/main/java/org/jsoup/parser/Parser.java']
['Jsoup-3', 13, 13, 13, 13, ['public Element append(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node);', 'public Element prepend(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i);', 'public Element wrap(String html) { Validate.notEmpty(html); Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop', 'private final TokenQueue tq; private final Document doc; private String baseUri; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html);', '@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body */ private Document parse() { while (!tq.isEmpty()) {', 'Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor) { // create implicit parent around this child Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri);', 'if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node // otherwise, look up the stack for valid ancestors for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidParent(childTag)) { return true; } }', 'private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase();', "return false; // don't allow children to contain their parent (directly) return true; }", 'return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag', 'createBlock("TITLE").setAncestor("HEAD", "BODY").setContainDataOnly(); createInline("BASE").setAncestor("HEAD", "BODY").setEmpty(); createBlock("FRAME").setAncestor("FRAMESET").setEmpty(); createBlock("NOFRAMES").setAncestor("FRAMESET").setContainDataOnly();', 'createInline("TEXTAREA").setAncestor("FORM").setContainDataOnly(); createInline("LABEL").setAncestor("FORM").setOptionalClosing(); // not self createInline("BUTTON").setAncestor("FORM"); // bunch of excludes not defined createInline("OPTGROUP").setAncestor("SELECT"); createInline("OPTION").setAncestor("SELECT").setContainDataOnly(); createBlock("FIELDSET").setAncestor("FORM"); createInline("LEGEND").setAncestor("FIELDSET"); // other createInline("AREA").setEmpty(); // not an inline per-se createInline("PARAM").setAncestor("OBJECT").setEmpty(); createBlock("INS"); // only within body createBlock("DEL"); // only within body createBlock("DL"); createInline("DT").setAncestor("DL").setOptionalClosing(); createInline("DD").setAncestor("DL").setOptionalClosing(); createBlock("LI").setAncestor("UL", "OL").setOptionalClosing(); // only within OL or UL. // tables createBlock("TABLE"); // specific list of only includes (tr, td, thead etc) not implemented createBlock("CAPTION").setAncestor("TABLE"); createBlock("THEAD").setAncestor("TABLE").setOptionalClosing(); createBlock("TFOOT").setAncestor("TABLE").setOptionalClosing(); createBlock("TBODY").setAncestor("TABLE").setOptionalClosing(); createBlock("COLGROUP").setAncestor("TABLE").setOptionalClosing(); createBlock("COL").setAncestor("COLGROUP").setEmpty(); createBlock("TR").setAncestor("TABLE").setOptionalClosing(); createBlock("TH").setAncestor("TR").setOptionalClosing(); createBlock("TD").setAncestor("TR").setOptionalClosing(); } private static Tag createBlock(String tagName) {', 'return this; } }'], ['public Element append(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body(); for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node);', 'public Element prepend(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body(); List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i);', 'public Element wrap(String html) { Validate.notEmpty(html); Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body(); Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop', 'private final TokenQueue tq; private final Document doc; private String baseUri; private boolean relaxed = false; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html);', '@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body */ public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); parser.relaxed = true; return parser.parse(); } private Document parse() { while (!tq.isEmpty()) {', 'Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor && !relaxed) { // create implicit parent around this child Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri);', 'if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node if (childTag.requiresSpecificParent()) return stack.getLast().tag().isValidParent(childTag); // otherwise, look up the stack for valid ancestors for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidAncestor(childTag)) { return true; } }', 'private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag parent; // if not null, elements must be a direct child of parent private Tag(String tagName) { this.tagName = tagName.toLowerCase();', "return false; // don't allow children to contain their parent (directly) if (this.requiresSpecificParent() && this.getImplicitParent().equals(child)) return false; return true; }", 'return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean requiresSpecificParent() { return this.parent != null; } boolean isValidParent(Tag child) { return this.equals(child.parent); } boolean isValidAncestor(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag', 'createBlock("TITLE").setAncestor("HEAD", "BODY").setContainDataOnly(); createInline("BASE").setAncestor("HEAD", "BODY").setEmpty(); createBlock("FRAME").setParent("FRAMESET").setEmpty(); createBlock("NOFRAMES").setParent("FRAMESET").setContainDataOnly();', 'createInline("TEXTAREA").setAncestor("FORM").setContainDataOnly(); createInline("LABEL").setAncestor("FORM").setOptionalClosing(); // not self createInline("BUTTON").setAncestor("FORM"); // bunch of excludes not defined createInline("OPTGROUP").setParent("SELECT"); // only contain option createInline("OPTION").setParent("SELECT").setContainDataOnly(); createBlock("FIELDSET").setAncestor("FORM"); createInline("LEGEND").setAncestor("FIELDSET"); // other createInline("AREA").setEmpty(); // not an inline per-se createInline("PARAM").setParent("OBJECT").setEmpty(); createBlock("INS"); // only within body createBlock("DEL"); // only within body createBlock("DL"); createInline("DT").setParent("DL").setOptionalClosing(); // only within DL. createInline("DD").setParent("DL").setOptionalClosing(); // only within DL. createBlock("LI").setAncestor("UL", "OL").setOptionalClosing(); // only within OL or UL. // tables createBlock("TABLE"); // specific list of only includes (tr, td, thead etc) not implemented createBlock("CAPTION").setParent("TABLE"); createBlock("THEAD").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TFOOT").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TBODY").setParent("TABLE").setOptionalClosing(); // optional / implicit open too. just TR createBlock("COLGROUP").setParent("TABLE").setOptionalClosing(); // just COL createBlock("COL").setParent("COLGROUP").setEmpty(); createBlock("TR").setParent("TABLE").setOptionalClosing(); // just TH, TD createBlock("TH").setParent("TR").setOptionalClosing(); createBlock("TD").setParent("TR").setOptionalClosing(); } private static Tag createBlock(String tagName) {', 'return this; } private Tag setParent(String tagName) { parent = Tag.valueOf(tagName); setAncestor(tagName); return this; } }'], ['Element fragment = Parser.parseBodyFragment(html, baseUri).body();', 'Element fragment = Parser.parseBodyFragment(html, baseUri).body();', 'Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();', '', '', 'if (!validAncestor) {', 'if (parent2.isValidParent(childTag)) {', '', '', '', 'createBlock("FRAME").setAncestor("FRAMESET").setEmpty(); createBlock("NOFRAMES").setAncestor("FRAMESET").setContainDataOnly();', 'createInline("OPTGROUP").setAncestor("SELECT"); createInline("OPTION").setAncestor("SELECT").setContainDataOnly(); createInline("PARAM").setAncestor("OBJECT").setEmpty(); createInline("DT").setAncestor("DL").setOptionalClosing(); createInline("DD").setAncestor("DL").setOptionalClosing(); createBlock("CAPTION").setAncestor("TABLE"); createBlock("THEAD").setAncestor("TABLE").setOptionalClosing(); createBlock("TFOOT").setAncestor("TABLE").setOptionalClosing(); createBlock("TBODY").setAncestor("TABLE").setOptionalClosing(); createBlock("COLGROUP").setAncestor("TABLE").setOptionalClosing(); createBlock("COL").setAncestor("COLGROUP").setEmpty(); createBlock("TR").setAncestor("TABLE").setOptionalClosing(); createBlock("TH").setAncestor("TR").setOptionalClosing(); createBlock("TD").setAncestor("TR").setOptionalClosing();', ''], ['Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();', 'Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();', 'Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();', 'private boolean relaxed = false;', 'public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); parser.relaxed = true; return parser.parse(); }', 'if (!validAncestor && !relaxed) {', 'if (childTag.requiresSpecificParent()) return stack.getLast().tag().isValidParent(childTag); if (parent2.isValidAncestor(childTag)) {', 'private Tag parent; // if not null, elements must be a direct child of parent', 'if (this.requiresSpecificParent() && this.getImplicitParent().equals(child)) return false;', 'boolean requiresSpecificParent() { return this.parent != null; } return this.equals(child.parent); } boolean isValidAncestor(Tag child) {', 'createBlock("FRAME").setParent("FRAMESET").setEmpty(); createBlock("NOFRAMES").setParent("FRAMESET").setContainDataOnly();', 'createInline("OPTGROUP").setParent("SELECT"); // only contain option createInline("OPTION").setParent("SELECT").setContainDataOnly(); createInline("PARAM").setParent("OBJECT").setEmpty(); createInline("DT").setParent("DL").setOptionalClosing(); // only within DL. createInline("DD").setParent("DL").setOptionalClosing(); // only within DL. createBlock("CAPTION").setParent("TABLE"); createBlock("THEAD").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TFOOT").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TBODY").setParent("TABLE").setOptionalClosing(); // optional / implicit open too. just TR createBlock("COLGROUP").setParent("TABLE").setOptionalClosing(); // just COL createBlock("COL").setParent("COLGROUP").setEmpty(); createBlock("TR").setParent("TABLE").setOptionalClosing(); // just TH, TD createBlock("TH").setParent("TR").setOptionalClosing(); createBlock("TD").setParent("TR").setOptionalClosing();', 'private Tag setParent(String tagName) { parent = Tag.valueOf(tagName); setAncestor(tagName); return this; }'], 'a/src/main/java/org/jsoup/parser/Tag.java', 'b/src/main/java/org/jsoup/parser/Tag.java']
['Jsoup-4', 2, 2, 2, 2, ['} catch (NumberFormatException e) { } // skip } else { String name = m.group(1).toLowerCase(); if (full.containsKey(name)) charval = full.get(name); }', ' for (Object[] entity : baseArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); baseByVal.put(c, ((String) entity[0]).toLowerCase()); } for (Object[] entity : fullArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); full.put((String) entity[0], c); fullByVal.put(c, ((String) entity[0]).toLowerCase()); } }'], ['} catch (NumberFormatException e) { } // skip } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }', ' for (Object[] entity : baseArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); baseByVal.put(c, ((String) entity[0])); } for (Object[] entity : fullArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); full.put((String) entity[0], c); fullByVal.put(c, ((String) entity[0])); } }'], ['String name = m.group(1).toLowerCase();', 'baseByVal.put(c, ((String) entity[0]).toLowerCase()); fullByVal.put(c, ((String) entity[0]).toLowerCase());'], ['String name = m.group(1);', 'baseByVal.put(c, ((String) entity[0])); fullByVal.put(c, ((String) entity[0]));'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-5', 1, 1, 1, 1, ['if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); return null; }'], ['if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance(); return null; }'], ['tq.consume();'], ['if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance();'], 'a/src/main/java/org/jsoup/parser/Parser.java', 'b/src/main/java/org/jsoup/parser/Parser.java']
['Jsoup-6', 1, 1, 1, 1, [' if (charval != -1 || charval > 0xFFFF) { // out of range String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); } } m.appendTail(accum);'], [' if (charval != -1 || charval > 0xFFFF) { // out of range String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string } } m.appendTail(accum);'], ['m.appendReplacement(accum, c); m.appendReplacement(accum, m.group(0));'], ['m.appendReplacement(accum, Matcher.quoteReplacement(c)); m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-7', 3, 3, 3, 3, [' import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder;', 'normaliseTextNodes(htmlEl); normaliseTextNodes(this); return this; }', '} // merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html> // ensure parented by <html> // fast method to get first by tag name, used for html, head, body finders private Element findFirstElementByTagName(String tag, Node node) {'], [' import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import org.jsoup.select.Elements; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder;', 'normaliseTextNodes(htmlEl); normaliseTextNodes(this); normaliseStructure("head", htmlEl); normaliseStructure("body", htmlEl); return this; }', '} // merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html> private void normaliseStructure(String tag, Element htmlEl) { Elements elements = this.getElementsByTag(tag); Element master = elements.first(); // will always be available as created above if not existent if (elements.size() > 1) { // dupes, move contents to master List<Node> toMove = new ArrayList<Node>(); for (int i = 1; i < elements.size(); i++) { Node dupe = elements.get(i); for (Node node : dupe.childNodes) toMove.add(node); dupe.remove(); } for (Node dupe : toMove) master.appendChild(dupe); } // ensure parented by <html> if (!master.parent().equals(htmlEl)) { htmlEl.appendChild(master); // includes remove() } } // fast method to get first by tag name, used for html, head, body finders private Element findFirstElementByTagName(String tag, Node node) {'], ['', '', ''], ['import org.jsoup.select.Elements;', 'normaliseStructure("head", htmlEl); normaliseStructure("body", htmlEl);', 'private void normaliseStructure(String tag, Element htmlEl) { Elements elements = this.getElementsByTag(tag); Element master = elements.first(); // will always be available as created above if not existent if (elements.size() > 1) { // dupes, move contents to master List<Node> toMove = new ArrayList<Node>(); for (int i = 1; i < elements.size(); i++) { Node dupe = elements.get(i); for (Node node : dupe.childNodes) toMove.add(node); dupe.remove(); } for (Node dupe : toMove) master.appendChild(dupe); } if (!master.parent().equals(htmlEl)) { htmlEl.appendChild(master); // includes remove() } }'], 'a/src/main/java/org/jsoup/nodes/Document.java', 'b/src/main/java/org/jsoup/nodes/Document.java']
['Jsoup-8', 1, 1, 1, 1, ['} protected void outerHtml(StringBuilder accum) { new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings /** Get the outer HTML of this node.'], ['} protected void outerHtml(StringBuilder accum) { new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document("")).outputSettings(); } /** Get the outer HTML of this node.'], ['new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);'], ['new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document("")).outputSettings(); }'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-9', 1, 1, 1, 1, ['private static final Map<Character, String> xhtmlByVal; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?"); static String escape(String string, Document.OutputSettings out) { return escape(string, out.encoder(), out.escapeMode());'], ['private static final Map<Character, String> xhtmlByVal; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?"); static String escape(String string, Document.OutputSettings out) { return escape(string, out.encoder(), out.escapeMode());'], ['private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?");'], ['private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?");'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-10', 1, 1, 1, 1, ["return abs.toExternalForm(); } // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) {"], ['return abs.toExternalForm(); } // workaround: java resolves \'//path/file + ?foo\' to \'//path/?foo\', not \'//path/file?foo\' as desired if (relUrl.startsWith("?")) relUrl = base.getPath() + relUrl; URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) {'], [''], ['if (relUrl.startsWith("?")) relUrl = base.getPath() + relUrl;'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-11', 4, 4, 4, 4, ['if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements elements.add(root); combinator(tq.consume().toString()); } else { addElements(findElements()); // chomp first element matcher off queue }', 'return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { // unhandled throw new SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder()); }', '} // :not(selector) // direct child descendants private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {', '} // exclude set. package open so that Elements can implement .not() selector. public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {'], ['if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements elements.add(root); combinator(tq.consume().toString()); } else if (tq.matches(":has(")) { elements.addAll(root.getAllElements()); } else { addElements(findElements()); // chomp first element matcher off queue }', 'return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not(); } else { // unhandled throw new SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder()); }', '} // :not(selector) private Elements not() { tq.consume(":not"); String subQuery = tq.chompBalanced(\'(\', \')\'); Validate.notEmpty(subQuery, ":not(selector) subselect must not be empty"); return filterOut(root.getAllElements(), select(subQuery, root)); } // direct child descendants private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {', '} // exclude set. package open so that Elements can implement .not() selector. static Elements filterOut(Collection<Element> elements, Collection<Element> outs) { Elements output = new Elements(); for (Element el: elements) { boolean found = false; for (Element out: outs) { if (el.equals(out)) { found = true; break; } } if (!found) output.add(el); } return output; } public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {'], ['', '', '', ''], ['} else if (tq.matches(":has(")) { elements.addAll(root.getAllElements());', '} else if (tq.matches(":not(")) { return not();', 'private Elements not() { tq.consume(":not"); String subQuery = tq.chompBalanced(\'(\', \')\'); Validate.notEmpty(subQuery, ":not(selector) subselect must not be empty"); return filterOut(root.getAllElements(), select(subQuery, root)); }', 'static Elements filterOut(Collection<Element> elements, Collection<Element> outs) { Elements output = new Elements(); for (Element el: elements) { boolean found = false; for (Element out: outs) { if (el.equals(out)) { found = true; break; } } if (!found) output.add(el); } return output; }'], 'a/src/main/java/org/jsoup/select/Selector.java', 'b/src/main/java/org/jsoup/select/Selector.java']
['Jsoup-12', 2, 2, 2, 2, [" private void combinator(char combinator) { tq.consumeWhitespace(); String subQuery = tq.consumeToAny(combinators); Elements output; if (combinator == '>')", 'elements.clear(); elements.addAll(output); } private Elements findElements() { if (tq.matchChomp("#")) {'], [" private void combinator(char combinator) { tq.consumeWhitespace(); String subQuery = consumeSubQuery(); // support multi > childs Elements output; if (combinator == '>')", 'elements.clear(); elements.addAll(output); } private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced(\'(\', \')\')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced(\'[\', \']\')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } private Elements findElements() { if (tq.matchChomp("#")) {'], ['String subQuery = tq.consumeToAny(combinators);', ''], ['String subQuery = consumeSubQuery(); // support multi > childs', 'private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced(\'(\', \')\')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced(\'[\', \']\')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); }'], 'a/src/main/java/org/jsoup/select/Selector.java', 'b/src/main/java/org/jsoup/select/Selector.java']
['Jsoup-13', 1, 1, 1, 1, ['public boolean hasAttr(String attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }'], ['public boolean hasAttr(String attributeKey) { Validate.notNull(attributeKey); if (attributeKey.toLowerCase().startsWith("abs:")) { String key = attributeKey.substring("abs:".length()); if (attributes.hasKey(key) && !absUrl(key).equals("")) return true; } return attributes.hasKey(attributeKey); }'], [''], ['if (attributeKey.toLowerCase().startsWith("abs:")) { String key = attributeKey.substring("abs:".length()); if (attributes.hasKey(key) && !absUrl(key).equals("")) return true; }'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-14', 2, 2, 2, 2, ['return tagPending.tagName.equals(lastStartTag.tagName); } boolean isTrackErrors() { return trackErrors;', 'if (r.matches(\'/\')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); // diverge from spec: got a start tag, but there\'s no appropriate end tag (</title>), so rather than // consuming to EOF; break out here } else { t.emit("<"); t.transition(Rcdata);'], ['return tagPending.tagName.equals(lastStartTag.tagName); } String appropriateEndTagName() { return lastStartTag.tagName; } boolean isTrackErrors() { return trackErrors;', 'if (r.matches(\'/\')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) { // diverge from spec: got a start tag, but there\'s no appropriate end tag (</title>), so rather than // consuming to EOF; break out here t.tagPending = new Token.EndTag(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); // undo "<" t.transition(Data); } else { t.emit("<"); t.transition(Rcdata);'], ['', ''], ['String appropriateEndTagName() { return lastStartTag.tagName; }', '} else if (r.matchesLetter() && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) { t.tagPending = new Token.EndTag(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); // undo "<" t.transition(Data);'], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-15', 1, 1, 1, 1, ['if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "style", "title")) { return tb.process(t, InHead); } else if (name.equals("body")) { tb.error(this);'], ['if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title")) { return tb.process(t, InHead); } else if (name.equals("body")) { tb.error(this);'], ['} else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "style", "title")) {'], ['} else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title")) {'], 'a/src/main/java/org/jsoup/parser/TreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/TreeBuilderState.java']
['Jsoup-16', 3, 3, 3, 3, ['package org.jsoup.nodes; import org.jsoup.helper.StringUtil; /** * A {@code <!DOCTPYE>} node.', 'public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);', ' @Override void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) { accum.append("<!DOCTYPE html"); if (!StringUtil.isBlank(attr("publicId"))) accum.append(" PUBLIC \\"").append(attr("publicId")).append("\\""); if (!StringUtil.isBlank(attr("systemId"))) accum.append(\' \').append(attr("systemId")).append("\\""); accum.append(\'>\'); }'], ['package org.jsoup.nodes; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; /** * A {@code <!DOCTPYE>} node.', 'public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); Validate.notEmpty(name); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);', ' @Override void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) { accum.append("<!DOCTYPE ").append(attr("name")); if (!StringUtil.isBlank(attr("publicId"))) accum.append(" PUBLIC \\"").append(attr("publicId")).append("\\""); if (!StringUtil.isBlank(attr("systemId"))) accum.append(" \\"").append(attr("systemId")).append("\\""); accum.append(\'>\'); }'], ['', '', 'accum.append("<!DOCTYPE html"); accum.append(\' \').append(attr("systemId")).append("\\"");'], ['import org.jsoup.helper.Validate;', 'Validate.notEmpty(name);', 'accum.append("<!DOCTYPE ").append(attr("name")); accum.append(" \\"").append(attr("systemId")).append("\\"");'], 'a/src/main/java/org/jsoup/nodes/DocumentType.java', 'b/src/main/java/org/jsoup/nodes/DocumentType.java']
['Jsoup-17', 1, 1, 1, 1, ['} }; private static String nullString = String.valueOf(0x0000); abstract boolean process(Token t, TreeBuilder tb);'], ["} }; private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, TreeBuilder tb);"], ['private static String nullString = String.valueOf(0x0000);'], ["private static String nullString = String.valueOf('\\u0000');"], 'a/src/main/java/org/jsoup/parser/TreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/TreeBuilderState.java']
['Jsoup-18', 2, 2, 2, 2, [' CharacterReader(String input) { Validate.notNull(input); this.input = input; this.length = input.length();', '} String consumeToEnd() { String data = input.substring(pos, input.length() - 1); pos = input.length(); return data; }'], [' CharacterReader(String input) { Validate.notNull(input); input = input.replaceAll("\\r\\n?", "\\n"); // normalise carriage returns to newlines this.input = input; this.length = input.length();', '} String consumeToEnd() { String data = input.substring(pos, input.length()); pos = input.length(); return data; }'], ['', 'String data = input.substring(pos, input.length() - 1);'], ['input = input.replaceAll("\\r\\n?", "\\n"); // normalise carriage returns to newlines', 'String data = input.substring(pos, input.length());'], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-19', 1, 1, 1, 1, ['// try to resolve relative urls to abs, and optionally update the attribute so output html has abs. // rels without a baseuri get removed String value = el.absUrl(attr.getKey()); if (!preserveRelativeLinks) attr.setValue(value);'], ['// try to resolve relative urls to abs, and optionally update the attribute so output html has abs. // rels without a baseuri get removed String value = el.absUrl(attr.getKey()); if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols if (!preserveRelativeLinks) attr.setValue(value);'], [''], ['if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols'], 'a/src/main/java/org/jsoup/safety/Whitelist.java', 'b/src/main/java/org/jsoup/safety/Whitelist.java']
['Jsoup-20', 1, 1, 1, 1, ["// there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight // into head mode doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);"], ["// there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight // into head mode if (docData.charAt(0) == 65279) docData = docData.substring(1); doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);"], [''], ['if (docData.charAt(0) == 65279) docData = docData.substring(1);'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-21', 3, 3, 3, 3, ['this.evaluators.addAll(evaluators); } public void add(Evaluator e) { evaluators.add(e);', '// hierarchy and extras boolean seenWhite = tq.consumeWhitespace(); if (tq.matchChomp(",")) { CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals); evals.clear(); evals.add(or); while (!tq.isEmpty()) { String subQuery = tq.chompTo(","); or.add(parse(subQuery)); } } else if (tq.matchesAny(combinators)) { combinator(tq.consume()); } else if (seenWhite) { combinator(\' \');', 'evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e))); else if (combinator == \'~\') evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e))); else throw new Selector.SelectorParseException("Unknown combinator: " + combinator); }'], ['this.evaluators.addAll(evaluators); } Or() { super(); } public void add(Evaluator e) { evaluators.add(e);', "// hierarchy and extras boolean seenWhite = tq.consumeWhitespace(); if (tq.matchesAny(combinators)) { combinator(tq.consume()); } else if (seenWhite) { combinator(' ');", 'evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e))); else if (combinator == \'~\') evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e))); else if (combinator == \',\') { // group or CombiningEvaluator.Or or; if (e instanceof CombiningEvaluator.Or) { or = (CombiningEvaluator.Or) e; or.add(f); } else { or = new CombiningEvaluator.Or(); or.add(e); or.add(f); } evals.add(or); } else throw new Selector.SelectorParseException("Unknown combinator: " + combinator); }'], ['', 'if (tq.matchChomp(",")) { CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals); evals.clear(); evals.add(or); while (!tq.isEmpty()) { String subQuery = tq.chompTo(","); or.add(parse(subQuery)); } } else if (tq.matchesAny(combinators)) {', ''], ['Or() { super(); }', 'if (tq.matchesAny(combinators)) {', "else if (combinator == ',') { // group or CombiningEvaluator.Or or; if (e instanceof CombiningEvaluator.Or) { or = (CombiningEvaluator.Or) e; or.add(f); } else { or = new CombiningEvaluator.Or(); or.add(e); or.add(f); } evals.add(or); }"], 'a/src/main/java/org/jsoup/select/QueryParser.java', 'b/src/main/java/org/jsoup/select/QueryParser.java']
['Jsoup-22', 6, 6, 6, 6, ['* @return sibling elements */ public Elements siblingElements() { return parent().children(); } /**', '* @see #previousElementSibling() */ public Element nextElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '* @see #nextElementSibling() */ public Element previousElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '@return node siblings. If the node has no parent, returns an empty list. */ public List<Node> siblingNodes() { return parent().childNodes(); } /**', '@return the previous sibling, or null if this is the first sibling */ public Node previousSibling() { List<Node> siblings = parentNode.childNodes; Integer index = siblingIndex();', 'contents = new ArrayList<Element>(); } public Elements(Collection<Element> elements) { contents = new ArrayList<Element>(elements);'], ['* @return sibling elements */ public Elements siblingElements() { if (parentNode == null) return new Elements(0); List<Element> elements = parent().children(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el); return siblings; } /**', '* @see #previousElementSibling() */ public Element nextElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '* @see #nextElementSibling() */ public Element previousElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '@return node siblings. If the node has no parent, returns an empty list. */ public List<Node> siblingNodes() { if (parentNode == null) return Collections.emptyList(); List<Node> nodes = parentNode.childNodes; List<Node> siblings = new ArrayList<Node>(nodes.size() - 1); for (Node node: nodes) if (node != this) siblings.add(node); return siblings; } /**', '@return the previous sibling, or null if this is the first sibling */ public Node previousSibling() { if (parentNode == null) return null; // root List<Node> siblings = parentNode.childNodes; Integer index = siblingIndex();', 'contents = new ArrayList<Element>(); } public Elements(int initialCapacity) { contents = new ArrayList<Element>(initialCapacity); } public Elements(Collection<Element> elements) { contents = new ArrayList<Element>(elements);'], ['return parent().children();', '', '', 'return parent().childNodes();', '', ''], ['if (parentNode == null) return new Elements(0); List<Element> elements = parent().children(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el); return siblings;', 'if (parentNode == null) return null;', 'if (parentNode == null) return null;', 'if (parentNode == null) return Collections.emptyList(); List<Node> nodes = parentNode.childNodes; List<Node> siblings = new ArrayList<Node>(nodes.size() - 1); for (Node node: nodes) if (node != this) siblings.add(node); return siblings;', 'if (parentNode == null) return null; // root', 'public Elements(int initialCapacity) { contents = new ArrayList<Element>(initialCapacity); }'], 'a/src/main/java/org/jsoup/select/Elements.java', 'b/src/main/java/org/jsoup/select/Elements.java']
['Jsoup-23', 2, 2, 2, 2, ['return input.substring(start, pos); } String consumeHexSequence() { int start = pos;', "} } else { // named // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found String nameRef = reader.consumeLetterSequence(); String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches boolean looksLegit = reader.matches(';'); boolean found = false;"], ["return input.substring(start, pos); } String consumeLetterThenDigitSequence() { int start = pos; while (!isEmpty()) { char c = input.charAt(pos); if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) pos++; else break; } while (!isEmpty()) { char c = input.charAt(pos); if (c >= '0' && c <= '9') pos++; else break; } return input.substring(start, pos); } String consumeHexSequence() { int start = pos;", "} } else { // named // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found String nameRef = reader.consumeLetterThenDigitSequence(); String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches boolean looksLegit = reader.matches(';'); boolean found = false;"], ['', 'String nameRef = reader.consumeLetterSequence();'], ["String consumeLetterThenDigitSequence() { int start = pos; while (!isEmpty()) { char c = input.charAt(pos); if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) pos++; else break; } while (!isEmpty()) { char c = input.charAt(pos); if (c >= '0' && c <= '9') pos++; else break; } return input.substring(start, pos); }", 'String nameRef = reader.consumeLetterThenDigitSequence();'], 'a/src/main/java/org/jsoup/parser/Tokeniser.java', 'b/src/main/java/org/jsoup/parser/Tokeniser.java']
['Jsoup-24', 1, 1, 1, 1, ['String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); r.advance(); return; }'], ['String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); return; }'], ['r.advance();'], [''], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-25', 1, 1, 1, 1, ['private static final String[] formatAsInlineTags = { "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style" }; private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title"}; static { // creates'], ['private static final String[] formatAsInlineTags = { "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style" }; private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title", "textarea"}; static { // creates'], ['private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title"};'], ['private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title", "textarea"};'], 'a/src/main/java/org/jsoup/parser/Tag.java', 'b/src/main/java/org/jsoup/parser/Tag.java']
['Jsoup-26', 1, 1, 1, 1, ['Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); copySafeNodes(dirtyDocument.body(), clean.body()); return clean;'], ["Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body. copySafeNodes(dirtyDocument.body(), clean.body()); return clean;"], [''], ["if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body."], 'a/src/main/java/org/jsoup/safety/Cleaner.java', 'b/src/main/java/org/jsoup/safety/Cleaner.java']
['Jsoup-27', 1, 1, 1, 1, ['Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); charset = charset.toUpperCase(Locale.ENGLISH); return charset; } return null; }'], ['Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; } return null; }'], ['return charset;'], ['if (Charset.isSupported(charset)) return charset; if (Charset.isSupported(charset)) return charset;'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-28', 6, 6, 6, 6, ['package org.jsoup.nodes; import java.io.IOException; import java.io.InputStream;', '* @return true if a known named entity in the base set * @see #isNamedEntity(String) */ /** * Get the Character value of the named entity', '* @return */ static String unescape(String string, boolean strict) { if (!string.contains("&")) return string; Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); StringBuffer accum = new StringBuffer(string.length()); while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); } } m.appendTail(accum); return accum.toString(); } // xhtml has restricted entities', '* @param inAttribute if the string is to be escaped in strict mode (as attributes are) * @return an unescaped string */ /** * @param bodyHtml HTML to parse', '} else { // named // get as many letters as possible, and look for matching entities. String nameRef = reader.consumeLetterThenDigitSequence(); String origNameRef = new String(nameRef); boolean looksLegit = reader.matches(\';\'); // found if a base named entity without a ;, or an extended entity with the ;. boolean found = false; while (nameRef.length() > 0 && !found) { if (Entities.isNamedEntity(nameRef)) found = true; else { nameRef = nameRef.substring(0, nameRef.length()-1); reader.unconsume(); } } if (!found) { reader.rewindToMark(); if (looksLegit) // named with semicolon characterReferenceError(String.format("invalid named referenece \'%s\'", origNameRef)); return null; } if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\'=\', \'-\', \'_\'))) {', '* @param inAttribute * @return unescaped string from reader */ }'], ['package org.jsoup.nodes; import org.jsoup.parser.Parser; import java.io.IOException; import java.io.InputStream;', '* @return true if a known named entity in the base set * @see #isNamedEntity(String) */ public static boolean isBaseNamedEntity(String name) { return base.containsKey(name); } /** * Get the Character value of the named entity', '* @return */ static String unescape(String string, boolean strict) { return Parser.unescapeEntities(string, strict); } // xhtml has restricted entities', '* @param inAttribute if the string is to be escaped in strict mode (as attributes are) * @return an unescaped string */ public static String unescapeEntities(String string, boolean inAttribute) { Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking()); return tokeniser.unescapeEntities(inAttribute); } /** * @param bodyHtml HTML to parse', '} else { // named // get as many letters as possible, and look for matching entities. String nameRef = reader.consumeLetterThenDigitSequence(); boolean looksLegit = reader.matches(\';\'); // found if a base named entity without a ;, or an extended entity with the ;. boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit)); if (!found) { reader.rewindToMark(); if (looksLegit) // named with semicolon characterReferenceError(String.format("invalid named referenece \'%s\'", nameRef)); return null; } if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\'=\', \'-\', \'_\'))) {', "* @param inAttribute * @return unescaped string from reader */ String unescapeEntities(boolean inAttribute) { StringBuilder builder = new StringBuilder(); while (!reader.isEmpty()) { builder.append(reader.consumeTo('&')); if (reader.matches('&')) { reader.consume(); Character c = consumeCharacterReference(null, inAttribute); if (c == null) builder.append('&'); else builder.append(c); } } return builder.toString(); } }"], ['', '', 'if (!string.contains("&")) return string; Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); StringBuffer accum = new StringBuffer(string.length()); while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); } } m.appendTail(accum); return accum.toString();', '', 'String origNameRef = new String(nameRef); boolean found = false; while (nameRef.length() > 0 && !found) { if (Entities.isNamedEntity(nameRef)) found = true; else { nameRef = nameRef.substring(0, nameRef.length()-1); reader.unconsume(); } } characterReferenceError(String.format("invalid named referenece \'%s\'", origNameRef));', ''], ['import org.jsoup.parser.Parser;', 'public static boolean isBaseNamedEntity(String name) { return base.containsKey(name); }', 'return Parser.unescapeEntities(string, strict);', 'public static String unescapeEntities(String string, boolean inAttribute) { Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking()); return tokeniser.unescapeEntities(inAttribute); }', 'boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit)); characterReferenceError(String.format("invalid named referenece \'%s\'", nameRef));', "String unescapeEntities(boolean inAttribute) { StringBuilder builder = new StringBuilder(); while (!reader.isEmpty()) { builder.append(reader.consumeTo('&')); if (reader.matches('&')) { reader.consume(); Character c = consumeCharacterReference(null, inAttribute); if (c == null) builder.append('&'); else builder.append(c); } } return builder.toString(); }"], 'a/src/main/java/org/jsoup/parser/Tokeniser.java', 'b/src/main/java/org/jsoup/parser/Tokeniser.java']
['Jsoup-29', 2, 2, 2, 2, ['package org.jsoup.nodes; import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import org.jsoup.select.Elements;', 'public String title() { // title is a preserve whitespace tag (for document output), but normalised here Element titleEl = getElementsByTag("title").first(); return titleEl != null ? titleEl.text().trim() : ""; } /**'], ['package org.jsoup.nodes; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import org.jsoup.select.Elements;', 'public String title() { // title is a preserve whitespace tag (for document output), but normalised here Element titleEl = getElementsByTag("title").first(); return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : ""; } /**'], ['', 'return titleEl != null ? titleEl.text().trim() : "";'], ['import org.jsoup.helper.StringUtil;', 'return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : "";'], 'a/src/main/java/org/jsoup/nodes/Document.java', 'b/src/main/java/org/jsoup/nodes/Document.java']
['Jsoup-30', 3, 3, 3, 3, ['import org.jsoup.helper.Validate; import org.jsoup.nodes.*; import org.jsoup.parser.Tag; import java.util.List;', '/** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination. */ private int copySafeNodes(Element root, Element destination) { List<Node> sourceChildren = root.childNodes(); int numDiscarded = 0; for (Node source : sourceChildren) { if (source instanceof Element) { Element sourceEl = (Element) source;', 'destination.appendChild(destChild); numDiscarded += meta.numAttribsDiscarded; numDiscarded += copySafeNodes(sourceEl, destChild); } else { numDiscarded++; numDiscarded += copySafeNodes(sourceEl, destination); } } else if (source instanceof TextNode) { TextNode sourceText = (TextNode) source; TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri()); destination.appendChild(destText); } } return numDiscarded; } private ElementMeta createSafeElement(Element sourceEl) {'], ['import org.jsoup.helper.Validate; import org.jsoup.nodes.*; import org.jsoup.parser.Tag; import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import java.util.List;', '/** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination. */ private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0; private final Element root; private Element destination; // current element to append nodes to private CleaningVisitor(Element root, Element destination) { this.root = root; this.destination = destination; } public void head(Node source, int depth) { if (source instanceof Element) { Element sourceEl = (Element) source;', "destination.appendChild(destChild); numDiscarded += meta.numAttribsDiscarded; destination = destChild; } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded. numDiscarded++; } } else if (source instanceof TextNode) { TextNode sourceText = (TextNode) source; TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri()); destination.appendChild(destText); } else { // else, we don't care about comments, xml proc instructions, etc numDiscarded++; } } public void tail(Node source, int depth) { if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) { destination = destination.parent(); // would have descended, so pop destination stack } } } private int copySafeNodes(Element source, Element dest) { CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest); NodeTraversor traversor = new NodeTraversor(cleaningVisitor); traversor.traverse(source); return cleaningVisitor.numDiscarded; } private ElementMeta createSafeElement(Element sourceEl) {"], ['', 'private int copySafeNodes(Element root, Element destination) { List<Node> sourceChildren = root.childNodes(); int numDiscarded = 0; for (Node source : sourceChildren) {', 'numDiscarded += copySafeNodes(sourceEl, destChild); } else { numDiscarded += copySafeNodes(sourceEl, destination); return numDiscarded;'], ['import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor;', 'private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0; private final Element root; private Element destination; // current element to append nodes to private CleaningVisitor(Element root, Element destination) { this.root = root; this.destination = destination; } public void head(Node source, int depth) {', "destination = destChild; } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded. } else { // else, we don't care about comments, xml proc instructions, etc numDiscarded++; public void tail(Node source, int depth) { if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) { destination = destination.parent(); // would have descended, so pop destination stack } } } private int copySafeNodes(Element source, Element dest) { CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest); NodeTraversor traversor = new NodeTraversor(cleaningVisitor); traversor.traverse(source); return cleaningVisitor.numDiscarded;"], 'a/src/main/java/org/jsoup/safety/Cleaner.java', 'b/src/main/java/org/jsoup/safety/Cleaner.java']
['Jsoup-31', 3, 3, 3, 3, [' static class Comment extends Token { final StringBuilder data = new StringBuilder(); Comment() { type = TokenType.Comment;', "// rewind to capture character that lead us here r.unconsume(); Token.Comment comment = new Token.Comment(); comment.data.append(r.consumeTo('>')); // todo: replace nullChar with replaceChar t.emit(comment);", 'void insert(Token.Comment commentToken) { Comment comment = new Comment(commentToken.getData(), baseUri); Node insert = comment; insertNode(insert); }'], [' static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; Comment() { type = TokenType.Comment;', "// rewind to capture character that lead us here r.unconsume(); Token.Comment comment = new Token.Comment(); comment.bogus = true; comment.data.append(r.consumeTo('>')); // todo: replace nullChar with replaceChar t.emit(comment);", 'void insert(Token.Comment commentToken) { Comment comment = new Comment(commentToken.getData(), baseUri); Node insert = comment; if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml) String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!")); } } insertNode(insert); }'], ['', '', ''], ['boolean bogus = false;', 'comment.bogus = true;', 'if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml) String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!")); } }'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-32', 1, 1, 1, 1, ['@Override public Element clone() { Element clone = (Element) super.clone(); clone.classNames(); return clone; } }'], ['@Override public Element clone() { Element clone = (Element) super.clone(); clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames return clone; } }'], ['clone.classNames();'], ['clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-33', 1, 1, 1, 1, ['if (startTag.isSelfClosing()) { Element el = insertEmpty(startTag); stack.add(el); tokeniser.emit(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in. emitted for yielded processing return el; }'], ['if (startTag.isSelfClosing()) { Element el = insertEmpty(startTag); stack.add(el); tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data tokeniser.emit(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in. emitted for yielded processing return el; }'], [''], ['tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-34', 1, 1, 1, 1, ['while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; if (offset < length) { for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) // found full sequence return offset - pos;'], ['while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; if (offset < length && last <= length) { for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) // found full sequence return offset - pos;'], ['if (offset < length) {'], ['if (offset < length && last <= length) {'], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-35', 1, 1, 1, 1, ['} Element adopter = new Element(formatEl.tag(), tb.getBaseUri()); Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.'], ['} Element adopter = new Element(formatEl.tag(), tb.getBaseUri()); adopter.attributes().addAll(formatEl.attributes()); Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.'], [''], ['adopter.attributes().addAll(formatEl.attributes());'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-36', 4, 4, 4, 4, ['import java.io.*; import java.nio.ByteBuffer; import java.nio.charset.Charset; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Locale;', '* */ public class DataUtil { private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*\\"?([^\\\\s;\\"]*)"); static final String defaultCharset = "UTF-8"; // used if not found in header or meta charset private static final int bufferSize = 0x20000; // ~130K.', 'String foundCharset; if (meta.hasAttr("http-equiv")) { foundCharset = getCharsetFromContentType(meta.attr("content")); } else { foundCharset = meta.attr("charset"); } if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode charsetName = foundCharset; byteData.rewind(); docData = Charset.forName(foundCharset).decode(byteData).toString();', 'Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; // if our advanced charset matching fails.... we just take the default } return null; }'], ['import java.io.*; import java.nio.ByteBuffer; import java.nio.charset.Charset; import java.nio.charset.IllegalCharsetNameException; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Locale;', '* */ public class DataUtil { private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*(?:\\"|\')?([^\\\\s,;\\"\']*)"); static final String defaultCharset = "UTF-8"; // used if not found in header or meta charset private static final int bufferSize = 0x20000; // ~130K.', 'String foundCharset; if (meta.hasAttr("http-equiv")) { foundCharset = getCharsetFromContentType(meta.attr("content")); if (foundCharset == null && meta.hasAttr("charset")) { try { if (Charset.isSupported(meta.attr("charset"))) { foundCharset = meta.attr("charset"); } } catch (IllegalCharsetNameException e) { foundCharset = null; } } } else { foundCharset = meta.attr("charset"); } if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode foundCharset = foundCharset.trim().replaceAll("[\\"\']", ""); charsetName = foundCharset; byteData.rewind(); docData = Charset.forName(foundCharset).decode(byteData).toString();', 'Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); charset = charset.replace("charset=", ""); if (charset.isEmpty()) return null; try { if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; } catch (IllegalCharsetNameException e) { // if our advanced charset matching fails.... we just take the default return null; } } return null; }'], ['', 'private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*\\"?([^\\\\s;\\"]*)");', '', ''], ['import java.nio.charset.IllegalCharsetNameException;', 'private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*(?:\\"|\')?([^\\\\s,;\\"\']*)");', 'if (foundCharset == null && meta.hasAttr("charset")) { try { if (Charset.isSupported(meta.attr("charset"))) { foundCharset = meta.attr("charset"); } } catch (IllegalCharsetNameException e) { foundCharset = null; } } foundCharset = foundCharset.trim().replaceAll("[\\"\']", "");', 'charset = charset.replace("charset=", ""); if (charset.isEmpty()) return null; try { } catch (IllegalCharsetNameException e) { return null; }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-37', 1, 1, 1, 1, ['public String html() { StringBuilder accum = new StringBuilder(); html(accum); return accum.toString().trim(); } private void html(StringBuilder accum) {'], ['public String html() { StringBuilder accum = new StringBuilder(); html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); } private void html(StringBuilder accum) {'], ['return accum.toString().trim();'], ['return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-38', 1, 1, 1, 1, ['tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals("image")) { return tb.process(startTag.name("img")); // change <image> to <img>, unless in svg } else if (name.equals("isindex")) { // how much do we care about the early 90s? tb.error(this);'], ['tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals("image")) { if (tb.getFromStack("svg") == null) return tb.process(startTag.name("img")); // change <image> to <img>, unless in svg else tb.insert(startTag); } else if (name.equals("isindex")) { // how much do we care about the early 90s? tb.error(this);'], [''], ['if (tb.getFromStack("svg") == null) else tb.insert(startTag);'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-39', 1, 1, 1, 1, ['docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; } if (doc == null) { doc = parser.parseInput(docData, baseUri);'], ['docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; doc = null; } if (doc == null) { doc = parser.parseInput(docData, baseUri);'], [''], ['doc = null;'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-40', 1, 1, 1, 1, ['public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); Validate.notEmpty(name); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);'], ['public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);'], ['Validate.notEmpty(name);'], [''], 'a/src/main/java/org/jsoup/nodes/DocumentType.java', 'b/src/main/java/org/jsoup/nodes/DocumentType.java']
['Jsoup-41', 1, 1, 1, 1, [' Element element = (Element) o; return this == o; } @Override'], [' Element element = (Element) o; return tag.equals(element.tag); } @Override'], ['return this == o;'], ['return tag.equals(element.tag);'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-42', 2, 2, 2, 2, ['// iterate the form control elements and accumulate their values for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type");', '} else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { // only add checkbox or radio if they have the checked attribute if (el.hasAttr("checked")) { final String val = el.val(); data.add(HttpConnection.KeyVal.create(name, val)); } } else {'], ['// iterate the form control elements and accumulate their values for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable if (el.hasAttr("disabled")) continue; // skip disabled form inputs String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type");', '} else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { // only add checkbox or radio if they have the checked attribute if (el.hasAttr("checked")) { final String val = el.val().length() > 0 ? el.val() : "on"; data.add(HttpConnection.KeyVal.create(name, val)); } } else {'], ['', 'final String val = el.val();'], ['if (el.hasAttr("disabled")) continue; // skip disabled form inputs', 'final String val = el.val().length() > 0 ? el.val() : "on";'], 'a/src/main/java/org/jsoup/nodes/FormElement.java', 'b/src/main/java/org/jsoup/nodes/FormElement.java']
['Jsoup-43', 1, 1, 1, 1, [' for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); if (element.equals(search)) return i; } return null;'], [' for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); if (element == search) return i; } return null;'], ['if (element.equals(search))'], ['if (element == search)'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-44', 1, 1, 1, 1, ['protected abstract boolean process(Token token); protected boolean processStartTag(String name) { return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { return process(end.reset().name(name)); }'], ["protected abstract boolean process(Token token); protected boolean processStartTag(String name) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); } return process(end.reset().name(name)); }"], [''], ["if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); }"], 'a/src/main/java/org/jsoup/parser/TreeBuilder.java', 'b/src/main/java/org/jsoup/parser/TreeBuilder.java']
['Jsoup-45', 1, 1, 1, 1, ['if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag } else if (("td".equals(name) || "td".equals(name) && !last)) { transition(HtmlTreeBuilderState.InCell); break; } else if ("tr".equals(name)) {'], ['if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag } else if (("td".equals(name) || "th".equals(name) && !last)) { transition(HtmlTreeBuilderState.InCell); break; } else if ("tr".equals(name)) {'], ['} else if (("td".equals(name) || "td".equals(name) && !last)) {'], ['} else if (("td".equals(name) || "th".equals(name) && !last)) {'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-46', 1, 1, 1, 1, ['if (escapeMode != EscapeMode.xhtml) accum.append("&nbsp;"); else accum.append(c); break; case \'<\': if (!inAttribute)'], ['if (escapeMode != EscapeMode.xhtml) accum.append("&nbsp;"); else accum.append("&#xa0;"); break; case \'<\': if (!inAttribute)'], ['accum.append(c);'], ['accum.append("&#xa0;");'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-47', 1, 1, 1, 1, ['break; case \'<\': // escape when in character data or when in a xml attribue val; not needed in html attr val if (!inAttribute) accum.append("&lt;"); else accum.append(c);'], ['break; case \'<\': // escape when in character data or when in a xml attribue val; not needed in html attr val if (!inAttribute || escapeMode == EscapeMode.xhtml) accum.append("&lt;"); else accum.append(c);'], ['if (!inAttribute)'], ['if (!inAttribute || escapeMode == EscapeMode.xhtml)'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-48', 1, 1, 1, 1, ['cookie(cookieName, cookieVal); } } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 if (!values.isEmpty()) header(name, values.get(0)); } } }'], ['cookie(cookieName, cookieVal); } } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 if (values.size() == 1) header(name, values.get(0)); else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(", "); accum.append(val); } header(name, accum.toString()); } } } }'], ['if (!values.isEmpty())'], ['if (values.size() == 1) else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(", "); accum.append(val); } header(name, accum.toString()); }'], 'a/src/main/java/org/jsoup/helper/HttpConnection.java', 'b/src/main/java/org/jsoup/helper/HttpConnection.java']
['Jsoup-49', 1, 1, 1, 1, ['Node in = children[i]; reparentChild(in); childNodes.add(index, in); } reindexChildren(index); } protected void ensureChildNodes() {'], ['Node in = children[i]; reparentChild(in); childNodes.add(index, in); reindexChildren(index); } } protected void ensureChildNodes() {'], ['reindexChildren(index);'], ['reindexChildren(index);'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-50', 2, 2, 2, 2, ['Document doc = null; // look for BOM - overrides any other header or input if (charsetName == null) { // determine from meta. safe parse as UTF-8 // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">', 'Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) { byteData.rewind(); docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; doc = null; } if (doc == null) { doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);'], ['Document doc = null; // look for BOM - overrides any other header or input byteData.mark(); byte[] bom = new byte[4]; byteData.get(bom); byteData.rewind(); if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE charsetName = "UTF-32"; // and I hope it\'s on your system } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { charsetName = "UTF-16"; // in all Javas } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { charsetName = "UTF-8"; // in all Javas byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed } if (charsetName == null) { // determine from meta. safe parse as UTF-8 // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">', 'Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (doc == null) { doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);'], ['', 'if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) { byteData.rewind(); docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; doc = null; }'], ['byteData.mark(); byte[] bom = new byte[4]; byteData.get(bom); byteData.rewind(); if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE charsetName = "UTF-32"; // and I hope it\'s on your system } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { charsetName = "UTF-16"; // in all Javas } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { charsetName = "UTF-8"; // in all Javas byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed }', ''], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-51', 1, 1, 1, 1, ["if (isEmpty()) return false; char c = input[pos]; return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); } boolean matchesDigit() {"], ["if (isEmpty()) return false; char c = input[pos]; return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c); } boolean matchesDigit() {"], ["return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');"], ["return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);"], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-52', 4, 4, 4, 4, ['foundCharset = getCharsetFromContentType(meta.attr("content")); } if (foundCharset == null && meta.hasAttr("charset")) { try { if (Charset.isSupported(meta.attr("charset"))) { foundCharset = meta.attr("charset"); } } catch (IllegalCharsetNameException e) { foundCharset = null; } } } // look for <?xml encoding=\'ISO-8859-1\'?>', '@return XML declaration */ public String getWholeDeclaration() { final String decl = this.name; if(decl.equals("xml") && attributes.size() > 1 ) { StringBuilder sb = new StringBuilder(decl); final String version = attributes.get("version"); if( version != null ) { sb.append(" version=\\"").append(version).append("\\""); } final String encoding = attributes.get("encoding"); if( encoding != null ) { sb.append(" encoding=\\"").append(encoding).append("\\""); } return sb.toString(); } else { return this.name; } } void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { accum .append("<") .append(isProcessingInstruction ? "!" : "?") .append(getWholeDeclaration()) .append(">"); }', 'package org.jsoup.parser; import org.jsoup.helper.Validate; import org.jsoup.nodes.*;', '// so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!")); } } insertNode(insert);'], ['foundCharset = getCharsetFromContentType(meta.attr("content")); } if (foundCharset == null && meta.hasAttr("charset")) { foundCharset = meta.attr("charset"); } } // look for <?xml encoding=\'ISO-8859-1\'?>', '@return XML declaration */ public String getWholeDeclaration() { return attributes.html().trim(); // attr html starts with a " " } void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { accum .append("<") .append(isProcessingInstruction ? "!" : "?") .append(name); attributes.html(accum, out); accum .append(isProcessingInstruction ? "!" : "?") .append(">"); }', 'package org.jsoup.parser; import org.jsoup.Jsoup; import org.jsoup.helper.Validate; import org.jsoup.nodes.*;', '// so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith("!")); insert.attributes().addAll(el.attributes()); } } insertNode(insert);'], ['try { if (Charset.isSupported(meta.attr("charset"))) { } } catch (IllegalCharsetNameException e) { foundCharset = null; }', 'final String decl = this.name; if(decl.equals("xml") && attributes.size() > 1 ) { StringBuilder sb = new StringBuilder(decl); final String version = attributes.get("version"); if( version != null ) { sb.append(" version=\\"").append(version).append("\\""); } final String encoding = attributes.get("encoding"); if( encoding != null ) { sb.append(" encoding=\\"").append(encoding).append("\\""); } return sb.toString(); } else { return this.name; } .append(getWholeDeclaration())', '', 'String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!"));'], ['', 'return attributes.html().trim(); // attr html starts with a " " .append(name); attributes.html(accum, out); accum .append(isProcessingInstruction ? "!" : "?")', 'import org.jsoup.Jsoup;', 'Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith("!")); insert.attributes().addAll(el.attributes());'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-53', 1, 1, 1, 1, ['int end = -1; int depth = 0; char last = 0; do { if (isEmpty()) break; Character c = consume(); if (last == 0 || last != ESC) { if (c.equals(open)) { depth++; if (start == -1)'], ['int end = -1; int depth = 0; char last = 0; boolean inQuote = false; do { if (isEmpty()) break; Character c = consume(); if (last == 0 || last != ESC) { if (c.equals(\'\\\'\') || c.equals(\'"\') && c != open) inQuote = !inQuote; if (inQuote) continue; if (c.equals(open)) { depth++; if (start == -1)'], [''], ['boolean inQuote = false; if (c.equals(\'\\\'\') || c.equals(\'"\') && c != open) inQuote = !inQuote; if (inQuote) continue;'], 'a/src/main/java/org/jsoup/parser/TokenQueue.java', 'b/src/main/java/org/jsoup/parser/TokenQueue.java']
['Jsoup-54', 1, 1, 1, 1, ['for (Attribute attribute : source.attributes()) { // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.] String key = attribute.getKey().replaceAll("[^-a-zA-Z0-9_:.]", ""); el.setAttribute(key, attribute.getValue()); } }'], ['for (Attribute attribute : source.attributes()) { // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.] String key = attribute.getKey().replaceAll("[^-a-zA-Z0-9_:.]", ""); if (key.matches("[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*")) el.setAttribute(key, attribute.getValue()); } }'], [''], ['if (key.matches("[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*"))'], 'a/src/main/java/org/jsoup/helper/W3CDom.java', 'b/src/main/java/org/jsoup/helper/W3CDom.java']
['Jsoup-55', 1, 1, 1, 1, ['break; default: t.error(this); t.transition(BeforeAttributeName); } }'], ['break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }'], [''], ['r.unconsume();'], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-56', 10, 10, 10, 10, ['public static final String PUBLIC_KEY = "PUBLIC"; public static final String SYSTEM_KEY = "SYSTEM"; private static final String NAME = "name"; private static final String PUBLIC_ID = "publicId"; private static final String SYSTEM_ID = "systemId"; // todo: quirk mode from publicId and systemId', ' attr(NAME, name); attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); }', "* @param systemId the doctype's system ID * @param baseUri the doctype's base URI */ @Override public String nodeName() {", '} if (has(NAME)) accum.append(" ").append(attr(NAME)); if (has(PUBLIC_ID)) accum.append(" PUBLIC \\"").append(attr(PUBLIC_ID)).append(\'"\'); if (has(SYSTEM_ID)) accum.append(" \\"").append(attr(SYSTEM_ID)).append(\'"\'); accum.append(\'>\');', '// todo: quirk state check on doctype ids Token.Doctype d = t.asDoctype(); DocumentType doctype = new DocumentType( tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri()); tb.getDocument().appendChild(doctype); if (d.isForceQuirks()) tb.getDocument().quirksMode(Document.QuirksMode.quirks);', ' static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false;', '@Override Token reset() { reset(name); reset(publicIdentifier); reset(systemIdentifier); forceQuirks = false;', 'return name.toString(); } String getPublicIdentifier() { return publicIdentifier.toString();', 't.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.transition(AfterDoctypeSystemKeyword); } else { t.error(this);', '} void insert(Token.Doctype d) { DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri); insertNode(doctypeNode); }'], ['public static final String PUBLIC_KEY = "PUBLIC"; public static final String SYSTEM_KEY = "SYSTEM"; private static final String NAME = "name"; private static final String PUB_SYS_KEY = "pubSysKey"; // PUBLIC or SYSTEM private static final String PUBLIC_ID = "publicId"; private static final String SYSTEM_ID = "systemId"; // todo: quirk mode from publicId and systemId', ' attr(NAME, name); attr(PUBLIC_ID, publicId); if (has(PUBLIC_ID)) { attr(PUB_SYS_KEY, PUBLIC_KEY); } attr(SYSTEM_ID, systemId); }', "* @param systemId the doctype's system ID * @param baseUri the doctype's base URI */ public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); if (pubSysKey != null) { attr(PUB_SYS_KEY, pubSysKey); } attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } @Override public String nodeName() {", '} if (has(NAME)) accum.append(" ").append(attr(NAME)); if (has(PUB_SYS_KEY)) accum.append(" ").append(attr(PUB_SYS_KEY)); if (has(PUBLIC_ID)) accum.append(" \\"").append(attr(PUBLIC_ID)).append(\'"\'); if (has(SYSTEM_ID)) accum.append(" \\"").append(attr(SYSTEM_ID)).append(\'"\'); accum.append(\'>\');', '// todo: quirk state check on doctype ids Token.Doctype d = t.asDoctype(); DocumentType doctype = new DocumentType( tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri()); tb.getDocument().appendChild(doctype); if (d.isForceQuirks()) tb.getDocument().quirksMode(Document.QuirksMode.quirks);', ' static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); String pubSysKey = null; final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false;', '@Override Token reset() { reset(name); pubSysKey = null; reset(publicIdentifier); reset(systemIdentifier); forceQuirks = false;', 'return name.toString(); } String getPubSysKey() { return pubSysKey; } String getPublicIdentifier() { return publicIdentifier.toString();', 't.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY; t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY; t.transition(AfterDoctypeSystemKeyword); } else { t.error(this);', '} void insert(Token.Doctype d) { DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri); insertNode(doctypeNode); }'], ['', '', '', 'accum.append(" PUBLIC \\"").append(attr(PUBLIC_ID)).append(\'"\');', 'tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());', '', '', '', '', 'DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);'], ['private static final String PUB_SYS_KEY = "pubSysKey"; // PUBLIC or SYSTEM', 'if (has(PUBLIC_ID)) { attr(PUB_SYS_KEY, PUBLIC_KEY); }', 'public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); if (pubSysKey != null) { attr(PUB_SYS_KEY, pubSysKey); } attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); }', 'if (has(PUB_SYS_KEY)) accum.append(" ").append(attr(PUB_SYS_KEY)); accum.append(" \\"").append(attr(PUBLIC_ID)).append(\'"\');', 'tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());', 'String pubSysKey = null;', 'pubSysKey = null;', 'String getPubSysKey() { return pubSysKey; }', 't.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY; t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;', 'DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-57', 1, 1, 1, 1, ['for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) attributes.remove(attrKey); } }'], ['for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) it.remove(); } }'], ['attributes.remove(attrKey);'], ['it.remove();'], 'a/src/main/java/org/jsoup/nodes/Attributes.java', 'b/src/main/java/org/jsoup/nodes/Attributes.java']
['Jsoup-58', 4, 4, 4, 4, ['@see #clean(String, org.jsoup.safety.Whitelist) */ public static boolean isValid(String bodyHtml, Whitelist whitelist) { return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, "")); } }', '* * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified. */ /** * Parse a fragment of XML into a list of nodes.', 'import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; /**', ' Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; } /** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.'], ['@see #clean(String, org.jsoup.safety.Whitelist) */ public static boolean isValid(String bodyHtml, Whitelist whitelist) { return new Cleaner(whitelist).isValidBodyHtml(bodyHtml); } }', '* * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified. */ public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder(); return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings()); } /** * Parse a fragment of XML into a list of nodes.', 'import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import java.util.List; /**', ' Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0 && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there\'s nothing in the head } public boolean isValidBodyHtml(String bodyHtml) { Document clean = Document.createShell(""); Document dirty = Document.createShell(""); ParseErrorList errorList = ParseErrorList.tracking(1); List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), "", errorList); dirty.body().insertChildren(0, nodes); int numDiscarded = copySafeNodes(dirty.body(), clean.body()); return numDiscarded == 0 && errorList.size() == 0; } /** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.'], ['return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, ""));', '', '', 'return numDiscarded == 0;'], ['return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);', 'public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder(); return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings()); }', 'import java.util.List;', 'return numDiscarded == 0 && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there\'s nothing in the head public boolean isValidBodyHtml(String bodyHtml) { Document clean = Document.createShell(""); Document dirty = Document.createShell(""); ParseErrorList errorList = ParseErrorList.tracking(1); List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), "", errorList); dirty.body().insertChildren(0, nodes); int numDiscarded = copySafeNodes(dirty.body(), clean.body()); return numDiscarded == 0 && errorList.size() == 0; }'], 'a/src/main/java/org/jsoup/safety/Cleaner.java', 'b/src/main/java/org/jsoup/safety/Cleaner.java']
['Jsoup-59', 2, 2, 2, 2, ['if (pendingAttributeName != null) { // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here pendingAttributeName = pendingAttributeName.trim(); Attribute attribute; if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName,', 'else attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); } pendingAttributeName = null; hasEmptyAttributeValue = false;'], ['if (pendingAttributeName != null) { // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here pendingAttributeName = pendingAttributeName.trim(); if (pendingAttributeName.length() > 0) { Attribute attribute; if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName,', 'else attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); } } pendingAttributeName = null; hasEmptyAttributeValue = false;'], ['', ''], ['if (pendingAttributeName.length() > 0) {', '}'], 'a/src/main/java/org/jsoup/parser/Token.java', 'b/src/main/java/org/jsoup/parser/Token.java']
['Jsoup-60', 2, 2, 2, 2, ['last = c; } while (depth > 0); final String out = (end >= 0) ? queue.substring(start, end) : ""; return out; }', '* @return Evaluator */ public static Evaluator parse(String query) { QueryParser p = new QueryParser(query); return p.parse(); } /**'], ['last = c; } while (depth > 0); final String out = (end >= 0) ? queue.substring(start, end) : ""; if (depth > 0) {// ran out of queue before seeing enough ) Validate.fail("Did not find balanced maker at " + out); } return out; }', '* @return Evaluator */ public static Evaluator parse(String query) { try { QueryParser p = new QueryParser(query); return p.parse(); } catch (IllegalArgumentException e) { throw new Selector.SelectorParseException(e.getMessage()); } } /**'], ['', ''], ['if (depth > 0) {// ran out of queue before seeing enough ) Validate.fail("Did not find balanced maker at " + out); }', 'try { } catch (IllegalArgumentException e) { throw new Selector.SelectorParseException(e.getMessage()); }'], 'a/src/main/java/org/jsoup/select/QueryParser.java', 'b/src/main/java/org/jsoup/select/QueryParser.java']
['Jsoup-61', 1, 1, 1, 1, ['*/ // performance sensitive public boolean hasClass(String className) { final String classAttr = attributes.get("class"); final int len = classAttr.length(); final int wantLen = className.length();'], ['*/ // performance sensitive public boolean hasClass(String className) { final String classAttr = attributes.getIgnoreCase("class"); final int len = classAttr.length(); final int wantLen = className.length();'], ['final String classAttr = attributes.get("class");'], ['final String classAttr = attributes.getIgnoreCase("class");'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-62', 1, 1, 1, 1, ['} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().normalName(); ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos);'], ['} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().name(); // matches with case sensitivity if enabled ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos);'], ['String name = t.asEndTag().normalName();'], ['String name = t.asEndTag().name(); // matches with case sensitivity if enabled'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-63', 5, 5, 5, 5, ['insertNode(el); if (startTag.isSelfClosing()) { if (tag.isKnownTag()) { if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); } else { tag.setSelfClosing(); tokeniser.acknowledgeSelfClosingFlag(); } } return el; }', 'Token.Doctype doctypePending = new Token.Doctype(); // doctype building up Token.Comment commentPending = new Token.Comment(); // comment building up private String lastStartTag; // the last start tag emitted, to test appropriate end tag private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) { this.reader = reader;', '} Token read() { if (!selfClosingFlagAcknowledged) { error("Self closing flag not acknowledged"); selfClosingFlagAcknowledged = true; } while (!isEmitPending) state.read(this, reader);', 'if (token.type == Token.TokenType.StartTag) { Token.StartTag startTag = (Token.StartTag) token; lastStartTag = startTag.tagName; if (startTag.selfClosing) selfClosingFlagAcknowledged = false; } else if (token.type == Token.TokenType.EndTag) { Token.EndTag endTag = (Token.EndTag) token; if (endTag.attributes != null)', 'this.state = state; } void acknowledgeSelfClosingFlag() { selfClosingFlagAcknowledged = true; } final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays final private int[] multipointHolder = new int[2]; int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {'], ['insertNode(el); if (startTag.isSelfClosing()) { if (tag.isKnownTag()) { if (!tag.isEmpty()) tokeniser.error("Tag cannot be self closing; not a void tag"); } else // unknown tag, remember this is self closing for output tag.setSelfClosing(); } return el; }', 'Token.Doctype doctypePending = new Token.Doctype(); // doctype building up Token.Comment commentPending = new Token.Comment(); // comment building up private String lastStartTag; // the last start tag emitted, to test appropriate end tag Tokeniser(CharacterReader reader, ParseErrorList errors) { this.reader = reader;', '} Token read() { while (!isEmitPending) state.read(this, reader);', 'if (token.type == Token.TokenType.StartTag) { Token.StartTag startTag = (Token.StartTag) token; lastStartTag = startTag.tagName; } else if (token.type == Token.TokenType.EndTag) { Token.EndTag endTag = (Token.EndTag) token; if (endTag.attributes != null)', 'this.state = state; } final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays final private int[] multipointHolder = new int[2]; int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {'], ['if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); else { tokeniser.acknowledgeSelfClosingFlag(); }', 'private boolean selfClosingFlagAcknowledged = true;', 'if (!selfClosingFlagAcknowledged) { error("Self closing flag not acknowledged"); selfClosingFlagAcknowledged = true; }', 'if (startTag.selfClosing) selfClosingFlagAcknowledged = false;', 'void acknowledgeSelfClosingFlag() { selfClosingFlagAcknowledged = true; }'], ['if (!tag.isEmpty()) tokeniser.error("Tag cannot be self closing; not a void tag"); else // unknown tag, remember this is self closing for output', '', '', '', ''], 'a/src/main/java/org/jsoup/parser/Tokeniser.java', 'b/src/main/java/org/jsoup/parser/Tokeniser.java']
['Jsoup-64', 1, 1, 1, 1, ['} private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) { tb.insert(startTag); tb.tokeniser.transition(TokeniserState.Rawtext); tb.markInsertionMode(); tb.transition(Text); } // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.'], ['} private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) { tb.tokeniser.transition(TokeniserState.Rawtext); tb.markInsertionMode(); tb.transition(Text); tb.insert(startTag); } // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.'], ['tb.insert(startTag);'], ['tb.insert(startTag);'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-65', 3, 3, 3, 3, ['} void clearStackToTableBodyContext() { clearStackToContext("tbody", "tfoot", "thead"); } void clearStackToTableRowContext() { clearStackToContext("tr"); } private void clearStackToContext(String... nodeNames) {', 'case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals("tr")) { tb.clearStackToTableBodyContext(); tb.insert(startTag); tb.transition(InRow);', 'Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (StringUtil.in(name, "th", "td")) { tb.clearStackToTableRowContext(); tb.insert(startTag); tb.transition(InCell);'], ['} void clearStackToTableBodyContext() { clearStackToContext("tbody", "tfoot", "thead", "template"); } void clearStackToTableRowContext() { clearStackToContext("tr", "template"); } private void clearStackToContext(String... nodeNames) {', 'case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals("template")) { tb.insert(startTag); } else if (name.equals("tr")) { tb.clearStackToTableBodyContext(); tb.insert(startTag); tb.transition(InRow);', 'Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals("template")) { tb.insert(startTag); } else if (StringUtil.in(name, "th", "td")) { tb.clearStackToTableRowContext(); tb.insert(startTag); tb.transition(InCell);'], ['clearStackToContext("tbody", "tfoot", "thead"); clearStackToContext("tr");', 'if (name.equals("tr")) {', 'if (StringUtil.in(name, "th", "td")) {'], ['clearStackToContext("tbody", "tfoot", "thead", "template"); clearStackToContext("tr", "template");', 'if (name.equals("template")) { tb.insert(startTag); } else if (name.equals("tr")) {', 'if (name.equals("template")) { tb.insert(startTag); } else if (StringUtil.in(name, "th", "td")) {'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-66', 2, 2, 2, 2, [' protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(4); } return childNodes; }', 'Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(childNodes.size()); clone.childNodes.addAll(childNodes); return clone; } private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { super(initialCapacity); } public void onContentsChanged() { nodelistChanged(); } } }'], [' protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(this, 4); } return childNodes; }', 'Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(clone, childNodes.size()); clone.childNodes.addAll(childNodes); return clone; } private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) { super(initialCapacity); this.owner = owner; } public void onContentsChanged() { owner.nodelistChanged(); } } }'], ['childNodes = new NodeList(4);', 'clone.childNodes = new NodeList(childNodes.size()); private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { nodelistChanged();'], ['childNodes = new NodeList(this, 4);', 'clone.childNodes = new NodeList(clone, childNodes.size()); private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) { this.owner = owner; owner.nodelistChanged();'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-67', 2, 2, 2, 2, ['"section", "select", "style", "summary", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "title", "tr", "ul", "wbr", "xmp"}); private HtmlTreeBuilderState state; // the current state private HtmlTreeBuilderState originalState; // original / marked state', ' private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { int depth = stack.size() -1; for (int pos = depth; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.nodeName();'], ['"section", "select", "style", "summary", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "title", "tr", "ul", "wbr", "xmp"}); public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages private HtmlTreeBuilderState state; // the current state private HtmlTreeBuilderState originalState; // original / marked state', ' private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { int depth = stack.size() -1; if (depth > MaxScopeSearchDepth) { depth = MaxScopeSearchDepth; } for (int pos = depth; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.nodeName();'], ['', ''], ['public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages', 'if (depth > MaxScopeSearchDepth) { depth = MaxScopeSearchDepth; }'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-68', 1, 1, 1, 1, [" private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; // don't walk too far up the tree"], [" private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope final int bottom = stack.size() -1; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; // don't walk too far up the tree"], ['int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; }'], ['final int bottom = stack.size() -1;'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-69', 1, 1, 1, 1, ['return this; } /** * Prepare to submit this form. A Connection object is created with the request set up from the form values. You'], ['return this; } @Override protected void removeChild(Node out) { super.removeChild(out); elements.remove(out); } /** * Prepare to submit this form. A Connection object is created with the request set up from the form values. You'], [''], ['@Override protected void removeChild(Node out) { super.removeChild(out); elements.remove(out); }'], 'a/src/main/java/org/jsoup/nodes/FormElement.java', 'b/src/main/java/org/jsoup/nodes/FormElement.java']
['Jsoup-70', 1, 1, 1, 1, ['// looks only at this element and five levels up, to prevent recursion & needless stack searches if (node != null && node instanceof Element) { Element el = (Element) node; if (el.tag.preserveWhitespace()) return true; else return el.parent() != null && el.parent().tag.preserveWhitespace(); } return false; }'], ['// looks only at this element and five levels up, to prevent recursion & needless stack searches if (node != null && node instanceof Element) { Element el = (Element) node; int i = 0; do { if (el.tag.preserveWhitespace()) return true; el = el.parent(); i++; } while (i < 6 && el != null); } return false; }'], ['else return el.parent() != null && el.parent().tag.preserveWhitespace();'], ['int i = 0; do { el = el.parent(); i++; } while (i < 6 && el != null);'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-71', 2, 4, 4, 4, ['import org.jsoup.nodes.DocumentType; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node; import org.jsoup.nodes.XmlDeclaration; import java.util.List;', 'evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else // unhandled throw new Selector.SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder());'], ['package org.jsoup.nodes; import org.jsoup.parser.Tag; import java.io.IOException; /** * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with * the {@link org.jsoup.select.Selector} {@code :matchText} syntax. */ public class PseudoTextElement extends Element { public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) { super(tag, baseUri, attributes); } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } }', 'import org.jsoup.nodes.DocumentType; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node; import org.jsoup.nodes.PseudoTextElement; import org.jsoup.nodes.TextNode; import org.jsoup.nodes.XmlDeclaration; import java.util.List;', '} } public static final class MatchText extends Evaluator { @Override public boolean matches(Element root, Element element) { if (element instanceof PseudoTextElement) return true; List<TextNode> textNodes = element.textNodes(); for (TextNode textNode : textNodes) { PseudoTextElement pel = new PseudoTextElement( org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes()); textNode.replaceWith(pel); pel.appendChild(textNode); } return false; } @Override public String toString() { return ":matchText"; } } }', 'evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else if (tq.matchChomp(":matchText")) evals.add(new Evaluator.MatchText()); else // unhandled throw new Selector.SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder());'], ['', '', '', ''], ['package org.jsoup.nodes; import org.jsoup.parser.Tag; import java.io.IOException; /** * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with * the {@link org.jsoup.select.Selector} {@code :matchText} syntax. */ public class PseudoTextElement extends Element { public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) { super(tag, baseUri, attributes); } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } }', 'import org.jsoup.nodes.PseudoTextElement; import org.jsoup.nodes.TextNode;', 'public static final class MatchText extends Evaluator { @Override public boolean matches(Element root, Element element) { if (element instanceof PseudoTextElement) return true; List<TextNode> textNodes = element.textNodes(); for (TextNode textNode : textNodes) { PseudoTextElement pel = new PseudoTextElement( org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes()); textNode.replaceWith(pel); pel.appendChild(textNode); } return false; } @Override public String toString() { return ":matchText"; } }', 'else if (tq.matchChomp(":matchText")) evals.add(new Evaluator.MatchText());'], 'a/src/main/java/org/jsoup/select/QueryParser.java', 'b/src/main/java/org/jsoup/select/QueryParser.java']
['Jsoup-72', 1, 1, 1, 1, ['// limit (no cache): if (count > maxStringCacheLen) return new String(charBuf, start, count); // calculate hash: int hash = 0;'], ['// limit (no cache): if (count > maxStringCacheLen) return new String(charBuf, start, count); if (count < 1) return ""; // calculate hash: int hash = 0;'], [''], ['if (count < 1) return "";'], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-73', 4, 4, 4, 4, ['import javax.xml.transform.stream.StreamResult; import java.io.StringWriter; import java.util.HashMap; /** * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},', 'private static final String xmlnsPrefix = "xmlns:"; private final Document doc; private final HashMap<String, String> namespaces = new HashMap<>(); private Element dest; public W3CBuilder(Document doc) { this.doc = doc; } public void head(org.jsoup.nodes.Node source, int depth) { if (source instanceof org.jsoup.nodes.Element) { org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source; String prefix = updateNamespaces(sourceEl); String namespace = namespaces.get(prefix); Element el = doc.createElementNS(namespace, sourceEl.tagName()); copyAttributes(sourceEl, el);', 'if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) { dest = (Element) dest.getParentNode(); // undescend. cromulent. } } private void copyAttributes(org.jsoup.nodes.Node source, Element el) {', '} else { continue; } namespaces.put(prefix, attr.getValue()); } // get the element prefix if any'], ['import javax.xml.transform.stream.StreamResult; import java.io.StringWriter; import java.util.HashMap; import java.util.Stack; /** * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},', 'private static final String xmlnsPrefix = "xmlns:"; private final Document doc; private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn private Element dest; public W3CBuilder(Document doc) { this.doc = doc; this.namespacesStack.push(new HashMap<String, String>()); } public void head(org.jsoup.nodes.Node source, int depth) { namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack if (source instanceof org.jsoup.nodes.Element) { org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source; String prefix = updateNamespaces(sourceEl); String namespace = namespacesStack.peek().get(prefix); Element el = doc.createElementNS(namespace, sourceEl.tagName()); copyAttributes(sourceEl, el);', 'if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) { dest = (Element) dest.getParentNode(); // undescend. cromulent. } namespacesStack.pop(); } private void copyAttributes(org.jsoup.nodes.Node source, Element el) {', '} else { continue; } namespacesStack.peek().put(prefix, attr.getValue()); } // get the element prefix if any'], ['', 'private final HashMap<String, String> namespaces = new HashMap<>(); String namespace = namespaces.get(prefix);', '', 'namespaces.put(prefix, attr.getValue());'], ['import java.util.Stack;', 'private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn this.namespacesStack.push(new HashMap<String, String>()); namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack String namespace = namespacesStack.peek().get(prefix);', 'namespacesStack.pop();', 'namespacesStack.peek().put(prefix, attr.getValue());'], 'a/src/main/java/org/jsoup/helper/W3CDom.java', 'b/src/main/java/org/jsoup/helper/W3CDom.java']
['Jsoup-74', 2, 2, 2, 2, ['// 160 is &nbsp; (non-breaking space). Not in the spec but expected. } // zero width sp, zw non join, zw join, soft hyphen /** * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters', "accum.append(' '); lastWasWhite = true; } else { accum.appendCodePoint(c); lastWasWhite = false; reachedNonWhite = true;"], ['// 160 is &nbsp; (non-breaking space). Not in the spec but expected. } public static boolean isInvisibleChar(int c) { return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173); // zero width sp, zw non join, zw join, soft hyphen } /** * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters', "accum.append(' '); lastWasWhite = true; } else if (!isInvisibleChar(c)) { accum.appendCodePoint(c); lastWasWhite = false; reachedNonWhite = true;"], ['', 'else {'], ['public static boolean isInvisibleChar(int c) { return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173); }', 'else if (!isInvisibleChar(c)) {'], 'a/src/main/java/org/jsoup/helper/StringUtil.java', 'b/src/main/java/org/jsoup/helper/StringUtil.java']
['Jsoup-75', 1, 1, 1, 1, ['accum.append(\' \').append(key); // collapse checked=null, checked="", checked=checked; write out others if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { accum.append("=\\""); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append(\'"\');'], ['accum.append(\' \').append(key); // collapse checked=null, checked="", checked=checked; write out others if (!Attribute.shouldCollapseAttribute(key, val, out)) { accum.append("=\\""); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append(\'"\');'], ['if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {'], ['if (!Attribute.shouldCollapseAttribute(key, val, out)) {'], 'a/src/main/java/org/jsoup/nodes/Attributes.java', 'b/src/main/java/org/jsoup/nodes/Attributes.java']
['Jsoup-76', 1, 1, 1, 1, ['tb.processEndTag("p"); } tb.insert(startTag); tb.framesetOk(false); } else if (name.equals("form")) { if (tb.getFormElement() != null) {'], ['tb.processEndTag("p"); } tb.insert(startTag); tb.reader.matchConsume("\\n"); // ignore LF if next token tb.framesetOk(false); } else if (name.equals("form")) { if (tb.getFormElement() != null) {'], [''], ['tb.reader.matchConsume("\\n"); // ignore LF if next token'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-77', 1, 1, 1, 1, ['* @param endTag tag to close */ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) {'], ['* @param endTag tag to close */ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.normalName(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) {'], ['String elName = endTag.name();'], ['String elName = endTag.normalName();'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-78', 2, 2, 2, 2, ['package org.jsoup.helper; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element;', 'if (charsetName == null) charsetName = defaultCharset; BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize); doc = parser.parseInput(reader, baseUri); // io exception when parsing (not seen before because reading the stream as we go) doc.outputSettings().charset(charsetName); } input.close();'], ['package org.jsoup.helper; import org.jsoup.UncheckedIOException; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element;', 'if (charsetName == null) charsetName = defaultCharset; BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize); try { doc = parser.parseInput(reader, baseUri); } catch (UncheckedIOException e) { // io exception when parsing (not seen before because reading the stream as we go) throw e.ioException(); } doc.outputSettings().charset(charsetName); } input.close();'], ['', ''], ['import org.jsoup.UncheckedIOException;', 'try { } catch (UncheckedIOException e) { throw e.ioException(); }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-79', 2, 2, 2, 2, [' import org.jsoup.helper.Validate; import java.util.List; abstract class LeafNode extends Node { Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)', ' @Override protected List<Node> ensureChildNodes() { throw new UnsupportedOperationException("Leaf Nodes do not have child nodes."); } }'], [' import org.jsoup.helper.Validate; import java.util.Collections; import java.util.List; abstract class LeafNode extends Node { private static final List<Node> EmptyNodes = Collections.emptyList(); Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)', ' @Override protected List<Node> ensureChildNodes() { return EmptyNodes; } }'], ['', 'throw new UnsupportedOperationException("Leaf Nodes do not have child nodes.");'], ['import java.util.Collections; private static final List<Node> EmptyNodes = Collections.emptyList();', 'return EmptyNodes;'], 'a/src/main/java/org/jsoup/nodes/LeafNode.java', 'b/src/main/java/org/jsoup/nodes/LeafNode.java']
['Jsoup-80', 1, 1, 1, 1, ['String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith("!")); insert.attributes().addAll(el.attributes()); } } insertNode(insert);'], ['String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); if (doc.childNodeSize() > 0) { Element el = doc.child(0); insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith("!")); insert.attributes().addAll(el.attributes()); } // else, we couldn\'t parse it as a decl, so leave as a comment } } insertNode(insert);'], [''], ["if (doc.childNodeSize() > 0) { } // else, we couldn't parse it as a decl, so leave as a comment"], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-81', 2, 2, 2, 2, [' import org.jsoup.UncheckedIOException; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node;', 'XmlDeclaration decl = null; if (first instanceof XmlDeclaration) decl = (XmlDeclaration) first; if (decl != null) { if (decl.name().equalsIgnoreCase("xml")) foundCharset = decl.attr("encoding");'], [' import org.jsoup.UncheckedIOException; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Comment; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node;', 'XmlDeclaration decl = null; if (first instanceof XmlDeclaration) decl = (XmlDeclaration) first; else if (first instanceof Comment) { Comment comment = (Comment) first; if (comment.isXmlDeclaration()) decl = comment.asXmlDeclaration(); } if (decl != null) { if (decl.name().equalsIgnoreCase("xml")) foundCharset = decl.attr("encoding");'], ['', ''], ['import org.jsoup.nodes.Comment;', 'else if (first instanceof Comment) { Comment comment = (Comment) first; if (comment.isXmlDeclaration()) decl = comment.asXmlDeclaration(); }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-82', 1, 1, 1, 1, ['} Charset charset = Charset.forName(charsetName); doc.outputSettings().charset(charset); // some charsets can read but not encode; switch to an encodable charset and update the meta el } input.close(); return doc;'], ['} Charset charset = Charset.forName(charsetName); doc.outputSettings().charset(charset); if (!charset.canEncode()) { // some charsets can read but not encode; switch to an encodable charset and update the meta el doc.charset(Charset.forName(defaultCharset)); } } input.close(); return doc;'], [''], ['if (!charset.canEncode()) { doc.charset(Charset.forName(defaultCharset)); }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-83', 4, 4, 4, 4, [" while (bufPos < remaining) { final char c = val[bufPos]; if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == TokeniserState.nullChar) break; bufPos++; }", "case '/': t.transition(SelfClosingStartTag); break; // intended fall through to next > case '>': t.emitTagPending();", "case '/': t.transition(SelfClosingStartTag); break; // intended fall through as if > case '>': t.emitTagPending();", 'break; case \'"\': case \'\\\'\': case \'<\': case \'=\': t.error(this); t.tagPending.newAttribute();'], [" while (bufPos < remaining) { final char c = val[bufPos]; if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == '<' || c == TokeniserState.nullChar) break; bufPos++; }", "case '/': t.transition(SelfClosingStartTag); break; case '<': // NOTE: out of spec, but clear author intent t.error(this); r.unconsume(); // intended fall through to next > case '>': t.emitTagPending();", "case '/': t.transition(SelfClosingStartTag); break; case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name) t.error(this); r.unconsume(); // intended fall through as if > case '>': t.emitTagPending();", 'break; case \'"\': case \'\\\'\': case \'=\': t.error(this); t.tagPending.newAttribute();'], ["if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == TokeniserState.nullChar)", '', '', "case '<':"], ["if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == '<' || c == TokeniserState.nullChar)", "case '<': // NOTE: out of spec, but clear author intent t.error(this); r.unconsume();", "case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name) t.error(this); r.unconsume();", ''], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-84', 1, 1, 1, 1, ['String namespace = namespacesStack.peek().get(prefix); String tagName = sourceEl.tagName(); Element el = doc.createElementNS(namespace, tagName); copyAttributes(sourceEl, el); if (dest == null) { // sets up the root'], ['String namespace = namespacesStack.peek().get(prefix); String tagName = sourceEl.tagName(); Element el = namespace == null && tagName.contains(":") ? doc.createElementNS("", tagName) : // doesn\'t have a real namespace defined doc.createElementNS(namespace, tagName); copyAttributes(sourceEl, el); if (dest == null) { // sets up the root'], ['Element el ='], ['Element el = namespace == null && tagName.contains(":") ? doc.createElementNS("", tagName) : // doesn\'t have a real namespace defined'], 'a/src/main/java/org/jsoup/helper/W3CDom.java', 'b/src/main/java/org/jsoup/helper/W3CDom.java']
['Jsoup-85', 1, 1, 1, 1, ['* @see #createFromEncoded*/ public Attribute(String key, String val, Attributes parent) { Validate.notNull(key); this.key = key.trim(); Validate.notEmpty(key); // trimming could potentially make empty, so validate here this.val = val; this.parent = parent; }'], ['* @see #createFromEncoded*/ public Attribute(String key, String val, Attributes parent) { Validate.notNull(key); key = key.trim(); Validate.notEmpty(key); // trimming could potentially make empty, so validate here this.key = key; this.val = val; this.parent = parent; }'], ['this.key = key.trim();'], ['key = key.trim(); this.key = key;'], 'a/src/main/java/org/jsoup/nodes/Attribute.java', 'b/src/main/java/org/jsoup/nodes/Attribute.java']
['Jsoup-86', 1, 1, 1, 1, ['String data = getData(); Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; if (doc.childNodeSize() > 0) { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith("!")); decl.attributes().addAll(el.attributes());'], ['String data = getData(); Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; if (doc.children().size() > 0) { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith("!")); decl.attributes().addAll(el.attributes());'], ['if (doc.childNodeSize() > 0) {'], ['if (doc.children().size() > 0) {'], 'a/src/main/java/org/jsoup/nodes/Comment.java', 'b/src/main/java/org/jsoup/nodes/Comment.java']
['Jsoup-87', 47, 47, 47, 47, ['* of the tag case preserving setting of the parser. * @return */ /** * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with', 'Element getFromStack(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { return next; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next.nodeName().equals(elName)) break; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (inSorted(next.nodeName(), elNames)) break; } }', 'void popStackToBefore(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { break; } else { stack.remove(pos);', 'private void clearStackToContext(String... nodeNames) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals("html")) break; else stack.remove(pos);', 'last = true; node = contextElement; } String name = node.nodeName(); if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag', "// don't walk too far up the tree for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes))", 'boolean inSelectScope(String targetName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.nodeName(); if (elName.equals(targetName)) return true; if (!inSorted(elName, TagSearchSelectScope)) // all elements except', 'process, then the UA must perform the above steps as if that element was not in the above list. */ void generateImpliedEndTags(String excludeTag) { while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) && inSorted(currentElement().nodeName(), TagSearchEndTags)) pop(); }', "boolean isSpecial(Element el) { // todo: mathml's mi, mo, mn // todo: svg's foreigObject, desc, title String name = el.nodeName(); return inSorted(name, TagSearchSpecial); }", ' private boolean isSameFormattingElement(Element a, Element b) { // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children return a.nodeName().equals(b.nodeName()) && // a.namespace().equals(b.namespace()) && a.attributes().equals(b.attributes()); // todo: namespaces', ' // 8. create new element from element, 9 insert into current node, onto stack skip = false; // can only skip increment from 4. Element newEl = insertStartTag(entry.nodeName()); // newEl.namespace(entry.namespace()); // todo: namespaces newEl.attributes().addAll(entry.attributes());', 'Element next = formattingElements.get(pos); if (next == null) // scope marker break; else if (next.nodeName().equals(nodeName)) return next; } return null;', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (el.nodeName().equals("li")) { tb.processEndTag("li"); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', '} else if (name.equals("body")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) { // only in fragment case return false; // ignore } else {', '} else if (name.equals("frameset")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) { // only in fragment case return false; // ignore } else if (!tb.framesetOk()) {', 'if (tb.inButtonScope("p")) { tb.processEndTag("p"); } if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) { tb.error(this); tb.pop(); }', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) { tb.processEndTag(el.nodeName()); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', 'else tb.transition(InSelect); } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { if (tb.currentElement().nodeName().equals("option")) tb.processEndTag("option"); tb.reconstructFormattingElements(); tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { if (tb.inScope("ruby")) { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals("ruby")) { tb.error(this); tb.popStackToBefore("ruby"); // i.e. close up to but not include name }', 'tb.error(this); tb.removeFromActiveFormattingElements(formatEl); return true; } else if (!tb.inScope(formatEl.nodeName())) { tb.error(this); return false; } else if (tb.currentElement() != formatEl)', '} } if (furthestBlock == null) { tb.popStackToClose(formatEl.nodeName()); tb.removeFromActiveFormattingElements(formatEl); return true; }', 'lastNode = node; } if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) { if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); // remove currentForm from stack. will shift anything under up. tb.removeFromStack(currentForm);', 'return tb.process(endTag); } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(Constants.Headings); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', '} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = tb.settings.normalizeTag(t.asEndTag().name()); ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (node.nodeName().equals(name)) { tb.generateImpliedEndTags(name); if (!name.equals(tb.currentElement().nodeName())) tb.error(this); tb.popStackToClose(name); break;', '} return true; // todo: as above todo } else if (t.isEOF()) { if (tb.currentElement().nodeName().equals("html")) tb.error(this); return true; // stops parsing }', 'boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); boolean processed; if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); processed = tb.process(t, InBody); tb.setFosterInserts(false);', 'if (!isWhitespace(character)) { // InTable anything else section: tb.error(this); if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); tb.process(new Token.Character().data(character), InBody); tb.setFosterInserts(false);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals("caption")) tb.error(this); tb.popStackToClose("caption"); tb.clearFormattingElementsToLastMarker();', 'case EndTag: Token.EndTag endTag = t.asEndTag(); if (endTag.normalName.equals("colgroup")) { if (tb.currentElement().nodeName().equals("html")) { tb.error(this); return false; } else {', 'return anythingElse(t, tb); break; case EOF: if (tb.currentElement().nodeName().equals("html")) return true; // stop parsing; frag case else return anythingElse(t, tb);', 'return false; } tb.clearStackToTableBodyContext(); tb.processEndTag(tb.currentElement().nodeName()); return tb.process(t); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', 'if (name.equals("html")) return tb.process(start, InBody); else if (name.equals("option")) { if (tb.currentElement().nodeName().equals("option")) tb.processEndTag("option"); tb.insert(start); } else if (name.equals("optgroup")) { if (tb.currentElement().nodeName().equals("option")) tb.processEndTag("option"); else if (tb.currentElement().nodeName().equals("optgroup")) tb.processEndTag("optgroup"); tb.insert(start); } else if (name.equals("select")) {', 'name = end.normalName(); switch (name) { case "optgroup": if (tb.currentElement().nodeName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals("optgroup")) tb.processEndTag("option"); if (tb.currentElement().nodeName().equals("optgroup")) tb.pop(); else tb.error(this); break; case "option": if (tb.currentElement().nodeName().equals("option")) tb.pop(); else tb.error(this);', '} break; case EOF: if (!tb.currentElement().nodeName().equals("html")) tb.error(this); break; default:', 'return false; } } else if (t.isEndTag() && t.asEndTag().normalName().equals("frameset")) { if (tb.currentElement().nodeName().equals("html")) { tb.error(this); return false; } else { tb.pop(); if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals("frameset")) { tb.transition(AfterFrameset); } } } else if (t.isEOF()) { if (!tb.currentElement().nodeName().equals("html")) { tb.error(this); return true; }', 'package org.jsoup.parser; import org.jsoup.helper.Validate; import java.util.HashMap; import java.util.Map;', 'private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags private String tagName; private boolean isBlock = true; // block or inline private boolean formatAsBlock = true; // should be formatted as a block private boolean canContainInline = true; // only pcdata if not', ' private Tag(String tagName) { this.tagName = tagName; } /**', "* Get this tag's normalized (lowercased) name. * @return the tag's normal name. */ /** * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything."], ['* of the tag case preserving setting of the parser. * @return */ public String normalName() { return tag.normalName(); } /** * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with', 'Element getFromStack(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.normalName().equals(elName)) { return next; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next.normalName().equals(elName)) break; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (inSorted(next.normalName(), elNames)) break; } }', 'void popStackToBefore(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.normalName().equals(elName)) { break; } else { stack.remove(pos);', 'private void clearStackToContext(String... nodeNames) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals("html")) break; else stack.remove(pos);', 'last = true; node = contextElement; } String name = node.normalName(); if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag', "// don't walk too far up the tree for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).normalName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes))", 'boolean inSelectScope(String targetName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.normalName(); if (elName.equals(targetName)) return true; if (!inSorted(elName, TagSearchSelectScope)) // all elements except', 'process, then the UA must perform the above steps as if that element was not in the above list. */ void generateImpliedEndTags(String excludeTag) { while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) && inSorted(currentElement().normalName(), TagSearchEndTags)) pop(); }', "boolean isSpecial(Element el) { // todo: mathml's mi, mo, mn // todo: svg's foreigObject, desc, title String name = el.normalName(); return inSorted(name, TagSearchSpecial); }", ' private boolean isSameFormattingElement(Element a, Element b) { // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children return a.normalName().equals(b.normalName()) && // a.namespace().equals(b.namespace()) && a.attributes().equals(b.attributes()); // todo: namespaces', ' // 8. create new element from element, 9 insert into current node, onto stack skip = false; // can only skip increment from 4. Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here? // newEl.namespace(entry.namespace()); // todo: namespaces newEl.attributes().addAll(entry.attributes());', 'Element next = formattingElements.get(pos); if (next == null) // scope marker break; else if (next.normalName().equals(nodeName)) return next; } return null;', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (el.normalName().equals("li")) { tb.processEndTag("li"); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', '} else if (name.equals("body")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) { // only in fragment case return false; // ignore } else {', '} else if (name.equals("frameset")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) { // only in fragment case return false; // ignore } else if (!tb.framesetOk()) {', 'if (tb.inButtonScope("p")) { tb.processEndTag("p"); } if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) { tb.error(this); tb.pop(); }', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) { tb.processEndTag(el.normalName()); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', 'else tb.transition(InSelect); } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { if (tb.currentElement().normalName().equals("option")) tb.processEndTag("option"); tb.reconstructFormattingElements(); tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { if (tb.inScope("ruby")) { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals("ruby")) { tb.error(this); tb.popStackToBefore("ruby"); // i.e. close up to but not include name }', 'tb.error(this); tb.removeFromActiveFormattingElements(formatEl); return true; } else if (!tb.inScope(formatEl.normalName())) { tb.error(this); return false; } else if (tb.currentElement() != formatEl)', '} } if (furthestBlock == null) { tb.popStackToClose(formatEl.normalName()); tb.removeFromActiveFormattingElements(formatEl); return true; }', 'lastNode = node; } if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) { if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); // remove currentForm from stack. will shift anything under up. tb.removeFromStack(currentForm);', 'return tb.process(endTag); } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(Constants.Headings); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', '} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (node.normalName().equals(name)) { tb.generateImpliedEndTags(name); if (!name.equals(tb.currentElement().normalName())) tb.error(this); tb.popStackToClose(name); break;', '} return true; // todo: as above todo } else if (t.isEOF()) { if (tb.currentElement().normalName().equals("html")) tb.error(this); return true; // stops parsing }', 'boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); boolean processed; if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); processed = tb.process(t, InBody); tb.setFosterInserts(false);', 'if (!isWhitespace(character)) { // InTable anything else section: tb.error(this); if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); tb.process(new Token.Character().data(character), InBody); tb.setFosterInserts(false);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals("caption")) tb.error(this); tb.popStackToClose("caption"); tb.clearFormattingElementsToLastMarker();', 'case EndTag: Token.EndTag endTag = t.asEndTag(); if (endTag.normalName.equals("colgroup")) { if (tb.currentElement().normalName().equals("html")) { // frag case tb.error(this); return false; } else {', 'return anythingElse(t, tb); break; case EOF: if (tb.currentElement().normalName().equals("html")) return true; // stop parsing; frag case else return anythingElse(t, tb);', 'return false; } tb.clearStackToTableBodyContext(); tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead return tb.process(t); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', 'if (name.equals("html")) return tb.process(start, InBody); else if (name.equals("option")) { if (tb.currentElement().normalName().equals("option")) tb.processEndTag("option"); tb.insert(start); } else if (name.equals("optgroup")) { if (tb.currentElement().normalName().equals("option")) tb.processEndTag("option"); else if (tb.currentElement().normalName().equals("optgroup")) tb.processEndTag("optgroup"); tb.insert(start); } else if (name.equals("select")) {', 'name = end.normalName(); switch (name) { case "optgroup": if (tb.currentElement().normalName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals("optgroup")) tb.processEndTag("option"); if (tb.currentElement().normalName().equals("optgroup")) tb.pop(); else tb.error(this); break; case "option": if (tb.currentElement().normalName().equals("option")) tb.pop(); else tb.error(this);', '} break; case EOF: if (!tb.currentElement().normalName().equals("html")) tb.error(this); break; default:', 'return false; } } else if (t.isEndTag() && t.asEndTag().normalName().equals("frameset")) { if (tb.currentElement().normalName().equals("html")) { // frag tb.error(this); return false; } else { tb.pop(); if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals("frameset")) { tb.transition(AfterFrameset); } } } else if (t.isEOF()) { if (!tb.currentElement().normalName().equals("html")) { tb.error(this); return true; }', 'package org.jsoup.parser; import org.jsoup.helper.Validate; import org.jsoup.internal.Normalizer; import java.util.HashMap; import java.util.Map;', 'private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags private String tagName; private String normalName; // always the lower case version of this tag, regardless of case preservation mode private boolean isBlock = true; // block or inline private boolean formatAsBlock = true; // should be formatted as a block private boolean canContainInline = true; // only pcdata if not', ' private Tag(String tagName) { this.tagName = tagName; normalName = Normalizer.lowerCase(tagName); } /**', "* Get this tag's normalized (lowercased) name. * @return the tag's normal name. */ public String normalName() { return normalName; } /** * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything."], ['', 'if (next.nodeName().equals(elName)) {', 'if (next.nodeName().equals(elName))', 'if (inSorted(next.nodeName(), elNames))', 'if (next.nodeName().equals(elName)) {', 'if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals("html"))', 'String name = node.nodeName();', 'final String elName = stack.get(pos).nodeName();', 'String elName = el.nodeName();', 'while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) && inSorted(currentElement().nodeName(), TagSearchEndTags))', 'String name = el.nodeName();', 'return a.nodeName().equals(b.nodeName()) &&', 'Element newEl = insertStartTag(entry.nodeName());', 'else if (next.nodeName().equals(nodeName))', 'if (el.nodeName().equals("li")) { if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {', 'if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {', 'if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) { tb.processEndTag(el.nodeName()); if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))', 'if (tb.currentElement().nodeName().equals("option")) if (!tb.currentElement().nodeName().equals("ruby")) {', '} else if (!tb.inScope(formatEl.nodeName())) {', 'tb.popStackToClose(formatEl.nodeName());', 'if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'String name = tb.settings.normalizeTag(t.asEndTag().name()); if (node.nodeName().equals(name)) { if (!name.equals(tb.currentElement().nodeName()))', 'if (tb.currentElement().nodeName().equals("html"))', 'if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (!tb.currentElement().nodeName().equals("caption"))', 'if (tb.currentElement().nodeName().equals("html")) {', 'if (tb.currentElement().nodeName().equals("html"))', 'tb.processEndTag(tb.currentElement().nodeName());', 'if (!tb.currentElement().nodeName().equals(name))', 'if (tb.currentElement().nodeName().equals("option")) if (tb.currentElement().nodeName().equals("option")) else if (tb.currentElement().nodeName().equals("optgroup"))', 'if (tb.currentElement().nodeName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals("optgroup")) if (tb.currentElement().nodeName().equals("optgroup")) if (tb.currentElement().nodeName().equals("option"))', 'if (!tb.currentElement().nodeName().equals("html"))', 'if (tb.currentElement().nodeName().equals("html")) { if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals("frameset")) { if (!tb.currentElement().nodeName().equals("html")) {', '', '', '', ''], ['public String normalName() { return tag.normalName(); }', 'if (next.normalName().equals(elName)) {', 'if (next.normalName().equals(elName))', 'if (inSorted(next.normalName(), elNames))', 'if (next.normalName().equals(elName)) {', 'if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals("html"))', 'String name = node.normalName();', 'final String elName = stack.get(pos).normalName();', 'String elName = el.normalName();', 'while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) && inSorted(currentElement().normalName(), TagSearchEndTags))', 'String name = el.normalName();', 'return a.normalName().equals(b.normalName()) &&', 'Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here?', 'else if (next.normalName().equals(nodeName))', 'if (el.normalName().equals("li")) { if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) {', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) {', 'if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) {', 'if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) { tb.processEndTag(el.normalName()); if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))', 'if (tb.currentElement().normalName().equals("option")) if (!tb.currentElement().normalName().equals("ruby")) {', '} else if (!tb.inScope(formatEl.normalName())) {', 'tb.popStackToClose(formatEl.normalName());', 'if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive if (node.normalName().equals(name)) { if (!name.equals(tb.currentElement().normalName()))', 'if (tb.currentElement().normalName().equals("html"))', 'if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (!tb.currentElement().normalName().equals("caption"))', 'if (tb.currentElement().normalName().equals("html")) { // frag case', 'if (tb.currentElement().normalName().equals("html"))', 'tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead', 'if (!tb.currentElement().normalName().equals(name))', 'if (tb.currentElement().normalName().equals("option")) if (tb.currentElement().normalName().equals("option")) else if (tb.currentElement().normalName().equals("optgroup"))', 'if (tb.currentElement().normalName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals("optgroup")) if (tb.currentElement().normalName().equals("optgroup")) if (tb.currentElement().normalName().equals("option"))', 'if (!tb.currentElement().normalName().equals("html"))', 'if (tb.currentElement().normalName().equals("html")) { // frag if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals("frameset")) { if (!tb.currentElement().normalName().equals("html")) {', 'import org.jsoup.internal.Normalizer;', 'private String normalName; // always the lower case version of this tag, regardless of case preservation mode', 'normalName = Normalizer.lowerCase(tagName);', 'public String normalName() { return normalName; }'], 'a/src/main/java/org/jsoup/parser/Tag.java', 'b/src/main/java/org/jsoup/parser/Tag.java']
['Jsoup-88', 1, 1, 1, 1, ['@return the attribute value */ public String getValue() { return val; } /**'], ['@return the attribute value */ public String getValue() { return Attributes.checkNotNull(val); } /**'], ['return val;'], ['return Attributes.checkNotNull(val);'], 'a/src/main/java/org/jsoup/nodes/Attribute.java', 'b/src/main/java/org/jsoup/nodes/Attribute.java']
['Jsoup-89', 1, 1, 1, 1, ['@param val the new attribute value; must not be null */ public String setValue(String val) { String oldVal = parent.get(this.key); if (parent != null) { int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.vals[i] = val;'], ['@param val the new attribute value; must not be null */ public String setValue(String val) { String oldVal = this.val; if (parent != null) { oldVal = parent.get(this.key); // trust the container more int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.vals[i] = val;'], ['String oldVal = parent.get(this.key);'], ['String oldVal = this.val; oldVal = parent.get(this.key); // trust the container more'], 'a/src/main/java/org/jsoup/nodes/Attribute.java', 'b/src/main/java/org/jsoup/nodes/Attribute.java']
['Jsoup-90', 1, 1, 1, 1, ['return false; } while (i < end) { i++;'], ['return false; } if (end >= input.length) return false; while (i < end) { i++;'], [''], ['if (end >= input.length) return false;'], 'a/src/main/java/org/jsoup/helper/HttpConnection.java', 'b/src/main/java/org/jsoup/helper/HttpConnection.java']
['Jsoup-91', 3, 3, 3, 3, ['super(cause); } public IOException ioException() { return (IOException) getCause();', 'charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz]; bufferUp(); } public CharacterReader(Reader input) {', 'return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1); } /** * Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be * decoded correctly, so a bunch of NULLs indicates a binary file */ @Override public String toString() {'], ['super(cause); } public UncheckedIOException(String message) { super(new IOException(message)); } public IOException ioException() { return (IOException) getCause();', 'charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz]; bufferUp(); if (isBinary()) { throw new UncheckedIOException("Input is binary and unsupported"); } } public CharacterReader(Reader input) {', "return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1); } private static final int numNullsConsideredBinary = 10; // conservative /** * Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be * decoded correctly, so a bunch of NULLs indicates a binary file */ boolean isBinary() { int nullsSeen = 0; for (int i = bufPos; i < bufLength; i++) { if (charBuf[i] == '\\0') nullsSeen++; } return nullsSeen >= numNullsConsideredBinary; } @Override public String toString() {"], ['', '', ''], ['public UncheckedIOException(String message) { super(new IOException(message)); }', 'if (isBinary()) { throw new UncheckedIOException("Input is binary and unsupported"); }', "private static final int numNullsConsideredBinary = 10; // conservative boolean isBinary() { int nullsSeen = 0; for (int i = bufPos; i < bufLength; i++) { if (charBuf[i] == '\\0') nullsSeen++; } return nullsSeen >= numNullsConsideredBinary; }"], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-92', 8, 8, 8, 8, ['import org.jsoup.SerializationException; import org.jsoup.helper.Validate; import org.jsoup.internal.StringUtil; import java.io.IOException; import java.util.AbstractMap;', '* Adds a new attribute. Will produce duplicates if the key already exists. * @see Attributes#put(String, String) */ private void add(String key, String value) { checkCapacity(size + 1); keys[size] = key; vals[size] = value; size++; } /**', '/** * Test if this Attributes list is empty (size==0). */ /** Add all the attributes from the incoming set to this set.', '* @param settings case sensitivity * @return number of removed dupes */ private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes;', " Element insert(final Token.StartTag startTag) { // cleanup duplicate attributes: // handle empty unknown tags // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.", '/** * Returns true if preserving attribute case. */ /** * Define parse settings.', 'else value = null; // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder). attributes.put(pendingAttributeName, value); } } pendingAttributeName = null;', "Element insert(Token.StartTag startTag) { Tag tag = Tag.valueOf(startTag.name(), settings); // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html. Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes)); insertNode(el);"], ['import org.jsoup.SerializationException; import org.jsoup.helper.Validate; import org.jsoup.internal.StringUtil; import org.jsoup.parser.ParseSettings; import java.io.IOException; import java.util.AbstractMap;', '* Adds a new attribute. Will produce duplicates if the key already exists. * @see Attributes#put(String, String) */ public Attributes add(String key, String value) { checkCapacity(size + 1); keys[size] = key; vals[size] = value; size++; return this; } /**', '/** * Test if this Attributes list is empty (size==0). */ public boolean isEmpty() { return size == 0; } /** Add all the attributes from the incoming set to this set.', "* @param settings case sensitivity * @return number of removed dupes */ public int deduplicate(ParseSettings settings) { if (isEmpty()) return 0; boolean preserve = settings.preserveAttributeCase(); int dupes = 0; OUTER: for (int i = 0; i < keys.length; i++) { for (int j = i + 1; j < keys.length; j++) { if (keys[j] == null) continue OUTER; // keys.length doesn't shrink when removing, so re-test if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) { dupes++; remove(j); j--; } } } return dupes; } private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes;", ' Element insert(final Token.StartTag startTag) { // cleanup duplicate attributes: if (!startTag.attributes.isEmpty()) { int dupes = startTag.attributes.deduplicate(settings); if (dupes > 0) { error("Duplicate attribute"); } } // handle empty unknown tags // when the spec expects an empty tag, will directly hit insertEmpty, so won\'t generate this fake end tag.', '/** * Returns true if preserving attribute case. */ public boolean preserveAttributeCase() { return preserveAttributeCase; } /** * Define parse settings.', 'else value = null; // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder). attributes.add(pendingAttributeName, value); } } pendingAttributeName = null;', "Element insert(Token.StartTag startTag) { Tag tag = Tag.valueOf(startTag.name(), settings); // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html. startTag.attributes.deduplicate(settings); Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes)); insertNode(el);"], ['', 'private void add(String key, String value) {', '', '', '', '', 'attributes.put(pendingAttributeName, value);', ''], ['import org.jsoup.parser.ParseSettings;', 'public Attributes add(String key, String value) { return this;', 'public boolean isEmpty() { return size == 0; }', "public int deduplicate(ParseSettings settings) { if (isEmpty()) return 0; boolean preserve = settings.preserveAttributeCase(); int dupes = 0; OUTER: for (int i = 0; i < keys.length; i++) { for (int j = i + 1; j < keys.length; j++) { if (keys[j] == null) continue OUTER; // keys.length doesn't shrink when removing, so re-test if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) { dupes++; remove(j); j--; } } } return dupes; }", 'if (!startTag.attributes.isEmpty()) { int dupes = startTag.attributes.deduplicate(settings); if (dupes > 0) { error("Duplicate attribute"); } }', 'public boolean preserveAttributeCase() { return preserveAttributeCase; }', 'attributes.add(pendingAttributeName, value);', 'startTag.attributes.deduplicate(settings);'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-93', 1, 1, 1, 1, ['if (name.length() == 0) continue; String type = el.attr("type"); if ("select".equals(el.normalName())) { Elements options = el.select("option[selected]");'], ['if (name.length() == 0) continue; String type = el.attr("type"); if (type.equalsIgnoreCase("button")) continue; // browsers don\'t submit these if ("select".equals(el.normalName())) { Elements options = el.select("option[selected]");'], [''], ['if (type.equalsIgnoreCase("button")) continue; // browsers don\'t submit these'], 'a/src/main/java/org/jsoup/nodes/FormElement.java', 'b/src/main/java/org/jsoup/nodes/FormElement.java']
