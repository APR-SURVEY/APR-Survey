['D4j_id: Math-94', 'Recoder_id: data1.pkl/57482', "D4j_rem: ['if (u * v == 0) {']", "D4j_add: ['if ((u == 0) || (v == 0)) {']", "D4j_bug: ['* @since 1.1 */ public static int gcd(int u, int v) { if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to']", "D4j_fix: ['* @since 1.1 */ public static int gcd(int u, int v) { if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to']", 'Recoder_bug: /** * <p> Gets the greatest common divisor of the absolute value of two numbers, using the "binary gcd" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). </p> * @param u a non-zero number * @param v a non-zero number * @return the greatest common divisor, never zero * @since 1.1 */ public static int gcd(int u,int v){ if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u=-u; } if (v > 0) { v=-v; } int k=0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u/=2; v/=2; k++; } if (k == 31) { throw new ArithmeticException("String_Node_Str"); } int t=((u & 1) == 1) ? v : -(u / 2); do { while ((t & 1) == 0) { t/=2; } if (t > 0) { u=-t; } else { v=t; } t=(v - u) / 2; } while (t != 0); return -u * (1 << k); }', 'Recoder_fix: /** * <p> Gets the greatest common divisor of the absolute value of two numbers, using the "binary gcd" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). </p> * @param u a non-zero number * @param v a non-zero number * @return the greatest common divisor, never zero * @since 1.1 */ public static int gcd(int u,int v){ if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u=-u; } if (v > 0) { v=-v; } int k=0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u/=2; v/=2; k++; } if (k == 31) { throw new ArithmeticException("String_Node_Str"); } int t=((u & 1) == 1) ? v : -(u / 2); do { while ((t & 1) == 0) { t/=2; } if (t > 0) { u=-t; } else { v=t; } t=(v - u) / 2; } while (t != 0); return -u * (1 << k); }']
['D4j_id: Math-70', 'Recoder_id: data1.pkl/61459', "D4j_rem: ['return solve(min, max);']", "D4j_add: ['return solve(f, min, max);']", "D4j_bug: ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); } /** {@inheritDoc} */']", "D4j_fix: ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(f, min, max); } /** {@inheritDoc} */']", 'Recoder_bug: /** * Math 70 bug can be fixed by replacing a method invocation inside a return statement. + return solve(f, min, max); - return solve(min, max); One solution with local scope, another with package This test validates the stats via API and JSON * @throws Exception */ @SuppressWarnings("String_Node_Str") @Test public void testMath70LocalOutputs() throws Exception { AstorMain main1=new AstorMain(); String dep=new File("String_Node_Str").getAbsolutePath(); File out=new File(ConfigurationProperties.getProperty("String_Node_Str")); int generations=50; String[] args=commandMath70(dep,out,generations); CommandSummary cs=new CommandSummary(args); cs.command.put("String_Node_Str","String_Node_Str"); System.out.println(Arrays.toString(cs.flat())); main1.execute(cs.flat()); List<ProgramVariant> solutions=main1.getEngine().getSolutions(); assertTrue(solutions.size() > 0); assertEquals(1,solutions.size()); Stats stats=Stats.createStat(); assertNotNull(stats); assertNotNull(stats.getStatsOfPatches()); assertTrue(stats.getStatsOfPatches().size() > 0); String jsonpath=main1.getEngine().getProjectFacade().getProperties().getWorkingDirRoot() + File.separator + ConfigurationProperties.getProperty("String_Node_Str")+ "String_Node_Str"; File filejson=new File(jsonpath); assertTrue(filejson.exists()); JSONParser parser=new JSONParser(); Object obj=parser.parse(new FileReader(filejson)); JSONObject jsonroot=(JSONObject)obj; JSONArray msg=(JSONArray)jsonroot.get("String_Node_Str"); assertEquals(1,msg.size()); JSONObject pob=(JSONObject)msg.get(0); JSONArray hunks=(JSONArray)pob.get("String_Node_Str"); assertEquals(1,hunks.size()); JSONObject hunkob=(JSONObject)hunks.get(0); assertEquals("String_Node_Str",hunkob.get(HunkStatEnum.PATCH_HUNK_CODE.name())); assertEquals("String_Node_Str",hunkob.get(HunkStatEnum.ORIGINAL_CODE.name())); assertEquals(1,stats.getStatsOfPatches().size()); PatchStat patchstats=stats.getStatsOfPatches().get(0); List<PatchHunkStats> hunksApi=(List<PatchHunkStats>)patchstats.getStats().get(PatchStatEnum.HUNKS); assertNotNull(hunksApi); PatchHunkStats hunkStats=hunksApi.get(0); assertNotNull(hunkStats); assertEquals("String_Node_Str",hunkStats.getStats().get(HunkStatEnum.PATCH_HUNK_CODE)); assertEquals("String_Node_Str",hunkob.get(HunkStatEnum.ORIGINAL_CODE.name())); }', 'Recoder_fix: /** * Math 70 bug can be fixed by replacing a method invocation inside a return statement. + return solve(f, min, max); - return solve(min, max); One solution with local scope, another with package This test validates the stats via API and JSON * @throws Exception */ @SuppressWarnings("String_Node_Str") @Test public void testMath70LocalOutputs() throws Exception { AstorMain main1=new AstorMain(); String dep=new File("String_Node_Str").getAbsolutePath(); File out=new File(ConfigurationProperties.getProperty("String_Node_Str")); int generations=50; String[] args=commandMath70(dep,out,generations); CommandSummary cs=new CommandSummary(args); cs.command.put("String_Node_Str","String_Node_Str"); System.out.println(Arrays.toString(cs.flat())); main1.execute(cs.flat()); List<ProgramVariant> solutions=main1.getEngine().getSolutions(); assertTrue(solutions.size() > 0); assertEquals(1,solutions.size()); Stats stats=Stats.getCurrentStat(); assertNotNull(stats); assertNotNull(stats.getStatsOfPatches()); assertTrue(stats.getStatsOfPatches().size() > 0); String jsonpath=main1.getEngine().getProjectFacade().getProperties().getWorkingDirRoot() + File.separator + ConfigurationProperties.getProperty("String_Node_Str")+ "String_Node_Str"; File filejson=new File(jsonpath); assertTrue(filejson.exists()); JSONParser parser=new JSONParser(); Object obj=parser.parse(new FileReader(filejson)); JSONObject jsonroot=(JSONObject)obj; JSONArray msg=(JSONArray)jsonroot.get("String_Node_Str"); assertEquals(1,msg.size()); JSONObject pob=(JSONObject)msg.get(0); JSONArray hunks=(JSONArray)pob.get("String_Node_Str"); assertEquals(1,hunks.size()); JSONObject hunkob=(JSONObject)hunks.get(0); assertEquals("String_Node_Str",hunkob.get(HunkStatEnum.PATCH_HUNK_CODE.name())); assertEquals("String_Node_Str",hunkob.get(HunkStatEnum.ORIGINAL_CODE.name())); assertEquals(1,stats.getStatsOfPatches().size()); PatchStat patchstats=stats.getStatsOfPatches().get(0); List<PatchHunkStats> hunksApi=(List<PatchHunkStats>)patchstats.getStats().get(PatchStatEnum.HUNKS); assertNotNull(hunksApi); PatchHunkStats hunkStats=hunksApi.get(0); assertNotNull(hunkStats); assertEquals("String_Node_Str",hunkStats.getStats().get(HunkStatEnum.PATCH_HUNK_CODE)); assertEquals("String_Node_Str",hunkob.get(HunkStatEnum.ORIGINAL_CODE.name())); }']
['D4j_id: Math-70', 'Recoder_id: data1.pkl/61608', "D4j_rem: ['return solve(min, max);']", "D4j_add: ['return solve(f, min, max);']", "D4j_bug: ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); } /** {@inheritDoc} */']", "D4j_fix: ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(f, min, max); } /** {@inheritDoc} */']", 'Recoder_bug: /** * Math 70 bug can be fixed by replacing a method invocation. + return solve(f, min, max); - return solve(min, max); * @throws Exception */ @Test public void testMath70() throws Exception { MainjGenProg main1=new MainjGenProg(); String dep="String_Node_Str"; File out=new File("String_Node_Str"); String[] args=new String[]{"String_Node_Str",dep,"String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str",new File("String_Node_Str").getAbsolutePath(),"String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str",out.getAbsolutePath(),"String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str"}; System.out.println(Arrays.toString(args)); main1.main(args); validatePatchExistence(out + File.separator + "String_Node_Str"); }', 'Recoder_fix: /** * Math 70 bug can be fixed by replacing a method invocation. + return solve(f, min, max); - return solve(min, max); * @throws Exception */ @Test public void testMath70() throws Exception { MainjGenProg main1=new MainjGenProg(); String dep="String_Node_Str"; File out=new File("String_Node_Str"); String[] args=new String[]{"String_Node_Str",dep,"String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str",new File("String_Node_Str").getAbsolutePath(),"String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str",out.getAbsolutePath(),"String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str","String_Node_Str"}; System.out.println(Arrays.toString(args)); main1.main(args); validatePatchExistence(out + File.separator + "String_Node_Str"); }']
['D4j_id: Closure-83', 'Recoder_id: data1.pkl/18859', "D4j_rem: ['String param = params.getParameter(0);']", "D4j_add: ['String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}']", "D4j_bug: [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = params.getParameter(0); if (param == null) { setter.addValue(true);']", "D4j_fix: [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true);']", 'Recoder_bug: @Override public int parseArguments(Parameters params) throws CmdLineException { String param=params.getParameter(0); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam=param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }', 'Recoder_fix: @Override public int parseArguments(Parameters params) throws CmdLineException { String param=null; try { param=params.getParameter(0); } catch ( CmdLineException e) { } if (param == null) { setter.addValue(true); return 0; } else { String lowerParam=param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }']
['D4j_id: Math-69', 'Recoder_id: data1.pkl/57381', "D4j_rem: ['out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));']", "D4j_add: ['out[i][j] = 2 * tDistribution.cumulativeProbability(-t);']", "D4j_bug: ['} else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); } } }']", "D4j_fix: ['} else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * tDistribution.cumulativeProbability(-t); } } }']", 'Recoder_bug: /** * Returns a matrix of p-values associated with the (two-sided) null hypothesis that the corresponding correlation coefficient is zero. <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability that a random variable distributed as <code>t<sub>n-2</sub></code> takes a value with absolute value greater than or equal to <br> <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p> <p>The values in the matrix are sometimes referred to as the <i>significance</i> of the corresponding correlation coefficients.</p> * @return matrix of p-values * @throws MathException if an error occurs estimating probabilities */ public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution=new TDistributionImpl(nObs - 2); int nVars=correlationMatrix.getColumnDimension(); double[][] out=new double[nVars][nVars]; for (int i=0; i < nVars; i++) { for (int j=0; j < nVars; j++) { if (i == j) { out[i][j]=0d; } else { double r=correlationMatrix.getEntry(i,j); double t=Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r))); out[i][j]=2 * (1 - tDistribution.cumulativeProbability(t)); } } } return new BlockRealMatrix(out); }', 'Recoder_fix: /** * Returns a matrix of p-values associated with the (two-sided) null hypothesis that the corresponding correlation coefficient is zero. <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability that a random variable distributed as <code>t<sub>n-2</sub></code> takes a value with absolute value greater than or equal to <br> <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p> <p>The values in the matrix are sometimes referred to as the <i>significance</i> of the corresponding correlation coefficients.</p> * @return matrix of p-values * @throws MathException if an error occurs estimating probabilities */ public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution=new TDistributionImpl(nObs - 2); int nVars=correlationMatrix.getColumnDimension(); double[][] out=new double[nVars][nVars]; for (int i=0; i < nVars; i++) { for (int j=0; j < nVars; j++) { if (i == j) { out[i][j]=0d; } else { double r=correlationMatrix.getEntry(i,j); double t=Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r))); out[i][j]=2 * tDistribution.cumulativeProbability(-t); } } } return new BlockRealMatrix(out); }']
['D4j_id: Math-79', 'Recoder_id: data1.pkl/57426', "D4j_rem: ['int sum = 0; final int dp = p1[i] - p2[i];']", "D4j_add: ['double sum = 0; final double dp = p1[i] - p2[i];']", "D4j_bug: ['* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);']", "D4j_fix: ['* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { double sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);']", 'Recoder_bug: /** * Calculates the L<sub>2</sub> (Euclidean) distance between two points. * @param p1 the first point * @param p2 the second point * @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1,int[] p2){ int sum=0; for (int i=0; i < p1.length; i++) { final int dp=p1[i] - p2[i]; sum+=dp * dp; } return Math.sqrt(sum); }', 'Recoder_fix: /** * Calculates the L<sub>2</sub> (Euclidean) distance between two points. * @param p1 the first point * @param p2 the second point * @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1,int[] p2){ double sum=0; for (int i=0; i < p1.length; i++) { final double dp=p1[i] - p2[i]; sum+=dp * dp; } return Math.sqrt(sum); }']
['D4j_id: Closure-119', 'Recoder_id: data0.pkl/27863', "D4j_rem: ['']", "D4j_add: ['case Token.CATCH:']", "D4j_bug: ['isSet = true; type = Name.Type.FUNCTION; break; case Token.INC: case Token.DEC: isSet = true;']", "D4j_fix: ['isSet = true; type = Name.Type.FUNCTION; break; case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;']", 'Recoder_bug: public void collect(JSModule module,Scope scope,Node n){ Node parent=n.getParent(); String name; boolean isSet=false; Name.Type type=Name.Type.OTHER; boolean isPropAssign=false; switch (n.getType()) { case Token.GETTER_DEF: case Token.SETTER_DEF: case Token.STRING_KEY: name=null; if (parent != null && parent.isObjectLit()) { name=getNameForObjLitKey(n); } if (name == null) { return; } isSet=true; switch (n.getType()) { case Token.STRING_KEY: type=getValueType(n.getFirstChild()); break; case Token.GETTER_DEF: type=Name.Type.GET; break; case Token.SETTER_DEF: type=Name.Type.SET; break; default : throw new IllegalStateException("String_Node_Str" + n); } break; case Token.NAME: if (parent != null) { switch (parent.getType()) { case Token.VAR: isSet=true; Node rvalue=n.getFirstChild(); type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue); break; case Token.ASSIGN: if (parent.getFirstChild() == n) { isSet=true; type=getValueType(n.getNext()); } break; case Token.GETPROP: return; case Token.FUNCTION: Node gramps=parent.getParent(); if (gramps == null || NodeUtil.isFunctionExpression(parent)) { return; } isSet=true; type=Name.Type.FUNCTION; break; case Token.INC: case Token.DEC: isSet=true; type=Name.Type.OTHER; break; default : if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet=true; type=Name.Type.OTHER; } } } name=n.getString(); break; case Token.GETPROP: if (parent != null) { switch (parent.getType()) { case Token.ASSIGN: if (parent.getFirstChild() == n) { isSet=true; type=getValueType(n.getNext()); isPropAssign=true; } break; case Token.INC: case Token.DEC: isSet=true; type=Name.Type.OTHER; break; case Token.GETPROP: return; default : if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet=true; type=Name.Type.OTHER; } } } name=n.getQualifiedName(); if (name == null) { return; } break; default : return; } if (!isGlobalNameReference(name,scope)) { return; } if (isSet) { if (isGlobalScope(scope)) { handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type); } else { handleSetFromLocal(module,scope,n,parent,name); } } else { handleGet(module,scope,n,parent,name); } }', 'Recoder_fix: public void collect(JSModule module,Scope scope,Node n){ Node parent=n.getParent(); String name; boolean isSet=false; Name.Type type=Name.Type.OTHER; boolean isPropAssign=false; switch (n.getType()) { case Token.GETTER_DEF: case Token.SETTER_DEF: case Token.STRING_KEY: name=null; if (parent != null && parent.isObjectLit()) { name=getNameForObjLitKey(n); } if (name == null) { return; } isSet=true; switch (n.getType()) { case Token.STRING_KEY: type=getValueType(n.getFirstChild()); break; case Token.GETTER_DEF: type=Name.Type.GET; break; case Token.SETTER_DEF: type=Name.Type.SET; break; default : throw new IllegalStateException("String_Node_Str" + n); } break; case Token.NAME: if (parent != null) { switch (parent.getType()) { case Token.VAR: isSet=true; Node rvalue=n.getFirstChild(); type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue); break; case Token.ASSIGN: if (parent.getFirstChild() == n) { isSet=true; type=getValueType(n.getNext()); } break; case Token.GETPROP: return; case Token.FUNCTION: Node gramps=parent.getParent(); if (gramps == null || NodeUtil.isFunctionExpression(parent)) { return; } isSet=true; type=Name.Type.FUNCTION; break; case Token.CATCH: case Token.INC: case Token.DEC: isSet=true; type=Name.Type.OTHER; break; default : if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet=true; type=Name.Type.OTHER; } } } name=n.getString(); break; case Token.GETPROP: if (parent != null) { switch (parent.getType()) { case Token.ASSIGN: if (parent.getFirstChild() == n) { isSet=true; type=getValueType(n.getNext()); isPropAssign=true; } break; case Token.INC: case Token.DEC: isSet=true; type=Name.Type.OTHER; break; case Token.GETPROP: return; default : if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet=true; type=Name.Type.OTHER; } } } name=n.getQualifiedName(); if (name == null) { return; } break; default : return; } if (!isGlobalNameReference(name,scope)) { return; } if (isSet) { if (isGlobalScope(scope)) { handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type); } else { handleSetFromLocal(module,scope,n,parent,name); } } else { handleGet(module,scope,n,parent,name); } }']
['D4j_id: Closure-120', 'Recoder_id: data0.pkl/27867', "D4j_rem: ['']", "D4j_add: ['if (ref.getSymbol().getScope() != ref.scope) { return false; }']", "D4j_bug: ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false;']", "D4j_fix: ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { if (ref.getSymbol().getScope() != ref.scope) { return false; } break; } else if (block.isLoop) { return false;']", 'Recoder_bug: /** * @return Whether the variable is only assigned a value once for itslifetime. */ boolean isAssignedOnceInLifetime(){ Reference ref=getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block=ref.getBasicBlock(); block != null; block=block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; } } return true; }', 'Recoder_fix: /** * @return Whether the variable is only assigned a value once for itslifetime. */ boolean isAssignedOnceInLifetime(){ Reference ref=getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block=ref.getBasicBlock(); block != null; block=block.getParent()) { if (block.isFunction) { if (ref.getSymbol().getScope() != ref.scope) { return false; } break; } else if (block.isLoop) { return false; } } return true; }']
['D4j_id: Closure-83', 'Recoder_id: data0.pkl/28180', "D4j_rem: ['String param = params.getParameter(0);']", "D4j_add: ['String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}']", "D4j_bug: [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = params.getParameter(0); if (param == null) { setter.addValue(true);']", "D4j_fix: [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true);']", 'Recoder_bug: @Override public int parseArguments(Parameters params) throws CmdLineException { String param=params.getParameter(0); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam=param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }', 'Recoder_fix: @Override public int parseArguments(Parameters params) throws CmdLineException { String param=null; try { param=params.getParameter(0); } catch ( CmdLineException e) { } if (param == null) { setter.addValue(true); return 0; } else { String lowerParam=param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }']
['D4j_id: Closure-121', 'Recoder_id: data0.pkl/27870']
